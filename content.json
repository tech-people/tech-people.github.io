{"meta":{"title":"People and Technology","subtitle":"피플앤드테크놀러지 기술 블로그 / Tech Blog","description":null,"author":"People and Technology","url":"http://yoursite.com","root":"/"},"pages":[{"title":"People and Technology","date":"2019-10-08T07:17:30.000Z","updated":"2021-11-13T10:48:21.533Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"피플앤드테크놀러지 피플앤드테크놀러지는 창립 이후로 Industrial IoT, Healthcare IoT, Building IoT 분야에서 국내외 총 30개가 넘는 고객을 확보하고 있는 국내 최고, World Class Level의 IoT Solution의 Leader 입니다. 피플앤드테크놀러지는 Bluetooth Low Energy 기반의 위치 측위 정밀도 1~2m 내외의 핵심기술을 활용하여 2014년 IndoorPlus+ LBS 및 IndoorPlus+ RTLS 제품 출시 이후 “LG 디스플레이 파주공장”, “한화 테크윈 방산공장”, “현대자동차 데이터센터”, ”아모레퍼시픽”, ”강북삼성병원” 등 산업용 IoT 및 Smart Factory의 사람 및 사물의 실시간 위치 추적 및. 모니터링 솔루션을 공급하여 작업자 안전관리(Workers Safety), 출입통제 보안(Security), 자산 관리(Asset Tracking), 공정 효율화 (Productivity) 등 Industry 4.0의 실제 적용 사례 창출을 주도하고 있습니다. 피플앤드테크놀러지는 세브란스 병원, 한양대병원, 부산대병원, 경북대병원, 호텔신라 면세점 등 Smart Phone 기반 Turn by Turn Indoor Presence 및 Navigation 시장의 No.1 Leading Provider로서 총 30개의 국내 각 비즈니스 분야의 주요 기업 및 기관에 솔루션을 공급 하였으며, 해외시장에도 진출하여 2개의 해외 레퍼런스를 확보하고 있습니다. 두 가지 유형의 솔루션을 동시에 제공하는 유일한 회사입니다 IndoorPlus+ 솔루션은 고정된 장소에 Bluetooth Beacon을 부착하여 주로 Smart Phone을 통해서 서비스를 제공하는 IndoorPlus+ LBS 솔루션과 움직이는 사람 및 Object에 Bluetooth Sensor Tag를 부착하고 Bluetooth Scanner &amp; Gateway를 통해 수집된 Signal 정보를 이용하여 서비스를 제공하는 IndoorPlus+ RTLS 등 총 2가지 솔루션을 제공합니다."}],"posts":[{"title":"카프카 1편 [구조 및 개념]","slug":"Kafka01","date":"2021-11-13T06:00:00.000Z","updated":"2021-11-13T11:45:11.468Z","comments":true,"path":"2021/11/13/Kafka01/","link":"","permalink":"http://yoursite.com/2021/11/13/Kafka01/","excerpt":"","text":"해당 글은 API 문서에 대한 독해 및 개인공부 글입니다. 따라서 개인적인 해석이 있을 수 있습니다. 1. 이벤트 스트리밍(event streaming)스트리밍(streaming) 이란 무엇일까? 스트리밍(streaming)은 ‘흐름’ 이라는 뜻으로 데이터가 흐른다는 뜻에서 사용하는 용어이다. 이러한 ‘흐름’을 통해 원하는 데이터를 보내기도 하고 받기도 할 수 있다. 이를 통해 실시간으로 분석 및 추가적인 로직을 통해 서비스를 제공할 수 있다. 결국 카프카에서 ‘이벤트 스트리밍(event streaming)’이란 일련의 데이터 흐름의 각각의 데이터 이벤트(event)를 지속적인 전달을 하는 스트리밍(streaming)이라는 개념을 갖는다. 2. 카프카의 핵심 3가지 이벤트 데이터 흐름에서 발행(publish)과 구독(subscribe)을 통해 하나의 시스템에서 또 다른 시스템으로 내보내기/가져오기를 할 수 있다. 이벤트 데이터를 내구성 있고 안정적으로 저장이 가능하다. 이벤트 스트리밍 과정에서 이벤트를 발생시키거나 소급이 가능하다. 위의 핵심 3가지 기능은 분산되고 확장성이 뛰어나고 탄력적이며 내결함성이 있으며 안전한 방식으로 제공이 된다. 또한 하드웨어, 가상 머신, 컨테이너, 온프레미스 및 클라우드에 배포할 수 있다. 3. 카프카의 서버와 클라이언트Kafka는 고성능 TCP 네트워크 프로토콜을 통해 통신하는 서버와 클라이언트로 구성된 분산 시스템이다. 서버: Kafka는 하나 이상의 서버의 클러스터로 실행된다. 이는 지속적으로 데이터를 가져오고 내보내 Kafka를 관계형 데이터베이스 및 다른 Kafka 클러스터와 같은 기존 시스템과 통합할 수 있다. 서버에 장애가 발생할 경우 다른 서버가 작업을 넘겨받아 데이터 손실 없이 지속적인 운영을 보장한다. 클라이언트: 네트워크 문제 또는 시스템 장애 발생 시에도 병렬, 규모 및 내결함성 방식으로 이벤트의 스트림을 읽고, 쓰고, 처리하는 분산 애플리케이션과 마이크로 서비스를 작성할 수 있다. 또한 클라이언트는 Kafk스트림 라이브러리, Go, Python, C/C++ 및 REST APIs를 포함한 자바와 스칼라에서 사용할 수 있다. 4. 작동 원리카프카는 일반적으로 “카프카 브로커”라고도 불리며 “브로커”에 맞게 중개자로서의 역할을 한다. 생산자(producer)는 Kafka에 이벤트를 게시(쓰기)하는 클라이언트 애플리케이션이고, 소비자(consumer)는 이러한 이벤트에 가입(읽고 처리, subscribe)하는 애플리케이션이다. Kafka에서는 생산자(producer)와 소비자(consumer)가 서로 완전히 분리되고 독립적이며, 이는 Kafka가 알려진 높은 확장성을 달성하기 위한 핵심 설계 요소이다. 예를 들어, 생산자들은 소비자를 기다릴 필요가 없으며 Kafka는 이벤트를 한 번 정확하게 처리할 수 있는 능력과 같은 다양한 보증을 제공한다. 4-1. 작동 원리 : 토픽(topic)이러한 카프카 브로커는 이벤트 데이터 생성을 하는 생산자(producer)와 데이터를 수신하는 소비자(consumer)의 사이에 토픽(topic)이라는 것을 통해 발행과 구독의 관계를 만든다. 생산자(producer)는 메세지(데이터)를 발행하며 발행시 어떤 토픽(topic)에 발행을 할지 결정한다. 이렇게 발행된 메세지는 토픽(topic) 내부의 파티션(partition)에 저장이 된다. 이렇게 내부의 파티션(partition)에 저장된 메세지는 해당 파티션(partition)에 append가 된다. 왜 여러개의 파티션으로 나눠서 메세지를 저장할까? 만약 파티션의 개념이 없이 분리되지 않은 하나의 공간에만 저장인 된다고 가정해보면 알 수 있다. Kafka는 순차적으로 들어온 순서에 따라 append를 한다. 이때, 많은 양의 메세지가 들어온다면 순차적인 데이터 저장 속도에 많은 불이익이 생긴다. 파티션으로 분리가 되어 있다면 데이터 처리가 병렬로 처리될 수 있는 이점을 얻을 수 있다. 무조건 파티션 수량을 늘린다면 이득일까? 무분별한 파티션 분할은 파티션별로 데이터에 대한 핸들러가 낭비가 될 수 있다. 또한 카프카는 파티션별로 Leader를 선출한다. 이때, 만약 Leader 파티션을 갖은 하나의 카프카가 강제로 종료가 된다면 파티션에 대한 Leader를 재선출을 해야하는데 파티션의 수가 많을수록 많은 Leader를 선출해야 한다는 단점이 있으며 이로인해 장애 복구에 대한 시간이 오래걸릴 수 있다. 4-2. 작동 원리 : 파티션 규칙카프카의 토픽(topic)은 하낭 이상의 파티션을 갖는다. 이때, 생산자(producer)가 토픽(topic)에게 발행한 메세지는 어떠한 파티션에 저장이 되는지에 대한 결정이 필요하다. 이때 아래와 같이 결정이 된다. key가 있는경우 key를 hash하여 특정 파티션으로 보내며 해당 키는 특정 파티션과 맵핑이 되어 있다. 이러한 맵핑은 파티션 개수가 변경되지 않는다면 유지된다. key가 없는 경우 전통적인 Round Robin 알고리즘을 통해 균등하게 파티션을 선택한다. 4-3. 작동 원리 : 컨슈머 그룹카프카의 메세지를 구독하는 소비자(consumer)는 컨슈머 그룹(consumer group)에 속하여 데이터를 받으며 컨슈머 그룹(consumer group)은 하나의 토픽(topic)에 대해 책임을 갖는다. 그림에서 보면 ‘테스트 토픽’에는 파티션이 3개가 존재한다. 이를 ‘컨슈머 그룹0’이 구독을 하고 있으며 내부에 컨슈머0~2 까지 3개의 컨슈머(consumer)가 존재한다. 현재 파티션 수와 컨슈머 수가 동일하므로 파티션과 컨슈머는 1:1 맵핑이 되어 있다. 여기서 빨강색으로 되어있는 데이터는 현재 컨슈머들이 받는 데이터를 뜻한다. 여기서 ‘컨슈머 그룹0’은 각 파티션별로 현재 어디까지 데이터를 소비했는지에 대한 Offset 정보를 알고 있어 다음에 소비할 데이터를 순차적으로 갖고 갈 수 있다. 파티션 수와 컨슈머(consumer) 수가 다르면 어떻게 될까? 첫 번째로 파티션 수와 컨슈머 수의 관계가 아래와 같다고 가정한다. 파티션 수 : 컨슈머 수 = 3 : 2 파티션 수가 더 많을 경우, 특정 몇몇의 컨슈머(consumer)는 하나 이상의 파티션에 대한 책임진다. 현재 예시에서는 컨슈머0~1 까지 2개의 컨슈머가 3개의 파티션을 담당하고 있으므로 콘슈머1이 채택되어 2개의 파티션을 감당한다. 파티션 수 : 컨슈머 수 = 3 : 4 컨슈머(consumer) 수가 더 많을 경우, 특정 몇몇의 컨슈머(consumer)는 아무것도 하지 않게 된다. 현재 예시에서는 컨슈머0~3 까지 4개의 컨슈머가 3개의 파티션을 담당하고 있으므로 각각 파티션과 1:1 맵핑이 되고 컨슈머3은 남게 된다. 컨슈머(consumer) 중에 하나가 장애가 발생한다면 어떻게 될까? 컨슈머 그룹0에 속한 컨슈머2가 아래와 같이 장애가 발생했다고 가정한다. 콘슈머2는 현재 카프카 브로커(Kafka)의 파티션3으로부터 정상적인 메세지를 처리할 수 없는 상황이다. 이때, 카프카는 장애를 극복하기 위해 일련의 과정이 필요하며 이를 리밸런싱(rebalancing)이라고 한다. 결국 이러한 리밸런싱(rebalancing)을 통해 정상적인 콘슈머들이 파티션1~3에 대해 처리를 할 수 있도록 설정이 된다. 참고123- https://kafka.apache.org/documentation- https://12bme.tistory.com/528- https://medium.com/@umanking/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-%ED%95%98%EA%B8%B0%EC%A0%84%EC%97%90-%EB%A8%BC%EC%A0%80-data%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EB%B3%B4%EC%9E%90-d2e3ca2f3c2","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/tags/kafka/"}]},{"title":"InfluxDB-01 [살펴보기]","slug":"influxDB-01","date":"2021-10-09T05:56:55.000Z","updated":"2021-11-13T10:48:21.521Z","comments":true,"path":"2021/10/09/influxDB-01/","link":"","permalink":"http://yoursite.com/2021/10/09/influxDB-01/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 InfluxDB는 시시각각 수집되는 데이터를 시간 순서로 저장을 하고 조회할 수 있는 시계열 데이터 베이스 입니다. 이는 Go 언어로 작성이 되었고, 2013년 9월에 출시가 되었습니다. 또한 SQL 계열 언어를 제공하기에 기존에 Oracle, Mysql을 사용하는 사용자들에게 더욱 친숙하게 기능을 사용할 수 있습니다. 1. 컨셉1.1 데이터 구성 요소InfluxDB는 개인적으로 사용해보면서 RDB와 유사한 느낌을 많이 받습니다. 그러나 쓰이는 용어 및 개념에서 차이가 존재하기 때문에 데이터의 구성요소에 대해 살펴보겠습니다. Database다수의 Measurement 를 포함하고 있는 개념이며, RDB의 Database와 동일한 개념으로 이해할 수 있습니다. MeasurementMeasurement는 Tag 및 Field, Timestamp 관련된 정보들을 포함하고 있는 구조입니다. RDB에서 테이블로 이해를 할 수 있습니다. ex) Measurement 예시 Tag Key Field Key Time Tag Value A Field Value A 1610176701000000000 Tag Value B Field Value A 1610176702000000000 Tag Value A Field Value B 1610176703000000000 TimestampInfluxDB에 저장되는 모든 데이터들은 timestamp를 저장하고 있는 time이라는 칼럼을 갖고 있으며 나노(10의 -9승) 초까지의 정밀도로 저장이 됩니다. 기본적은 Tag Key 입니다. Field Field KeyField Key는 문자열이며 Field에 대한 이름을 표현합니다. RDB에서 인덱스가 걸려 있지 않은 칼럼으로 이해할 수 있습니다. Field ValueField에 해당하는 값을 의미하며 String, Float, Integer, 또는 Boolean 형으로 데이터를 저장할 수 있습니다. Field SetField Key, Field Value 쌍과 Timestamp 정보를 포함한 Set을 의미합니다. Tag Tag KeyTag Key는 문자열이며 Tag에 대한 이름을 표현합니다. RDB에서 인덱스가 걸려 있거나 PK를 의미하는 칼럼으로 이해할 수 있습니다. Tag ValueTag에 해당하는 값을 의미하며 String 형으로 데이터를 저장할 수 있습니다. Tag SetTag Key, Tag Value 쌍으로 이루어진 Set을 의미합니다. PointPoint는 Series Key와 Field Value 및 Timestamp를 포함하고 있습니다. Series Series KeySeries Key는 Point에서 공유되는 Measurement와 Tag Set, Field Key를 포함하고 있습니다. Bucket모든 InfluxDB 데이터는 Bucket에 저장이 됩니다. Bucket은 Database와 각 Point들의 보관 시간에 대한 설정 정보인 Retention Policy(보관 정책) 개념이 합쳐진 개념입니다. OrganizationOrganization은 InfluxDB를 사용하는 사용자 그룹을 위한 작업공간입니다. 모든 Bucket과 사용자는 Organization에 속하게 됩니다. 1.2 설계 원칙InfluxDB의 데이터 요소들은 효율적으로 압축된 데이터로 저장하기 위해 TSM(time-structured merge tree), TSI(time series index) 파일로 저장됩니다. 데이터의 시간 정렬time을 기준으로 오름차순으로 정렬됩니다. 엄격한 업데이트 및 삭제 권한InfluxDB는 쿼리 및 쓰기 성능일 높이기 위해 업데이트 및 삭제 권한을 엄격하게 제한합니다. 우선적인 읽기, 쓰기 쿼리 처리InfluxDB는 데이터에 일관성보다 읽기 및 쓰기에 대한 우선순위를 더 높게 생각합니다. 즉, InfluxDB에 많은 쓰기가 발생하는 중에 읽기 쿼리를 할 경우 최신 데이터가 포함되지 않을 수 있습니다. 중복 데이터데이터에 대한 충돌을 단순히 해결하고 쓰기 성능을 높이기 위해 InfluxDB는 중복된 Tag Key들을 갖고 있는 정보에 대해서는 가장 최근의 Field Value로 업데이트 합니다. 기타현재 사용해본 경험으로는 데이터를 삭제할 경우 조건으로 Field Key는 조건으로 줄 수 없으며 Tag Key만 가능하다는 것을 확인하였습니다. 2. 엔진InfluxDB는 HTTP POST 프로토콜과 같은 쓰기 API를 요청이 수신 된 시점부터 데이터를 서버의 물리적인 디스크에 기록합니다. 이때, 내구성을 위해 일괄적인 Point들이 압축되고 WAL 에 저장됩니다. 또한 Point는 즉각적으로 쿼리할 수 있도록 캐시화 됩니다. 이렇게 캐시 정보는 주기적으로 TSM 파일로 기록됩니다. WAL(Write Ahead Log)WAL 은 InfluxDB 스토리지 엔진이 다시 시작될 때 데이터를 유지할 수 있게 해줍니다. 이러한 WAL은 예기치 않은 오류 발생시 데이터의 내구성을 보장해줍니다. 스토리지 엔진이 쓰기 요청을 받았을 경우 아래와 같은 순서로 작동됩니다. 쓰기 요청은 WAL 파일 마지막에 추가됩니다. 데이터가 디스크에 저장됩니다. 캐시 메모리를 업데이트 합니다. 정상적으로 디스크에 데이터가 저장이 되었다면 성공을 결과로 반환합니다. CacheCache는 현재 WAL 저장된 데이터 Point들에 대한 복사본입니다. 이러한 Cache는 아래와 같은 특징을 같습니다. Point들의 Measurement, Tag set, Unique field로 구성되어 있습니다. 압축이 되지 않은 데이터 입니다. 스토리지 엔진이 다시 시작될 때, WAL에서 업데이트 정보를 갖고 갑니다. 이러한 캐시는 런타임시 조회되고 TSM 파일에 저장된 데이터와 병합됩니다. Time-Structured Merge Tree (TSM)데이터를 효율적으로 압축하고 저장하기 위해 스토리지 엔진은 Series Key별로 필드 값을 그룹화 한 다음 해당 필드 값을 시간별로 정렬합니다. Time Series Index (TSI)데이터 카디널리티 (시리즈 수)가 증가함에 따라 쿼리는 더 많은 Series Key를 읽고 느려집니다. TSI는 데이터 카디널리티가 증가해도 쿼리가 빠르게 유지되도록합니다 References https://docs.influxdata.com/influxdb/v2.0/reference/key-concepts https://docs.influxdata.com/influxdb/v2.0/reference/internals","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"6. Cloud","slug":"it-tech/6-cloud","permalink":"http://yoursite.com/categories/it-tech/6-cloud/"}],"tags":[{"name":"InfluxDB","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"}]},{"title":"AWS 1편 [아마존 웹 서비스]","slug":"aws01_overview","date":"2020-08-09T03:56:55.000Z","updated":"2021-11-13T10:48:21.512Z","comments":true,"path":"2020/08/09/aws01_overview/","link":"","permalink":"http://yoursite.com/2020/08/09/aws01_overview/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 목차1.클라우드 컴퓨팅이란?2.IaaS, PaaS, SaaS3.AWS(아마존 웹 서비스)란?4.AWS의 인프라 1. 클라우드 컴퓨팅이란? 클라우드(cloud)는 구름이라는 뜻으로 정보 시스템 구성도를 그릴 때, 복잡한 네트워크를 구름 모양으로 표시하는 것에서 비롯되었습니다.즉, 컴퓨터 통신망이 복잡한 네트워크 및 서버 구성 등을 알 필요 없이 구름과 같이 내부가 보이지 않고, 사용자는 복잡한 내부를 굳이 알 필요도 없이 어디에서나 구름 속의 컴퓨터 자원에 접근하여 작업을 할 수 있다는 것입니다. 만약 직접 모든 것을 구입하여 운영 및 유지보수를 한다면 많은 전문지식과 리소스를 투자해야 합니다. 또한 장애에 대한 대비 또한 대비 또한 되어 있어야 하며 이런 부분은 중소기업에서 유지하기에는 어려운 부분이 많습니다. 2. IaaS, PaaS, SaaS 클라우드 컴퓨팅으로 제공받는 서비스는 크게 세가지 형태로 분류를 할 수 있습니다. 해당 분류는 클라우드 컴퓨팅을 사용하는 사용자의 책임 영역과 제공받는 영역의 범위에 따라 분류를 됩니다. IaaS(Infrastructure as a service) Infrastructure 에 해당하는 부분을 클라우드 컴퓨팅 서비스를 사용하는 사용자에게 제공하는 것을 의미합니다. 그림에서 보듯이 네트워크 부터 서버 가상화 까지의 영역에 대해 사용자는 제공을 받습니다. OS 부터는 사용자 관리 영역이며 일반적으로 적은 OS를 제공을 받습니다. 그러나 이렇게 OS 가 라이센스 등으로 비용이 발생하거나 유료 DBMS 등으로 인한 비용은 사용자가 부담을 해야할 수 있습니다. AWS의 IaaS 서비스의 대표적인 예로 ec2가 있으며 서비스 사의 VM을 통해 서비스를 받을 경우 프로시저닝 , 모니터링과 같은 기능을 손쉽게 재공받을 수 있습니다. PaaS(Platform as a service) PaaS는 네트워크 인프라부터 런타임까지 제공을 받을 수 있습니다. 때문에 개발자가 어플리케이션을 개발 및 서비스를 하기위한 기능들이 제공 되는 서비스입니다. 개발자는 low level에 있는 인프라 스트럭처 영역과 os 등과 같음 부분에 대한 관리 부담을 줄일 수 있습니다. SaaS(Software as a service) SaaS는 어플리케이션 및 어플리케이션이 동작하기 위한 모든 부분을 제공하는 것을 의미합니다. 즉, 인터넷으로 사용자가 별 다른 설치 없이 pc로 이용하는 서비스들이 이에 해당합니다. 대표적으로 구글 클라우드 등이 있습니다. 3. AWS(아마존 웹 서비스)란?AWS는 아마존 닷컴에서 개발하고 제공하는 클라우드 컴퓨팅 플랫폼입니다. 이는 네트워킹을 기반으로 가상 컴퓨터와 스토리지, 네트워크 인프라 등 다양한 서비스를 제공하고 있으며 장애 대비 및 확장 그리고 모니터링 등과 같은 정교한 작업들에 대해서도 손쉽게 사용자가 이용할 수 있도록 기능들을 제공합니다. 4. AWS의 인프라? 리전(Region) AWS의 인프라에를 이해하기 위해선 첫번째로 리전이라는 이라는 개념을 이해해야 합니다. AWS는 전 세계에 데이터 센터를 갖고 있습니다. 이러한 데이터 센터의 클러스터링하는 물리적 위치를 리전이라고 합니다. 리전은 지리적으로 격리가 되어 있고 여러 개의 가용 영역으로 구성이 됩니다. 리전 내에 저장된 해당 리전 내에서만 데이터가 복제가 됩니다. 비지니스적인 이유로 인해 다른 리전으로 데이터를 복제해야 하는 경우 사용자의 책임입니다. 이러한 리전은 전세계적으로 현재 24개가 존재합니다. 가용 영역(Availability Zone) AWS의 가용 영역은 하나 이상의 데이터 센터로 구성이 됩니다. 각 가용 영역은 일반적으로 대도시 리전 내에서 물리적으로 격리가 되어 있으며, 홍수 위험성이 낮은 지대에 위치합니다. 또한 무정전 전원 공급 장치와 현장 백업 발전 시설 등 단일 장애 지점에 대한 대비가 되어 있습니다. 한국에는 총 4개의 가용 영역이 존재합니다. 데이터 센터 보통 단일 데이터 센터에서 수만 개의 서버를 운영합니다. 이러한 데이터 센터는 전 세계 여러 리전에 클러스터 형태로 구축됩니다. 모든 데이터 센터는 온라인 방식이며 고객에게 서비스를 제공합니다. 또한 하나의 데이터 센터는 하나의 가용 영역에 포함됩니다. 출처 https://waspro.tistory.com/488 https://aws.amazon.com/ko/about-aws/global-infrastructure/regions_az/ https://aws.amazon.com/ko/about-aws/global-infrastructure/#reglink-pr","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"6. Cloud","slug":"it-tech/6-cloud","permalink":"http://yoursite.com/categories/it-tech/6-cloud/"}],"tags":[{"name":"AWS","slug":"aws","permalink":"http://yoursite.com/tags/aws/"}]},{"title":"React-3-2부 [서버 연동]","slug":"react-hooks-chapter03-2","date":"2020-04-05T06:24:55.000Z","updated":"2021-11-13T10:48:21.532Z","comments":true,"path":"2020/04/05/react-hooks-chapter03-2/","link":"","permalink":"http://yoursite.com/2020/04/05/react-hooks-chapter03-2/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 들어가기 앞서 본글은 React의 hooks문법으로 작성이 되었습니다. 또한 기본적인 리액트 환경셋팅 및 상태관리에 대한 내용은 다루지 않습니다. 해당 내용은 아래의 링크를 참고해주세요. React 1부 : 개발환경 구축하기React 2부 : 상태관리React 3-1부 : JWT와 React Router실습할 구조 위의 사진은 react로 작성한 프론트에서 node로 작성한 백엔드로 로그인을 요청하여 데이터베이스인 mysql에서 해당 회원의 정보를 검사하여 토큰(jwt)을 반환하는 예제입니다. react 개발 view 모듈 준비 모든 것을 새롭게 만들기에는 시간이 많이 소요되기 때문에 “React 2부 : 상태관리”에 사용된 프로젝트를 그대로 복사하여 사용하도록 하겠습니다. 또한 추가적으로 “MATERIAL-UI”라는 react 모듈을 이용하도록 하겠습니다. 추가적으로 아래의 모듈을 설치해주세요. 1npm install @material-ui/core @material-ui/icons MATERIAL-UI는 UI를 구현하는데 있어서 이미 라인업된 UI 컴포넌트를 통해 손쉽게 프론트르를 개발할 수 있도록 도와주는 모듈입니다. 12@material-ui/core : &quot;MATERIAL-UI&quot;에서 제공하는 react 컴포넌트를 사용할 수 있도록 해줍니다.@material-ui/icons : &quot;MATERIAL-UI&quot;에서 제공 icon을 사용할 수 있도록 해줍니다. 다수의 페이지를 라우팅 하고 서버에 http 요청을 하기 위해 아래의 모듈도 설치합니다. 1npm install axios react-router-dom 12axios : 서버 사이드에 http 요청을 하기 위한 모듈react-router-dom : 리액트 라우터를 사용하기 위한 모듈 view 템플릿 준비 아래의 링크를 통하면 “MATERIAL-UI”에서 제공하는 샘플 페이지를 볼 수가 있습니다. MATERIAL-UI 템플릿 링크 해당 실습에서 이용할 페이지는 “Sign In”과 “Album”입니다. 각 샘플의 “SOURCE CODE”를 클릭합니다. 해당 링크는 깃허브로 연결이 됩니다. 링크로 이동되면 README.md 파일을 제외하고 컴포넌트 js 파일이 있습니다. 해당 내용을 복사를 합니다. 프로젝트 구조 실습할 React는 전역상태 관리로 mobx를 사용합니다. 프로젝트 구조는 아래와 같습니다. 123456789101112131415161718chapter03_react_view /index.html /index.jsx /package.json /package-lock.json /webpack.config.js /src └─ components └─ Album.jsx : MATERIAL-UI 템플릿의 Album 을 수정 └─ AuthRoute.jsx : 권한을 확인하는 컴포넌트 └─ Container.jsx : 전체 컴포넌트를 갖고 있는 컨테이너 └─ SignIn.jsx : MATERIAL-UI 템플릿의 Sign In 을 수정 └─ store └─ LoginStore.js : 로그인과 관련된 전역상태 └─ app.css └─ Root.jsx /dist └─ app.js Container.jsx 코드 123456789101112131415161718192021222324import React from &apos;react&apos;;import Album from &quot;./Album&quot;;import SignIn from &quot;./SignIn&quot;;import &#123;useObserver&#125; from &quot;mobx-react/dist/mobx-react&quot;;import &#123; BrowserRouter as Router, Route, Switch&#125; from &apos;react-router-dom&apos;;import AuthRoute from &apos;./AuthRoute&apos;;export default function Container() &#123; return( useObserver(() =&gt; ( &lt;&gt; &lt;Router&gt; &lt;Switch&gt; &lt;AuthRoute path=&quot;/&quot; exact=&#123;true&#125;/&gt; &lt;Route path=&quot;/login&quot; exact=&#123;true&#125; component=&#123;SignIn&#125; /&gt; &lt;AuthRoute path=&quot;/album&quot; exact=&#123;true&#125; component=&#123;Album&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; &lt;/&gt; )) );&#125; “react-router-dom” 모듈의 BrowserRouter 컴포넌트를 이용하여 브라우저 경로에 따라 다른 컴포넌트가 렌더링이 되도록 설정을 했습니다. 라우터를 사용하기 위해 Router 컴포넌트 안에 Switch 컴포넌트를 넣습니다. 필수는 아니지만 Switch 컴포넌트는 하위의 Route 컴퍼넌트 중 1개만 렌더링이 되도록 해줍니다. AuthRoute 컴포넌트는 권한을 검사하는 컴포넌트 입니다. 내부에는 Route 컴퍼넌트와 Redirect 컴포넌트가 존재합니다. AuthRoute.jsx 코드 123456789101112131415import React from &apos;react&apos;;import &#123;Route, Redirect&#125; from &apos;react-router-dom&apos;;import &#123;useObserver&#125; from &quot;mobx-react/dist/mobx-react&quot;import LoginStore from &apos;../store/LoginStore&apos;;export default function AuthRoute(&#123;component : Component , ...rest&#125;) &#123; return( useObserver(() =&gt; ( &lt;Route &#123;...rest&#125; exact=&#123;true&#125; render=&#123;(props) =&gt; &#123; return LoginStore.loggedIn ? &lt;Component /&gt; : &lt;Redirect to=&#123;&apos;/login&apos;&#125; /&gt; &#125;&#125;/&gt; )) );&#125; AuthRoute 컴포넌트는 component로 렌더링할 컴포넌트를 받으며 나머지인 …rest를 받습니다. prop으로 들어온 component를 Component 변수에 할당하며 전역상태인 LoginStore 에서 로그인 여부를 확인하여 true(로그인을 한 경우)일 경우 Component 컴포넌트를 렌더링합니다. 전역상태에서 로그인 여부에 false일 경우 Redirect 컴포넌트를 이용하여 “/login” 로 라우팅을 합니다. SignIn.jsx 코드 중요 부분만 코드에 포함하도록 하겠습니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;useRef&#125; from &apos;react&apos;;import Axios from &apos;axios&apos;import &#123;useObserver&#125; from &quot;mobx-react/dist/mobx-react&quot;import loginStore from &quot;../store/LoginStore&quot;;import &#123;Redirect&#125; from &apos;react-router-dom&apos;;... 생략export default function SignIn() &#123; const classes = useStyles(); const form = useRef(); const onClickSignIn = () =&gt; &#123; Axios.post(&apos;http://localhost:3000/auth/login&apos;, new FormData(form.current) , &#123; headers: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125; &#125;) .then(function (&#123;data&#125;) &#123; if (data.result == &apos;success&apos;)&#123; loginStore.setLoggedIn(true); loginStore.setToken(data.token); console.log(&apos;로그인 여부 : &apos; +loginStore.loggedIn); console.log(&apos;토큰 : &apos; + loginStore.token); &#125; &#125;) &#125;; return( useObserver(()=&gt; ( &lt;Container&gt; ... 생략 &lt;Button type=&quot;button&quot; fullWidth variant=&quot;contained&quot; color=&quot;primary&quot; className=&#123;classes.submit&#125; onClick=&#123;onClickSignIn&#125; &gt; Sign In &lt;/Button&gt; ... 생략 &#123;loginStore.loggedIn ? &lt;Redirect to=&#123;&apos;/album&apos;&#125;/&gt; : null&#125; &lt;/Container&gt; )) );&#125; MATERIAL-UI로 복사한 코드를 SignIn.jsx에 복사하여 넣습니다. 그리고 mobx를 렌더링 할 수 있도록 코드를 수정 후 로그인 버튼에 onClick 이벤트를 통해 이벤트를 등록합니다. 로그인 버튼에 등록한 onClickSignIn 메서드는 Axios 모듈을 통해 서버 사이드에 요청을 합니다. 요청시 아이디와 비밀번호는 post로 넘깁니다. 서버 사이드에서 응답이 정상적으로 오면 전역상태에서 토큰과 로그인 여부에 대해 업데이트를 수행합니다. 렌더링의 마지막에 Redirect 컴포넌트를 통해 전역상태로부터 로그인 여부를 검사하여 로그인이 되었을 경우에는 “/album” 경로로 이동시킵니다. Album.jsx 코드중요 부분만 코드에 포함하도록 하겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142import React from &apos;react&apos;;import Axios from &apos;axios&apos;import &#123;useObserver&#125; from &quot;mobx-react/dist/mobx-react&quot;;import loginStore from &quot;../store/LoginStore&quot;;... 생략export default function Album() &#123; const classes = useStyles(); const verifyToken = () =&gt; &#123; let token = loginStore.token; Axios.post(&apos;http://localhost:3000/auth/verify&apos;, null , &#123; headers: &#123; &apos;Content-Type&apos;: &apos;application/json&apos;, &apos;token&apos; : token &#125; &#125;) .then(function (&#123;data&#125;) &#123; if (data.result == &apos;success&apos;)&#123; alert(&apos;유효한 토큰입니다.&apos;) &#125; &#125;); &#125; return( useObserver(()=&gt; ( &lt;&gt; &lt;CssBaseline /&gt; ... 생략 &lt;Grid container spacing=&#123;2&#125; justify=&quot;center&quot;&gt; &lt;Grid item&gt; &lt;Button variant=&quot;contained&quot; color=&quot;primary&quot; onClick=&#123;verifyToken&#125;&gt; Verify Token &lt;/Button&gt; &lt;/Grid&gt; &lt;/Grid&gt; ... 생략 &lt;/&gt; )) );&#125; MATERIAL-UI로 복사한 코드를 Album.jsx에 복사하여 넣습니다. 해당 화면은 로그인을 하면 접근할 수 있는 컴포넌트입니다. 중간에 있는 버튼 2개중에 1개를 삭제 후 현재 토큰을 서버에 검증하기 위한 버튼 1개만 남겨두고 삭제합니다. 그리고 검증을 하는 verifyToken 메서드를 이벤트로 연결해줍니다. 연결된 “verifyToken” 메서드는 Axios 모듈로 서버 사이드에 검증 요청을 보냅니다. 해당 검증이 정상적일 경우 alert 메서드로 정상임을 나타냅니다. node 개발 서버 사이드 모듈 준비 서버 사이드를 node로 구현하기 위해 새로운 폴더를 생성 후 아래와 같은 모듈을 설치합니다. 1npm install express cors jsonwebtoken multer sync-mysql body-parser 각각의 모듈은 아래와 같은 기능들을 도와줍니다. 서버 사이드 모듈 준비 123456express: 서버 구축을 위한 모듈cors: CORS 정책으로 인해 요청이 거부가 되는 것을 허용하기 위한 모듈jsonwebtoken: JWT를 생성 및 검증을 위한 모듈multer: multipart/form-data 형식으로 데이터를 받기 위한 모듈sync-mysql: 동기적으로 mysql를 이용하기 위한 모듈body-parser: 클라이언트측에서 요청을 받을때, url-encoded 쿼리 및 json 형태의 바디를 파싱하는데 도움을 주는 모듈 프로젝트 구조 12345678910chapter03_node_server /database └─ UserDao.js : 회원과 관련되어 mysql에 접근하는 class /service └─ JwtService.js : JWT를 생성하고 검증하는 class └─ LoginService.js : 회원정보 인증 및 토큰생성, 토큰 검증을 하는 class /config.js : JWT에 들어가 시크릿 /package.json /package-lock.json /server.js : 웹 서버 설정 server.js 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&apos;express&apos;);const multer = require(&apos;multer&apos;);const bodyParser = require(&apos;body-parser&apos;);const cors = require(&apos;cors&apos;);const loginService = require(&apos;./service/LoginService&apos;);const port = process.env.PORT || 3000;const app = express();const upload = multer();app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.use(bodyParser.json());app.use(upload.array());app.use(cors());app.listen(port, () =&gt; &#123; console.log(`Server is running at $&#123;port&#125;`);&#125;);app.post(&apos;/auth/login&apos;, (req, res) =&gt; &#123; let loginInfo = req.body; let token = loginService.getToken( loginInfo.id, loginInfo.password ); res.status(200).json(&#123; result : token ? &apos;success&apos; : &apos;fail&apos;, message : token ? &apos;Login success&apos; : &apos;Login Fail&apos;, token : token &#125;);&#125;);app.post(&apos;/auth/verify&apos;, (req, res) =&gt; &#123; let token = req.headers.token; let result = loginService.verifyToken(token); if(result) res.status(200).json(&#123; result : result ? &apos;success&apos; : &apos;fail&apos;, message : result ? &apos;Valid&apos; : &apos;Not valid&apos;, &#125;);&#125;); express 모듈에 CORS 정책과 관련된 이슈 및 요청에 대한 파싱을 정상적으로 수행하기 위해 각 모듈들을 설정해 줍니다. 로그인을 하기 위한 “/auth/login”, “/auth/verify” 로 post 방식인 경로를 설정해줍니다. config.js 코드 123module.exports = &#123; &apos;secret&apos;: &apos;pntbizSecret&apos;&#125; JWT에서 사용할 스크릿을 지정합니다. LoginService.js 코드 12345678910111213141516171819202122const jwtService = require(&apos;./JwtService&apos;);const userDao = require(&apos;../database/UserDao&apos;);class LoginService &#123; verifyToken(token) &#123; return jwtService.verify(token); &#125; getToken(id, pw) &#123; let user = userDao.getUserInfo(id, pw); let token = null; if(user) token = jwtService.create(user); return token; &#125;&#125;module.exports = new LoginService(); LoginService는 계정정보를 조회하여 토큰을 반환(getToken 메서드)하거나 토큰을 받아 토큰을 검증(verifyToken 메서드)하는 역할을 합니다. JwtService.js 코드 1234567891011121314151617181920212223242526const jwt = require(&apos;jsonwebtoken&apos;);const userData = require(&apos;../database/UserDao&apos;);const config = require(&apos;../config&apos;);class JwtService &#123; create(user) &#123; let token = jwt.sign(&#123; id: user.id, &#125;, config.secret, &#123; expiresIn: &apos;365d&apos;, issuer: &apos;pntbiz&apos;, subject: &apos;userInfo&apos; &#125;); return token; &#125; verify(token) &#123; return jwt.verify(token, config.secret); &#125;&#125;module.exports = new JwtService(); JwtService는 토큰을 생성하고 토큰을 검증하는 역할을 합니다. 내부적으로 jsonwebtoken 모듈을 이용하여 회원의 아이디를 클레임으로 추가하여 토큰을 생성합니다. JWT에 대한 자세한 내용은 해당 글의 처음에 “React 3-1부 : JWT와 React Router” 를 참고해주세요. UserDao.js 코드 123456789101112131415161718192021222324252627var mysql = require(&apos;sync-mysql&apos;);class UserDao &#123; constructor() &#123; this.connection = new mysql(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;123456&apos;, port : 3306, database : &apos;pntbiz_react&apos; &#125;); &#125; getUserInfo(id,pw)&#123; let user = null; let result = this.connection.query(`SELECT * from USER WHERE id=&apos;$&#123;id&#125;&apos; AND pw=&apos;$&#123;pw&#125;&apos;`); if(result.length == 1) user = result[0]; return user; &#125;&#125;module.exports = new UserDao(); UserDao는 동기적 mysql인 “sync-mysql” 모듈을 이용하여 회원정보를 Select 하는 역할입니다. Mysql 설정 mysql 설정으로는 아래와 같은 db 쿼리를 통해 생성 및 계정 1개를 설정합니다. 1234567891011121314CREATE DATABASE pntbiz_react;USE pntbiz_react;CREATE TABLE USER ( num INT(11) NOT NULL AUTO_INCREMENT, id VARCHAR(10) DEFAULT NULL, pw VARCHAR(10) DEFAULT NULL, PRIMARY KEY (`num`))INSERT INTO USER(id, pw)VALUES( &apos;pntbiz&apos;, &apos;1234&apos;); 마무리 이로서 서버 사이드와 데이터 베이스는 mysql를 연동을 하여 백엔드를 구성하고 리액트로 http 요청을 통해 로그인 요청을 후 JWT를 받아보는 실습을 진행하였습니다. 해당 실습 내용은 아래 깃허브에서 소스를 받으실 수 있습니다. React 3부 : JWT와 React Router / 서버 연동출처 https://beomy.tistory.com/33 https://velopert.com/2448 https://www.npmjs.com/package/jsonwebtoken","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"3. React","slug":"it-tech/3-react","permalink":"http://yoursite.com/categories/it-tech/3-react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-3-1부 [JWT와 React Router]","slug":"react-hooks-chapter03-1","date":"2020-04-04T10:29:55.000Z","updated":"2021-11-13T10:48:21.531Z","comments":true,"path":"2020/04/04/react-hooks-chapter03-1/","link":"","permalink":"http://yoursite.com/2020/04/04/react-hooks-chapter03-1/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 들어가기 앞서 본글은 React의 hooks문법으로 작성이 되었습니다. 또한 기본적인 리액트 환경셋팅 및 상태관리에 대한 내용은 다루지 않습니다. 해당 내용은 아래의 링크를 참고해주세요. React 1부 : 개발환경 구축하기React 2부 : 상태관리 본 글에서는 react를 활용하여 로그인 인증을 위해 추가적으로 알아야 하는 JWT 및 React Router에 대해 알아보도록 하겠습니다. 로그인 및 인증 웹 / 앱 개발을 하면 로그인과 관련되서 필연적으로 만나게 되는 개념이 쿠키와 세션입니다. 12쿠키 : 브라우저, 사용자의 컴퓨터(FRONT-END) 에 저장되는 데이터를 의미. 클라이언트 사이드에 있기 때문에 속도가 빠름세션 : &apos;시간&apos; 을 의미. 이 시간은 사용자와 서버(BACK-END)의 통신이 지속되는 시간을 의미함. 서버에 접속한 사용자별로 고유한 ID를 가진 세션이 생성됨. 서버측에 저장되기 때문에 보안이 쿠키에 비해 뛰어남. 쿠키는 보안상의 문제로 적용하기가 쉽지 않고 세션의 경우 쿠키에 비해 보안이 안전하지만 서버쪽 부하가 증가하게 됩니다. 이 때문에 본 리액트 3부에서는 JWT를 활용하여 간단하게 로그인을 하는 실습을 진행할 것입니다. JWT 개요 JWT는 “JSON Web Token”의 약자이며 웹표준(RFC7519) 으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인(Self-Contained) 방식으로 정보를 전달할 수 있습니다. 자가 수용적이기 때문에 Token에 모든 정보를 지니고 있습니다. 그렇기 때문에 특별히 인증과 과련되서 토큰을 저장하거나 하는 부하를 줄일 수 있습니다. 구조 JWT (JSON Web Token)는 헤더(Header) ,내용(Payload) , 서명(Signature) 인 3가지 부분으로 나눠집니다. 헤더(Header) 헤더는 typ와 alg라는 두가지 정보를 갖고 있습니다. 데이터의 예시는 아래와 같습니다. 1234&#123; typ : &quot;JWT&quot; alg : &quot;HS256&quot;&#125; typ : 토큰의 형식을 정보로 갖고 있습니다. alg : 해싱 알고리즘 정보를 갖고 있습니다. 대게 HMAC SHA256 혹은 RSA가 사용됩니다. 해당 알고리즘은 토큰을 검증할 때 사용되는 서명(Signature) 부분에 적용됩니다. 내용(Payload) 내용 부분은 토큰에 담을 정보가 들어가 있습니다. 정보는 name과 value의 한쌍으로 구분되며 이런 한 조각을 “클레임(claim)”이라고 일컫습니다. 클레임은 아래와 같이 3가지로 분류가 됩니다. 등록된 (registered) 클레임 공개 (public) 클레임 비공개 (private) 클레임 등록된 (registered) 클레임 등록된 클레임은 토큰에 대한 정보를 지정하기 위해 이미 정해진 클레임입니다. 해당 클레임은 필수가 아닌 선택이며 항목들은 아래와 같습니다. iss: 토큰 발급자 (issuer) sub: 토큰 제목 (subject) aud: 토큰 대상자 (audience) exp: 토큰의 만료시간 (expiraton), NumericDate 형식이며 현재 시간보다 이후로 설정되어 있어야 합니다. nbf: Not Before 를 의미, 토큰의 활성화 시간입니다.NumericDate 형식이며 지정한 날짜가 지나기 전까지는 토큰이 처리되지 않습니다. iat: 토큰이 발급된 시간 (issued at) jti: JWT의 고유 식별자 공개 (public) 클레임 공개 클레임은 서로 충돌이 일어나지 않도록 이름을 고유하게 갖고 있어야 합니다. 그래서 URL 형태로 작성을 합니다. 1&#123; &quot;http://pntbiz.co.kr&quot;: true &#125; 비공개 (private) 클레임 비공개 클레임은 대게 클라이언트와 서버에 약속된 클레임입니다. 이는 실제 사용을 하는 개발자가 지정하게 됩니다. 1&#123; &quot;comName&quot;: &quot;People and Technology&quot; &#125; 위의 3개의 클레임을 이용하여 내용(Payload)를 작성하였을 때 아래와 같은 예시가 나옵니다. 123456&#123; &quot;iss&quot;: &quot;pntbiz.co.kr&quot;, &quot;exp&quot;: &quot;1485270000000&quot;, &quot;http://pntbiz.co.kr&quot;: true, &quot;comName&quot;: &quot;People and Technology&quot;,&#125; 서명(Signature) JSON Web Token 의 마지막 부분으로 서명(signature)은 헤더(Header)의 인코딩값과, 내용(Payload)의 인코딩값을 합친후 주어진 비밀키로 해쉬를 하여 생성합니다. JWT 마무리 이러한 JWT를 통해 별도의 토큰과 관련된 저장소 및 부하를 만들지 않고 토큰으로 인증을 할 수 있습니다. 그러나 이것이 장점만을 갖고 있는 것은 아닙니다. 장단점의 요약은 아래와 같습니다. JWT 장점 URL 파라미터와 헤더로 사용 수평 스케일이 용이 REST 서비스로 제공 가능 내장된 만료 독립적인 JWT JWT 단점 내용(Payload)은 암호화되지 않기에 담는 데이터 내용이 제한적 클레임이 많을 수록 토큰의 길이가 길어짐 한 번 발급한 Token을 만료되기 전에 폐기가 어려움 React Router기본적인 react 환경과 관련된 모듈은 설치되어 있다는 가정하에 내용이 진행됩니다. React Router는 SPA 어플리케이션의 라우팅 문제를 해결하기 위해 react 진영에서 거의 표준처럼 사용되고 있는 네비게이션 라이브러리입니다. 이는 브라우저의 내장 API인 location과 history와도 연동이 됩니다. React Router 모듈 설치 React Router를 사용하기 위해 아래의 모듈을 설치합니다. 1npm i react-router-dom React Router 주요 컴포넌트 React Router를 활용하여 프로그램을 작성하기 전에 주요한 컴포넌트들에 대해 한번 살펴보도록 하겠습니다. Link 컴포넌트 Link 컴포넌트는 태그와 유사하게 브라우저를 href 속성을 통해 URL 변경하여 이동시키 듯이 컴포넌트는 to라는 prop을 통해 이동할 URL을 지정합니다. 코드상에서 사용 예시는 아래와 같습니다. 1&lt;Link to=&quot;/pntbiz&quot;&gt;피플앤드테크놀러지&lt;/Link&gt; Route 컴포넌트 Route 컴포넌트는 브라우저의 URL과 일치하는 컴퓨넌트를 브라우저에 렌더링 할 수 있도록 지정합니다. path라는 prop을 통해서 경로를 지정하며 component 라는 prop을 통해 렌더링 될 컴포넌트를 지정합니다. 코드상에서 사용 예시는 아래와 같습니다. 1&lt;Route path=&quot;/pntbiz&quot; component=&#123;Pnt&#125; /&gt; Redirect 컴포넌트 Redirect 컴포넌트는 브라우저의 경로를 변경시켜 주는 컴포넌트입니다. to라는 prop을 통해 변경할 경로를 지정할 수 있습니다. 코드상에서 사용 예시는 아래와 같습니다. 1&lt;Redirect to=&quot;/login&quot;/&gt; 마무리 이상으로 다음편에서 진행할 react로 로그인 구현하기와 관련되서 미리 알아야 할 내용에 대해 알아 보았습니다. 지금까지 실습한 내용을 토대로 간단하게 로그인을 구현해보는 시간을 갖도록 하겠습니다. 출처 https://www.npmjs.com/package/jsonwebtoken https://velopert.com/2448","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"3. React","slug":"it-tech/3-react","permalink":"http://yoursite.com/categories/it-tech/3-react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"엣지 컴퓨팅(Edge Computing)","slug":"edge_computing","date":"2020-03-25T09:00:55.000Z","updated":"2021-11-13T10:48:21.516Z","comments":true,"path":"2020/03/25/edge_computing/","link":"","permalink":"http://yoursite.com/2020/03/25/edge_computing/","excerpt":"","text":"작성자 : 플랫폼 개발실 서버개발팀 팀장 김대영 1. 엣지 컴퓨팅(Edge Computing)이란? 최근 급속히 확산되고 있는 IoT(Internet of Things) 기기로 인해 클라이언트-서버간 데이터 통신량이 폭증하면서 클라우드 컴퓨팅에서의 지연율 발생과 일시적 네트워크 중단 등 기술적 한계가 표출되기 시작했고, 이를 해결하기 위한 기술로서 엣지 컴퓨팅이 등장했다.엣지(Edge) 컴퓨팅(Computing)은 클라우드(Cloud) 컴퓨팅(Computing)과 대조적 개념의 컴퓨팅 방식으로, 클라우드나 중앙 서버에 집중되어 처리되던 데이터 처리가 아닌 네트워크 종단(Edge)에서 컴퓨팅이 이뤄지는 것을 의미한다. 엣지(Edge) 컴퓨팅은 중앙에서의 처리에 의존하지 않고 IoT 기기 자체 또는 물리적으로 근거리 위치한 엣지 서버를 주 매개로 하여 데이터 분석과 기기 동작이 이뤄지는 방식이다. 엣지(Edge) 컴퓨팅은 마치 신체의 자율신경계와 같은 기술이라고 할 수 있는데, 구름(Cloud)보다 더 가까이 안개처럼 다가오는 포그(Fog) 컴퓨팅 기술로 불리기도 한다.클라우드 컴퓨팅(Cloud Computing)이 데이터들이 저 먼 하늘의 구름까지 도달하여 중앙에서 처리 된다면, 포그 컴퓨팅(Fog Computing)은 하늘까지 가지 않아도 지표면 바로 위에 떠있는 안개처럼 가까운 곳 노드(엣지장비)에서 데이터가 처리되는 것을 의미한다.그렇다면 신기술인 엣지 컴퓨팅이 도입 하므로서 미치는 전반적인 영향력에 대해 알아보기로 하자. 엣지 컴퓨팅은 4차 산업혁명 시대에 요구되는 필수 요소 기술이다. 네트워크 불안정, 불필요한 데이터 문제, 프라이버시, 데이터의 지연 문제 등을 해결 하면서 새롭게 등장하는 수많은 스마트 기기와 자율 자동차, 스마트 시티, 스마트 그리드, 스마트 공장, 스마트 병원 등 새로운 응용 영역이 중요해지는 4차 산업혁명 시대에 엣지 컴퓨팅은 필수적이다. 엣지 컴퓨팅이 사회에 미치는 영향은 진화가 아닌 혁명이다. 컴퓨팅은 통합과 분산 사이의 세대교체가 반복되는 역사인데, 이런 엣지 컴퓨팅의 부상을 컴퓨팅 역사 측면에서 다시 주목받는 새로운 분산 컴퓨팅으로 보는 해석도 가능하다. 메인 프레임의 시대는 IBM이, 클라이언트 서버 시대는 HPE 등이 컴퓨팅 시장을 주도했고, 클라우드 중심으로 패러다임이 바뀌니 구글과 아마존 등 인터넷과 소프트웨어를 주특기로 하는 회사들이 컴퓨팅 흐름을 주도하는 주역으로 부상했는데, 실시간 데이터처리가 필요한 IT 환경이 확산되면서 클라우드가 갖는 효율성은 한계에 직면하고, 시장은 다시 통합이 아니라 분산 컴퓨팅을 요구하는 시대로 변모 하기 시작했다. 엣지 컴퓨팅은 수 많은 데이터로부터 인텔리전스(Intelligence)와 인사이트(Insight)를 효율적으로 엣지와 클라우드로 나누어서 분석/실행을 하고자 하는 접근이다. AI로 발전하는 새로운 지능 컴퓨팅 시대에 폭증하는 데이터 문제를 해결하면서도 성능이 뛰어난 AI 칩을 효과적으로 이용할 수 있는 가능성을 갖고, 전체 네트워크와 컴퓨팅 환경을 어떻게 분산할 것인가에 대한 대응 방안을 고민해야 한다. 2. 엣지 컴퓨팅(Edge Conputing)의 장단점2.1. 장점1) 대기시간(Latency)의 감소 엣지 컴퓨팅은 IoT 디바이스로부터의 데이터를 네트워크 엣지 단에서 효율화 할 수 있어 클라우드 컴퓨팅에 대한 의존도를 줄이고 실시간 컴퓨팅을 보장한다. 분산 구조의 엣지 컴퓨팅은 실시간 예측이 용이하고, 대기 및 지연 시간을 줄이기 위해 데이터 소스에 근접하여 컴퓨팅을 수행함으로써 Machine learning 및 AI 모델 구현도 가능하다. 2) 비용 절감 엣지 컴퓨팅은 데이터의 소스 가까이서 데이터를 분석/처리하여 엣지와 클라우드 간 데이터 전송을 줄임으로써 이상적인 솔루션으로 대두되었다. IoT에 투자하는 기업은 클라우드에서 실행될 서비스와 엣지에서 실행될 서비스를 구분하여 IoT 관련 비용 절감이 가능하다. 3) 스마트 애플리케이션의 증가 대량의 데이터가 생성/저장/분석/처리 되어야 하는데, 엣지 컴퓨팅은 시간에 민감한 IoT 애플리케이션의 요구 사항을 충족하기 위해 엣지에서 데이터를 처리하는 등 요구 사항을 충족시키기에 적합하다. 예를 들면, 제조 부문 엣지 단말의 스트리밍 데이터는 제품 결함을 예방하고 생산을 최적화하는 데 도움이 될 수 있으며, 스마트 신호등의 경우 스트리밍 데이터가 실시간 차량 선회 등에 도움이 된다. 4) 보안 및 개인정보 보호 엣지 컴퓨팅은 데이터 소스에 가까운 엣지(Edge) 단에서 데이터를 처리함으로써 데이터센터와 센서 간 데이터 교환을 줄여 보안 위험을 차단할 수 있다. 2.2 단점1) 데이테의 보전성 문제 엣지 컴퓨팅은 가공에의해 만들어진 필요한 데이터만 분석/처리하고 원천데이터와 불완전한 정보들은 버려진다. 즉 불필요한 정보의 손실이 발생 한다는 점을 고려해야 한다. 2) 데이터 해킹에 대한 문제 엣지 컴퓨팅에 사용에 필요한 사물인터넷(IoT), 네트워크 연결장치 및 내장 컴퓨터가 추가 됨에 따라 여러 장치를 통해 악의적인 공격 및 해커가 침투하여 중요한 데이터를 액세스 할 수 있는 방법이 증가한다. 3) 대량화에 대한 문제 규모가 큰 엣지 컴퓨팅은 더 많은 로컬 하드웨어가 필요 하다. 데이터 처리를 위한 다양한 장비와 컴퓨팅 프로세스를 처리 하기위한 하드웨어가 필요해지므로 그에 따른 비용 또한 증가한다. 3. 엣지 컴퓨팅(Edge Conputing)의 오픈소스 동향 엣지 컴퓨팅(Edge Computing)은 가트너에 의해 2018년, 2019년 10대 유망 기술로 선정되었고 이미 2016년에 10억 달러를 넘어선 엣지 컴퓨팅 관련 시장도 2021년에는 49.4억 달러로 초고속 성장을 보일 것으로 전망한다.엣지 컴퓨팅에서 오픈소스가 추구하는 혁신은 사물인터넷 기기 또는 단말에서 클라우드까지의 모든 데이터와 컴퓨팅의 경로에 소프트웨어 요소 기술들을 배치하고 그 역할을 잘 정의하여 다양한 혁신이 이루어지는 요소 기술들을 빠르게 수용하는 것이라 볼 수 있다.오픈소스 엣지 컴퓨팅 솔루션들은 그 응용의 완성도를 빠르게 달성하고 효율적으로 운영하기 위한 아키텍처의 정의와 구현, 아키텍쳐에 따른 시스템 구성 및 운영 관리의 효율화 기술에 집중하고 있다. 엣지 컴퓨팅 관련하여 의미 있는 규모의 오픈소스 프로젝트들을 살펴보려고 한다. 3.1. 리눅스 재단, EdgeX Foundry EdgeX Foundry 2017년에 시작된 리눅스 재단의 프로젝트로, 벤더 및 플랫폼 독립적인 느슨한 결합의 마이크로 서비스 프레임워크로 개별 기술이 가진 혁신들을 빠르게 수용하는 구조를 추구하는 오픈소스 프로젝트이다. EdgeX는 IoT 엣지를 중심으로 산업, 기업 환경, 소비자 응용에서 설계, 개발, 실제 적용 프로세스를 단순화하려는 목표를 가지고 있다. 이 프로젝트에는 바이두, 에릭슨, HP, 화웨이, 인텔, 주니퍼 네트웍스, 노키아, NTT, 텐센트, 윈드 리버 등이 설립 멤버이다. EdgeX는 이미 VMware, Cavium, 델 등의 솔루션에 포함되어 상용 수준으로 개발되어 있으며, 매년 두 번의 릴리즈를 목표로 하고 있다. 현재까지 ‘바르셀로나’, ‘캘리포니아’, ‘델파이’를 버전이 발표되었고 ‘후지’는 2019년 4월 중에 발표할 예정이다. EdgeX는 임베디드 PC, 허브, 게이트웨이, 라우터, 온프라미스 서버까지, 클라우드를 제외한 전 영역을 엣지 노드로 정의하고 있다. EdgeX 코어는 Go 언어로 작성되고 있으나, x86, ARM, 리눅스, 윈도우즈, MacOS를 비롯한 주요 하드웨어 소프트웨어 플랫폼과 모든 언어의 개발 환경을 지원한다. 3.2. 오픈엣지 컴퓨팅(OpenEdge Computing) 오픈엣지 컴퓨팅은 모든 엣지 노드가 개방적이고 표준화된 메커니즘을 통해 근접한 모든 사용자에게 컴퓨팅 및 스토리지를 제공하기 위한 오픈소스 프로젝트이다. 이 프로젝트에는 인텔, 마이크로소프트, 보다폰, T-모바일, 노키아, 카네기멜론 대학, 그리고 모바일 인프라 설비 업체인 크라운 캐슬(Crown Castle)로 구성된 Open Edge Computing Initiative에 의해 운영되고 있다. 이 프로젝트에선 이니셔티브 참여사들을 중심으로 Living Edge Lab을 운영하여 실제 테스트 환경을 제공한다. 3.3. 오픈엣지 (OpenEdge) 오픈엣지는 클라우드컴퓨팅, 데이터, 서비스를 엣지 기기까지 매끄럽게 연결하는 것을 목표로 하는 오픈소스 프레임워크이다. 중국의 바이두가 주도하고 있고, 다른 프레임워크들처럼 모듈화, 컨테이너화를 통해 자원 효율적으로 엣지 기기를 제어하고 보안성을 확보하고, BIE(Baidu IntelliEdge)라는 클라우드 관리 도구와 연동하여 엣지 기기에의 응용 프로그램의 배포 등을 쉽게 할 수 있도록 도와준다. 3.4. 이클립스 (Eclipse) 재단의 IoT 프로젝트 이클립스 큐라(Kura)는 IoT 게이트웨이를 구축하기 위한 플랫폼을 제공하는 사물인터넷 프로젝트이다.큐라는 IoT 게이트웨이들을 원격으로 관리할 수 있게 하는 스마트 응용 프로그램 컨테이너이며 사용자가 자신의 IoT 응용 프로그램을 작성하고 배포할 수 있도록 다양한 API를 제공한다. 큐라는 자바 가상머신 위에서 실행되며 OSGi를 기반으로 재사용 가능한 소프트웨어 빌딩 블록을 작성하는 프로세스를 단순화하고 있다. 큐라 API는 직렬포트, GPS, 워치 독, USB, GPIO, I2C 등 기본 하드웨어에 쉽게 접근 가능하게 하고, 네트워크 설정, IoT 서버와의 통신, 게이트웨이 관리를 단순화하기 위한 OSGi 번들을 제공한다.큐라는 엣지 컴퓨팅이란 용어가 나오기 전부터 IoT 환경을 위한 소프트웨어로 개발되어왔으며, 현재 버전 4.1.0까지 나와 있다.이클립스 ioFog 프로젝트는 리눅스가 실행되는 모든 하드웨어에 설치할 수 있는 런타임으로 포그(Fog) 컴퓨팅 계층에 필요한 기술 요소들로 구성된다. 포그는 IoT 기기와 게이트웨이의 일부를 포함하는 개념이다. ioFog는 엣지 기기 위에서 실행될 수 있는 마이크로 서비스 런타임으로 메시지 버스, 마이크로 서비스의 동적 구성 및 원격 디버깅을 비롯한 일련의 유용한 서비스를 제공한다. 3.5. 애저(Azure) IoT Edge 마이크로소프트의 애저(Azure) IoT Edge는 애저 서비스, 타사 서비스 또는 개발자 고유의 코드를 실행하는 컨테이너인 IoT Edge 모듈, 각 기기에 배포된 모듈을 관리하는 IoT Edge 런타임, 그리고 IoT 기기를 연결하여 데이터를 수집하고 비즈니스 인사이트와 자동화를 이루기 위한 클라우드 게이트웨이인 IoT 허브로 구성된다.마이크로소프트는 깃허브에 모든 IoT Edge 관련 프로젝트 소스)를 공개하고 있다 4. 엣지 컴퓨팅(Edge Conputing)이 필요한 이유 사물인터넷(IoT) 환경이 상용화되면서 점차 다양한 기기들이 인터넷에 연결되고 그로 인해 생성되는 데이터가 엄청난 속도로 증가하고 있다. 이렇게 다양한 경로를 통해 수집된 데이터들은 데이터 분석을 위해 중앙서버(클라우드)로 모이게 된다. 하지만, 중앙서버(클라우드)에서 처리할 수 있는 양은 한정되어 있고, 여기저기서 지속적으로 데이터가 몰리게 되면 정체 현상이 발생하기 때문에 빠르게 분석 결과를 받아 보기가 어렵다. 시장조사기관에 따르면, 전 세계 IoT 기기 수는 2016년 약 36억 대에서 2021년 250억대로 연평균 32%씩 늘어날 것이며, 이에 따라 발생하는 데이터 규모는 2015년 16.1제타바이트(ZB)에서 2025년 163ZB 규모로 10배 이상 폭증할 것으로 예상되고 있다. (1ZB는 약 1조1000억 기가바이트(GB))이런 방대한 데이터를 클라우드 컴퓨팅 환경에서만 처리하는 것은 역부족이다. 클라우드 컴퓨팅은 각종 기기에서 수집한 데이터를 멀리 있는 중앙서버에서 처리한 후에 이를 다시 기기로 송신하는 과정을 거쳐서 데이터를 처리하는 방식이라서 기가 중앙서버의 거리에 따라 지연 시간이 발생할 수밖에 없기 때문에 데이터 전송 중간에 오류가 발생할 가능성도 그만큼 높다. 이런 문제 때문에 엣지 컴퓨팅이 필요하며, 그 중요성도 높아지고 있다. 엣지 컴퓨팅은 데이터를 중앙 서버까지 보내지 않고 IoT 기기에 탑재된 인공지능(AI) 칩이나 가까운 미니 서버를 통해 처리한다. 데이터가 수집 되는 엣지에서 바로 처리하고, 연산 결과를 현장에서 바로 적용할 수 있다. 그러면 데이터 부하량이 줄어들고 처리 시간도 단축할 수 있을 뿐 아니라, 클라우드 컴퓨팅 환경 보다 훨씬 더 빠르게 대응할 수 있다. 즉, 단말에서 발생하는 데이터양이 적고 전송 지연이 치명적이지 않은 환경에서는 클라우드 컴퓨팅이 적합하지만, 실시간 처리의 중요도가 높은 환경에서는 엣지 컴퓨팅이 반드시 필요로 한다. 늘어나는 데이터의 양만큼 중앙서버(클라우드)를 증설 할 수 없기 때문에 IoT 환경에서 엣지 컴퓨팅은 필수적인 기술이 될 수 밖에 없다. 이처럼, 엣지 컴퓨팅은 데이터가 수집 되는 끝단에서 데이터를 즉시 분석하고 현장에서 곧바로 적용할 수 있기 때문에 클라우드를 통해 데이터 분석 결과를 가져오는 것보다 즉시성과 안정성이 높으며, 데이터 처리 시간 단축과 운영 비용 절감 등의 장점을 갖고 있다. 또한, 수집한 데이터에 대한 익명화와 암호화가 가능하기 때문에 개인정보 및 보안 문제도 해결 할 수 있다. 이런 이유로 엣지 컴퓨팅이 IoT 시장에서 각광 받고 있는 것이다. References https://www.eclipse.org/kura/ https://docs.microsoft.com/ko-kr/azure/iot-edge/about-iot-edge https://blog.softcamp.co.kr/285 엣지 컴퓨팅에서의 오픈소스 동향(이민석 국민대학교 교수) https://ettrends.etri.re.kr/ettrends/176/0905176006/34-2_51-59.pdf","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"1. IoT","slug":"it-tech/1-iot","permalink":"http://yoursite.com/categories/it-tech/1-iot/"}],"tags":[{"name":"Edge Computing","slug":"edge-computing","permalink":"http://yoursite.com/tags/edge-computing/"}]},{"title":"Flutter-3부 [Flutter 이해하기]","slug":"flutter03","date":"2020-03-17T05:56:55.000Z","updated":"2021-11-13T10:48:21.519Z","comments":true,"path":"2020/03/17/flutter03/","link":"","permalink":"http://yoursite.com/2020/03/17/flutter03/","excerpt":"","text":"작성자 : 솔루션 모바일팀 목차1.Stateful Widget Lifecycle2.위젯 종류3.BLoC Pattern4.References1.Stateful Widget Lifecycle StatefulWidget을 만들 때 State라는 오브젝트를 만듭니다. 이 오브젝트는 위젯이 동작하는 동안 mutable state를 뜻합니다. state 정의 ①위젯에 의해서 사용되어지는 데이터는 변할 수 있다. ②위젯이 빌드될 때 데이터들을 동기적으로 읽을 수 없다. 모든 state들은 build 함수가 호출될 때까지 설정되어야 한다. Lifecycle ① createState():Framework가 StatefulWidget을 만들경우 createState()가 즉시 호출된다. ② mounted is true:모든 위젯은 this.mounted : bool 속성을 가지고 있다. 즉 buildContext가 할당될 때 this.mounted가 true로 리턴된다. ③ initState():widget이 만들어지고 생성자 후에 처음 메소드 실행할때 이 함수가 실행된다. super.initState() 를 필수적으로 호출해야 한다. ④ didChangeDependencies():위젯이 최초 생성될때 initState 다음에 바로 호출 된다. 또한 위젯이 의존하는 데이터의 객체가 호출될때마다 호출된다. 예를 들면 업데이트되는 위젯을 상속한 경우 공식문서 또한 상속한 위젯이 업데이트 될때 네트워크 호출(또는 다른 비용이 큰 액션)(역자주: API호출)이 필요한 경우 유용하다고 함. ⑤ build():필수적으로 오버라이딩해서 구현해야되는 함수이다. 위젯을 리턴한다. ⑥ didUpdateWidget(Widget oldWidget):didUpdateWidget()는 부모 위젯이 변경되어 이 위젯을 재 구성해야 하는 경우(다은 데이터를 제공 해야하기 때문) 이것은 플러터가 오래동안 유지 되는 state를 다시 사용하기 때문이다. 이 경우 initState()에서 처럼 읿부 데이터를 다시 초기화 해야 한다. ⑦ setState():setState() 메서드는 플러터 프레임워크 자체적, 또는 개발자로 부터 자주 호출된다. ‘데이터가 변경되었음’을 프레임워크에 알리는데 사용되며 build context의 위젯을 다시 빌드하게 한다. setState()는 비동기적이 않은 callback을 사용한다.(역자주: callback으로 비동기를 사용할 수 없다는 말임). ⑧ deactivate():이 메서드는 거의 사용되지 않는다. deactivate()는 tree에서 State가 제거 될때 호출 된다. 그러나 현재 프레임 변경이 완료되기 전에 다시 삽입 될 수 있다. 이 메서드는 State객체가 tree의 한 지점에서 다른 지점으로 이동 할 수 있기 때문에 기본적으로 존재한다. ⑨ dispose():dispost()는 State객체가 영구히 제거 된다. ⑩ mounted is false:이 상태에서 state 객체는 결코 다시 mount되지 않으며, setState()가 호출되면 에러가 발생한다. 2.위젯 종류 widget은 widgets library의 standard widget과 Material library의 widget 입니다. widgets library는 어느 app이든 사용가능하지만 Material library는 Material app에서만 사용 가능합니다. 1)Standard widgets Container: padding, margins, borders, background color, 기타 style을 적용 가능 GridView: widget 을 스크롤 가능한 grid 모양으로 배치 ListView: widget 을 스크롤 가능한 list 로 배치 Stack: widget을 순차적으로 쌓아가면서 표시 2)Material widgets Card: 관련된 정보를 box 안에 표시 ListTile: 최대 3줄의 text를 표시하고, trailing icon 삽입 3)Container padding, margin, border 사용 가능 background color 또는 image 변경 가능 하나의 child widget을 갖는다. 다만, child widget으로 Row, Column 등 다수의 자식을 갖는 widget이 올 수 있다. 4)GridView grid 형태로 widget 배치 scrolling지원 직접 custom grid를 만들던지, 아래 제공되는 두가지 속성을 사용가능 GridView.count 지정된 개수 만큼의 column 을 제공 GridView.extent 타일의 최대 width를 지정 MediaQuery.of(context).orientation 를 사용하여 device의 landscape 나 portrait 을 인지하여 적절히 반응하도록 할 수 있다. 5)ListView Column형 widget으로 list를 만든다. 수평 또는 수직의 layout을 만들 수 있다. 자동으로 스크롤링을 만든다. Column widget 보다 확장성은 적다. 6)Stack Stack을 이용해 image 상단에 그라디언트를 넣습니다. 이 그라디언트를 통해 toolbar 의 icon이 iamge와 구분됩니다. 다른 widget 위에 widget을 배치 첫번째 widget이 base widget 이다. 그 위로 다른 widget 이 배치된다. Stack 은 scroll 되지 않는다. box를 넘는 자식 widget을 자를 수 있다. 7)Stack Material card 이다. 관련된 정보를 표현하는데 사용 자식을 하나만 갖지만, 멀티플 자식을 갖는 위젯을 자식으로 가질 수 있다. 둥근 테두리와 그림자를 보여준다. 스크롤이 되지 않는다. Material library 의 widget 이다. 3.BLoC Pattern BloC Pattern이란? BLoC(Bussiness Logic Component) Pattern 은 Flutter 의 상태 관리를 제어하기 위해서 Google 개발자에 의해서 디자인 되었습니다. Flutter 에서는 상태에 따라서 렌더링이 일어나기 때문에, 상태 관리가 매우 중요합니다. BLoC는 UI 와 Bussiness Logic 을 분리하여, 각각 코드의 의존성을 낮추게 해줍니다. Flutter 을 위해 설계 되었지만, 디자인 패턴이기 때문에, 어떠한 프레임워크 나 언어에서도 사용이 가능합니다. BLoC의 특징 ① UI 에서는 여러 BLoC 이 존재할 수 있다.② UI 에서는 화면에 집중하고, BLoC 에서는 Logic 에 집중한다.③ UI 에서는 BLoC 의 내부 구현에 대해서 몰라도 된다.④ BLoC 은 여러 UI 에서 구독 할 수 있다. 때문에 재사용이 용의하다.⑤ BLoC 만을 분리해서 테스트가 가능하다. BLoC의 형태 BLoC 에서 각 UI 객체 들은 BLoC 객체를 구독하고 있다.BLoC 객체의 상태가 변경되면, BLoC 의 상태를 구독중인 UI 객체 들은 그 즉시 해당 상태로 UI 를 변경한다.BLoC 객체는 UI 객체로 부터 이벤트를 전달받으면, BLoC 객체는 필요한 Provider 나 Repository 로 부터 데이터를 전달받아, Bussiness Logic 을 처리한다.Bussiness Logic 을 처리한후, BLoC 객체를 구독중인 UI 객체 들에게 상태를 전달한다. 123456789101112class BLoC &#123; provider: Provider = new Provider(); stream: Subject = new Subject(); async sink() &#123; const data = await Provider.getCounterModel(); const result = await this.BussinessLogic(data); this.stream.next(result); &#125; private async BussinessLogic() &#123; // ... &#125;&#125; UI 객체는 구독중이던 BLoC 객체의 상태가 변경되면 상태를 전달받는데, 이때 얻은 상태를 이용하여 화면을 재구성한다. 123456789101112131415class UI &#123; bloc = new BLoC(); constructor() &#123; this.bloc.stream.subscribe((data) =&gt; &#123; this.render(data); &#125;); &#125; render(data) &#123; return ( &lt;div onClick=&#123;this.bloc.sink&#125;&gt; &#123;data&#125; &lt;/div&gt; ) &#125;&#125; Flutter와 BLoC Flutter 에서는 Stream 을 이용해서 BLoC 을 구현한다.StreamController 으로 Observable 객체를 생성한다.StreamController 의 Sink 를 이용해서 값을 전달한다.StreamController 의 Steam 를 이용해서 상태를 구독한다.이때 RxDart 를 이용하여 StreamController 을 쉽게 만들 수 있다. 123456789101112class Bloc &#123; final _repository = Repository(); final _subject = PublishSubject&lt;String&gt;(); Observable&lt;String&gt; get stream =&gt; _subject.stream; action() async &#123; String result= await _repository.getData(); _subject.sink.add(result); &#125; dispose() &#123; _subject.close(); &#125;&#125; UI 에서는 StatefulWidget 을 쓰지 않고, 그리고 setState 를 쓰지 않고도 bloc 의 상태 변경에 따라 UI 를 변경할 수 있다. 1234567891011121314151617class UI extends StatelessWidget &#123; UI() &#123; bloc.action(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: StreamBuilder( stream: bloc.stream, builder: (context, AsyncSnapshot&lt;String&gt; snapshot) &#123; return Text(snapshot.data); &#125;, ), ); &#125;&#125; References https://brunch.co.kr/@myner/5 https://medium.com/flutter-korea/%EC%99%9C-flutter%EB%8A%94-dart%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-e838b9415f57 https://kimch3617.tistory.com/entry/Flutter%EB%9E%80-Flutter%EC%9D%98-%ED%8A%B9%EC%A7%95 https://medium.com/withj-kr/react-native-vs-flutter-%ED%81%AC%EB%A1%9C%EC%8A%A4%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EC%96%B4%EB%96%A4-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98-701ecbc19a24 https://skuld2000.tistory.com/69 https://medium.com/@pks2974/flutter-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-9532e16aff57 https://javaexpert.tistory.com/974 https://jaceshim.github.io/2019/01/28/flutter-study-stateful-widget-lifecycle/ https://insights.stackoverflow.com/survey/2019#methodology https://medium.com/@pks2974/bloc-%EC%9D%B4%ED%95%B4-%ED%95%98%EA%B8%B0-%EB%B0%8F-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC-%ED%95%98%EA%B8%B0-7dc705e4c640 http://murmurblog.com/layouts-in-flutter/","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"5. Flutter","slug":"it-tech/5-flutter","permalink":"http://yoursite.com/categories/it-tech/5-flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}]},{"title":"Flutter-2부 [개발환경구축]","slug":"flutter01","date":"2020-03-16T05:56:55.000Z","updated":"2021-11-13T10:48:21.517Z","comments":true,"path":"2020/03/16/flutter01/","link":"","permalink":"http://yoursite.com/2020/03/16/flutter01/","excerpt":"","text":"작성자 : 솔루션 모바일팀 Flutter 개발 환경 구축 Flutter는 Android Studio, IntelliJ, VS Code 등에서 Plugin을 제공합니다. 여기서는 Android Studio 를 기준으로 다음과 같이 개발 환경을 구축합니다. Android Studio 설치 / Flutter SDK 다운로드 Flutter Plugin 설치 프로젝트 생성 flutter doctor 확인 프로젝트 실행1. Android Studio 설치 / Flutter SDK 다운로드 아래 링크에서 안드로이드 스튜디오를 설치 해줍니다.https://developer.android.com/studio?hl=ko 아래 링크에서 Flutter SDK를 다운로드 받습니다. 안드로이드 스튜디오에 Flutter SDK 경로를 입력해 줘야 하기 때문에 적당한 경로에 이동 시킵시다.https://flutter-ko.dev/docs/get-started/install2. Flutter Plugin 설치 안드로이드 스튜디오 실행 화면의 Configure &gt; Plugins 에서 Flutter를 검색하여 설치 해줍니다. 설치 완료 시 Flutter 프로젝트를 생성 할 수 있는 메뉴가 추가 됩니다.3. 프로젝트 생성 New Flutter Project 메뉴를 통해 프로젝트명, Flutter SDK 경로, 프로젝트 저장 경로 등을 설정하여 프로젝트를 생성합니다.3. flutter doctor 확인 터미널에서 flutter doctor 명령어를 통해 Flutter 개발 준비 상태를 확인 하실 수 있습니다.12345678flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.12.13+hotfix.8, on Mac OS X 10.15.3 19D76, locale ko-KR)[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)[✓] Xcode - develop for iOS and macOS (Xcode 11.3.1)[✓] Android Studio (version 3.6)[✓] Connected device (1 available)• No issues found! 4. 프로젝트 실행 flutter doctor 까지 완료 했다면 이제 프로젝트를 실행 해볼 수 있습니다. 소스 코드 작성 기본적으로 생성해 주는 프로젝트는 FloatingActionButton 을 누르면 숫자를 카운트 하여 보여주는 앱 입니다. 그런데 늘어나기만 합니다.. 초기화 해주는 버튼을 한번 넣어 봅시다. 아래 main.dart의 소스 코드 중 body 부분의 소스코드를 보자면 Column이 있습니다. Column은 하위 위젯을 세로로 배치 할 수 있는 위젯입니다. 이 Column에 버튼을 추가하여 counter 변수를 초기화 해 주면 될 것 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &apos;package:flutter/material.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: &apos;Flutter Demo Home Page&apos;), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( &apos;You have pushed the button this many times:&apos;, ), Text( &apos;$_counter&apos;, style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: &apos;Increment&apos;, child: Icon(Icons.add), ), ); &#125;&#125; Column에 MaterialButton을 추가해주고 텍스트, 컬러 등을 적용해 주었습니다. 그리고 onPressed를 통해 버튼이 눌렸을 경우 counter 변수를 초기화하고 초기화 한 상태를 다시 적용해주기 위해 setState를 사용하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839@override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( &apos;You have pushed the button this many times:&apos;, ), Text( &apos;$_counter&apos;, style: Theme.of(context).textTheme.display1, ), MaterialButton( color: Colors.blue, child: Text( &apos;초기화&apos;, style: TextStyle( color: Colors.white )), onPressed: () &#123; setState(() &#123; _counter = 0; &#125;); &#125;, ) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: &apos;Increment&apos;, child: Icon(Icons.add), ), ); 이제 실행해 보면, 초기화 버튼이 생기고 카운트 초기화가 잘 작동하는지 확인 하실 수 있습니다.","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"5. Flutter","slug":"it-tech/5-flutter","permalink":"http://yoursite.com/categories/it-tech/5-flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}]},{"title":"Flutter-1부 [Flutter란 무엇인가?]","slug":"flutter02","date":"2020-03-15T05:56:55.000Z","updated":"2021-11-13T10:48:21.518Z","comments":true,"path":"2020/03/15/flutter02/","link":"","permalink":"http://yoursite.com/2020/03/15/flutter02/","excerpt":"","text":"작성자 : 솔루션 모바일팀 목차1.Flutter Flutter란? 장점 및 단점 Framework 구조 2.React Native와 비교3.Dart언어 Dart가 만들어진 이유 Dart의 특성 Dart의 실행방식 4.ReferencesFlutter1. Flutter란? iOS의 스토리보드나 Android의 xml에서 UI를 만들고, 불러오는 방식으로 코딩을 했었습니다. 플러터의 가장 큰 특징은 UI까지 모두 코드로 작성한다는 점입니다.구글에서 새롭게 선보이는 프레임워크이며, 개발자가 iOS와 Android 모두를 위한 고품질 기본 인터페이스를 제작하는데 도움을 주는 크로스 플랫폼 프레임워크입니다. 2019년 기준으로 Flutter는 React-Natice보다 선호하며, 75.4%로 높은 순위를 차지했습니다. 2.장점 및 단점1)장점 뛰어난 성능직접 컴파일 되어서 직접 Render하기 때문에 훨씬 빠르다. 신속한 개발상태를 기록하는 핫리로드(Stateful Hot Reload), 새로운 반응형 프레임워크, 다양한 위젯 세트 및 통합 도구와 같은 기능을 제공한다. 쉬운 크로스 프랫폼Android와 iOS 기반의 앱을 하나의 코드 베이스로 개발할 수 있다. Android의 material UI와 iOS의 cupertino UI를 플랫폼 제한 없이 상대 OS에서도 사용할 수 있다. 풍부하고 유연한 디자인작성 가능한 위젯 세트와 풍부한 애니메이션 라이브러리 및 확장 가능한 계층형 아키텍처를 제공한다. 고품질 환경이식성 있는 GPU 가속 렌더러 및 고성능의 네이티브 ARM 코드 런타임, 플랫폼 상호 운용성 기능을 통해 기기 및 플랫폼 전반에 걸쳐 고품질 환경을 지원한다. 2)단점 Dart라는 언어 사용하여 관련 오픈소스가 많지 않다. UI가 획일적으로 보일 수 있다. 3.Framework 구조 Flutter는 Dart로 구성되어 있는 코드들을 Flutter Engine을 통해서 Platform(Android, iOS 등)과 통신하게 되어있고, 이 과정이 JIT컴파일이던 AOT컴파일이던 상관 없이 동작합니다.또한 Dart의 중요한 개념 중 snapshot이라는 개념이 있는데, Dart 프로그램이 최초로 실행될 때 느리게 실행되는 것을 방지하기 위해서 파일을 미리 패키징하여 불러오는 방식이 있습니다. 이를 통해 최초 로딩 속도가 빨라지는 장점이 있습니다. widgetImage, Icon, Text 그리고 Row, Column, Padding도 모두 위젯이다. 프로젝트를 만들어보면, main.dart에서 runApp함수에 위젯을 전달하는 것부터 앱을 시작하는 것을 확인 가능하다. Rendering위젯으로 만들어진 Layer Tree를 Skia라는 그래픽 라이브러리를 이용하여 화면을 만들어낸다. ※ JIT(Just In Time):프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. ※ AOT(Ahead Of Time):미리 번역한 파일을 실행하는 기법이다. React Native와 비교 Flutter React Native 언어 Dart Javascript 외부 패키지 구글이 선두에 있는 만큼 빠르게 업데이트가 진행되고 있긴 하지만 아직은 패키지 버전들이 낮다. 라이브러리 호환성이 상당히 좋고, 패키지를 많이 보유하고 있다. 코드 재사용성 오버라이딩이 허용되어 코드 재사용이 가능하다. 코드의 재사용을 허용하지만 몇 가지 요소로 제한되어 있고, 재활용을 위한 스타일화의 시간이 오래 걸린다. UI 자체적인 위젯으로 동작한다. Native Component를 기반으로 한다. 개발속도 개발속도는 React Native와 비교하면 느리다. 개발속도는 Flutter와 비교하면 빠르다. Dart언어1.Dart가 만들어진 이유? 구글에서 만든 프로그래밍 언어로 플러터를 작성하는데 사용됩니다. 다트는 구글이 server-side 및 front-end 코드를 작성하는데 javascript 보다 더 나은 언어를 원했기에 만들어졌습니다. 구글은 아래와 같은 목표를 가지고 언어를 제작하게 되었습니다. 유연한 구조의 언어 개발자들에게 친근하고 자연스러운 언어 웹으로 접근하는 장비들을 모두 지원 가능한 언어 많이 사용되는 모던 브라우저들을 지원 가능한 언어 2.Dart의 특성 OOP(Object Oriented Programming)언어 Interface를 가진 단일 상속되는 Class를 가진 언어 isolates 기능을 통해 single-thread 언어임에도 불구하고 동시에 여러 프로세스를 동작 가능 3.Dart의 실행방식 Dart VM이 있는 브라우저(Chrome/Chromium)에서는 Dart Source가 바로 실행이 됩니다. 지원하지 않는 브라우저를 위해서는 DartC를 통해 Javascript 파일을 생성하여 실행 가능합니다. References https://brunch.co.kr/@myner/5 https://medium.com/flutter-korea/%EC%99%9C-flutter%EB%8A%94-dart%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-e838b9415f57 https://kimch3617.tistory.com/entry/Flutter%EB%9E%80-Flutter%EC%9D%98-%ED%8A%B9%EC%A7%95 https://medium.com/withj-kr/react-native-vs-flutter-%ED%81%AC%EB%A1%9C%EC%8A%A4%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EC%96%B4%EB%96%A4-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98-701ecbc19a24 https://skuld2000.tistory.com/69 https://medium.com/@pks2974/flutter-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-9532e16aff57 https://javaexpert.tistory.com/974 https://jaceshim.github.io/2019/01/28/flutter-study-stateful-widget-lifecycle/ https://insights.stackoverflow.com/survey/2019#methodology https://medium.com/@pks2974/bloc-%EC%9D%B4%ED%95%B4-%ED%95%98%EA%B8%B0-%EB%B0%8F-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC-%ED%95%98%EA%B8%B0-7dc705e4c640 http://murmurblog.com/layouts-in-flutter/","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"5. Flutter","slug":"it-tech/5-flutter","permalink":"http://yoursite.com/categories/it-tech/5-flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}]},{"title":"대시보드 설계와 데이터 시각화 2부","slug":"dashboard2","date":"2020-03-14T13:56:55.000Z","updated":"2021-11-13T10:48:21.515Z","comments":true,"path":"2020/03/14/dashboard2/","link":"","permalink":"http://yoursite.com/2020/03/14/dashboard2/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 신상은 대시보드 설계와 데이터 시각화 2부대시보드 설계와 데이터 시각화 1부에서는 데이터를 효과적으로 나타내는 방법과 여러가지 시각화를 나타내는 그래프의 종류에 대해서 알아 보았습니다.이번 편에서는 1부에서 소개드린 여러 시각화 그래프를 책에 나온 시나리오를 참고하여 어떤 상황이나 대시 보드에 맞추어 사용할 수 있는지에 대한 활용 방안에 대하여 살펴보고, 책에 소개된 다양한 시나리오 중에서 몇 가지 시나리오를 소개 해드리도록 하겠습니다. 1. 시나리오1.1. 기간별 순위 비교1.1.1. 구현 사항 특정 지역의 고객이 다른 지역 고객에 비해 얼마나 만족도가 높은지 알아보기 쉬워야 합니다. 현 분기 대비 전 분기 등 기간별로 성과를 비교할 수 있어야 합니다. 통계적 의미를 판단하기 위해 이전 기간과의 변화가 중요한지를 보여줘 야 합니다. 1.1.2. 관련 시나리오 제품과 서비스 매출을 주별로 세분화해 순위를 매긴 후, 이전 기간과 비교해야 하는 경우 현재 주간을 이전 주간과 비교해야 하는 경우 1.1.3. 대시보드의 특징과 장점(1) 데이터 비교에 용이한 막대 막대 그래프는 정렬 하기도 쉽고, 범위를 비교하기도 쉽습니다. 그래서 그래프에 레이블이 없어도 상단 막대 길이가 하단 막대보다 길면 약 2배임을 쉽게 알 수 있으며, 세로선이나 가로선을 넣어서 데이터를 비교하면 이전 기간과 비교하기 쉽다는 장점이 있습니다. 색상의 규약화는 현재 기간 성과를 이전 기간의 성과와 두드러지게 대조해, 성과가 하락했는지 개선 됐는지에 대해 분명한 시각화가 가능 합니다. (2) 이전 기간 대비 백분율 변화 이전 기간과의 백분율 차이 를 보여주면 매우 유용합니다. 백분율 차이보다 실제 숫자의 차이를 보고싶어하는 사람들도 있으므로 차이를 표시하는 두 방법 가운데 하나를 선택하게 하는 대시보드 위젯을 추가 할 수도 있습니다. 백분율의 차이가 실제 값보다 더 중요하다고 생각하면 그 차트를 더 크게 만들어야 합니다. 상세한 조사가 필요한 항목을 부각시키기 위해서는 막대그래프에 붉은 점을 표시하여, 현재와 이전 기간의 차이가 중요함을 나타낼 때 사용 할 수 있습니다. 붉은 점 덕분에 잠재적인 기회나 문제를 쉽게 확인 할수 있습니다. 또한 가장 중요한 질문을 가장 눈에 띄게 만들어야 합니다. 스파크라인은 지역마다 장기적으로 성과가 어떤지와 중요한 차이가 있는지 등을 한눈에 보여줍니다. 그래프 안에 붉은 점 범례를 사용하면 그래프의 장기적 성과를 재빨리 읽을 수 있습니다. 붉은 점은 변화가 생긴 시점이나, 중요한 의미가 있는 곳에 사용하기도 합니다. 1.2. 발전소 운영 모니터링1.2.1. 구현 사항 설치 지역별로 데이터를 보여줘야 합니다. 사용자가 지역 수준까지 파고들어 통시적 데이터를 볼 수 있어야 하므로 인터랙티브하게 동작 해야합니다. 장기적으로 계속 예상 출력에 미달되거나 출력을 초과하는 지역은 어디인지 알아야 합니다. 1.2.2. 관련 시나리오 여러 지역에 산재한 모든 분산 제조 공정에 대해 출력/성과를 추적 해야 하는 경우 최근과 비교한 용량 지표의 간결한 실시간 요약을 얻고자 하는 경우 실시간 결과를 운영 센터안의 벽걸이 디스플레이에 수동 인터렉션 없이 표시하려는 경우 1.2.3. 대시보드의 특징과 장점(1) 최신 데이터에 집중 심플한 디자인은 이해하기 쉽고, 한눈에 빠른 보기를 제공하며 핵심 요점을 강조 합니다. 영역 차트에 현재 값을 강조하면 사용자는 그 값에 집중해 전반적인 동향과 비교할 수 있습니다. 이러면 사용자가 더 이상 관련이 없는 최댓값, 최솟값보다 현재 값으로 관심을 돌리는 데 도움이 됩니다. 사용자는 꺾은 선 차트로 단일 시점 대신 특정 기간에 걸쳐 지역의 출력을 분석할 수 있습니다. 사용자는 조사 일자들을 데이터와 서로 매칭할 수도 있는데, 이렇게 하면 핵심 지역을 재빨리 파고들어 선택한 지역의 유지보수에 필요한 운영 데이터를 모두 얻을 수 있습니다. 벤 슈나이더만의 법칙: 대시보드를 디자인할 때, 벤 슈나이더만(Ben Shneiderman)의 법칙을 고려하자. 먼저 개요가 나오고, 줌과 필터, 그 뒤에 온디맨스 세부사항(details-on-demand)이 이어져야 한다. 이 사례는 정확히 이 권고를 따른다. (2) 불릿 그래프, 스파크라인, 성과 지표의 간결한 사용 심플한 불릿 그래프는 타겟 대비 실제 수치를 보여주며, 스파크 라인은 특정 기간의 동향을 나타냅니다. 스파크라인 차트는 대부분 데이터 동향만 나타냅니다. 스파크라인 차트와 불릿 그래프에 특정 타겟 선을 추가하면 데이터 동향을 적절한 맥락에 비춰볼 수 있습니다. 1.3. 연간 누적과 전년 대비 성과를 함께 비교1.3.1. 구현 사항 현재 일까지 연간 누적 매출 성과에 순위를 매겨 전년 매출과 비교해야 합니다. 한눈에 지역별로 성과가 얼마나 더 좋거나 나쁜지 알아볼 수 있어야 합니다. 목표 달성이 제대로 진척 중인지 알기 위해 동향을 살펴봐야 합니다. 특정 지역, 특정 기간의 매출 활동을 보는 방법이 필요 합니다. 1.3.2. 관련 시나리오 다양한 각 제품에 대한 초도 상담 해결율을 모니터링해서 전년도 해결율과 비교해야 하는 경우 올해 10개 지역의 기부금에 순위를 매겨 전년과 비교해야 하는 경우 현재의 연간 누적 티켓 매출을 전년도 매출과 비교해야 하는 경우 사용자의 서비스 사용량을 전년도 사용량과 비교해야 하는 경우 1.3.3. 대시보드의 특징과 장점(1) 쉽게 비교 가능한 막대 막대차트로는 어떤 지역의 매출이 다른 지역에 비해 얼마나 많은 지 보기가 쉽고 참조선 덕분에 성장세를 쉽게 파악 할 수 있습니다. 주된 관심사에 맞추어 데이터를 대조하기 위해 올해는 어두운 색으로, 작년은 밝은 색으로 그래프를 보여줍니다. 색상과 아이콘의 범례는 차트 안에 숨어 있어서 화면 공간을 더 차지하지 않습니다. (2) 공간을 최적화하는 숫자 배치 타겟 기기가 스마트폰임을 감안하면, 막대를 나타낼 공간이 넉넉하지 않습니다. 숫자를 막대 안에 배치하면 차트에 여유 공간이 생겨서 참조선과의 충돌을 피할 수 있습니다. 숫자를 막대 밖에 매치하면 차트는 복잡해지고 참조선과도 부딪힙니다. (3) 동향을 수집하기 쉬운 꺾은선 차트 빠른 요약 보기가 있으면 아주 좋지만 동향을 파악하는 것이 중요합니다. 예를 들어 전년보다 매출이 10% 하락했을 때, 그 차이는 최근에 발생 했는가? 아니면 연초부터 문제가 있었는가? 꺾은선 차트를 보면 해답이 나옵니다. 추세선은 차이가 좁아졌는가 넓어졌는가에 대한 사실을 보여주고 차트를 보고 해석하기에 용이합니다. 1.3.4. 적용하기 다음은 저희 피플앤드테크놀러지 솔루션에서 사용 중인 서비스 사용량 화면 입니다. 앞서 소개드린 대시보드의 특징과 장점을 살려서 현재의 화면을 아래와 같이 개선해 보도록 하겠습니다. 사용자는 개선 된 그래프를 통해 월별 평균 트래픽을 막대 그래프에 나타내어 이번 달 사용량과 평균 사용량을 비교 할 수 있으며, 연도별 데이터 트래픽을 꺾은선 차트로 사용량 추세를 확인 할 수 있습니다. 1.4. 웹 분석1.4.1. 구현 사항 블로그나 웹사이트의 방문자를 추적하여 해당 방문자들을 일정 기간 동안 살펴 보고자 합니다. 총 페이지뷰, 총 방문자, 기간 동안의 블로그 포스트 수를 보고자 합니다. 페이지뷰가 가장 많은 블로그 포스트나 웹 페이지를 보고자 합니다. 방문자의 지리적 위치를 파악 하고자 합니다. 요일별로 방문자 분포를 파악 하고자 합니다. 1.4.2. 관련 시나리오 책 판매, 판매 권수, 베스트셀러 도서, 판매 지역을 추적하고자 하는 출판사의 경우 장기적인 총 고객 확보, 인기 제품라인 카테고리를 보여주며 다양한 제품라인의 고객 확보 수치를 추적해야 하는 경우 서비스 구독자를 추적해야 하는 경우 장기적으로 수치를 취합해 인기 순위와 지리적 위치를 함께 보여주며 추적하고자 하는 경우 1.4.3. 대시보드의 특징과 장점(1) 단순하게 추적한 소수의 핵심 지표 꺾은선 차트, 히스토그램, 막대차트는 모두 이 지표의 변형을 보여줍니다. 이를테면 장기적 페이지뷰는 추세선이 그래진 막대 차트, 요일별 페이지뷰는 히스토그램, 인기 블로그 포스트별 페이지뷰는 일반 막대 차트로 표시합니다. 사용자수 수와 블로그 포스트 수는 텍스트에 추가 합니다. 대시보드의 기타 항목은 지도위의 사용자 위치 입니다. 색상으로 데이터를 규약화하지 않습니다. 색상을 단순화 하여 기업의 대표색이나 팀 색 같은 어떤 색상 조합도 효과적일 수 있습니다. (2) 다양한 비교를 위한 좋은 차트 유형 대시보드의 데이터 규약화에서 주된 방법론은 길이를 이용한 전주의적 속성입니다. 막대의 길이와 높이로 이 대시보드의 모든 데이터를 규약화 합니다. 그래서 비교는 아주 쉽고 정확해 집니다. 이를 통해 사용자는 주중보다 주말에 페이지뷰가 훨씬 더 적다는 사실을 알아차릴 수 있습니다. 실제로, 값이 비슷한 정도여도 그 작은 차이까지 분명히 나타낼 수 있습니다. 예를 들어 월요일 페이지뷰는 화, 수, 목요일 페이지뷰보다 약간 적습니다. (3) 복잡하지 않고 깔끔한 디자인 추가 데이터는 툴팁으로 보여주지만, 텍스트를 읽고 차트를 해석하는데도 문제가 없습니다. 툴팁은 선택하거나 강조한 특정 시점의 데이터 세부사항을 보여주기 위해 시각화 전반에 걸쳐 사용 합니다. 아래는 웹 분석에 흔히 사용 되는 구글 애널리틱스 화면 입니다. 사용자는 이 화면을 보고 특정 기간, 날짜를 선택 하여 페이지 뷰, 방문자 수, 세션 시간 등을 조회 할 수 있습니다. 1.5. 서버 프로세스 모니터링1.5.1. 구현 사항 서버 관리자로서 프로세스가 실패할 경우 재빨리 대응해야 합니다. 매일 아침, 지난밤 프로세스의 요약 보고가 담긴 이메일이 필요합니다. 실패한 프로세스에 대해 문제를 진단해 수정하는 데 유용한 추가적 맥락의 세부사항이 필요합니다. 1.5.2. 관련 시나리오 완성까지 생산 일정의 진행상황을 추적해야 하는 제조사의 경우 업무가 정확히 시작해 시간에 맞춰 운영되는지 추적해야 하는 이벤트 관리자 1.5.3. 대시보드의 특징과 장점(1) 간트 차트의 레이블 간트 차트에 운영 중인 그래프에 사용자가 빨간 색의 실패한 작업을 볼 때, 이름도 시선이 놓인 그 곳에 바로 있으므로 작업명을 찾으러 좌측으로 시선을 이동해 살필 필요가 없습니다. (2) 참조선 실패한 프로세스를 빨리 찾는 것 외에 그 실패에 일조할 수도 있는 다른 프로세스에 대한 표식이 필요합니다. 이 경우는 참조선으로 예약 일정과 지속 시간을 보여 줍니다. 수직 실선은 작업마다 평균 지속 시간을 보여줍니다. 이 실선을 보여줌으로써 사용자는 하나의 지연이 다른 지연을 유발 했는지를 알게 됩니다. (3) URL 액션 툴팁에는 URL이 들어 있습니다. 어떤 세부사항을 더 조사해야 할지 알 수 있으며, 클릭 한번이면 관련 정보로 바로 이동할 수 있습니다. 이와 같이 빠르고 직접적인 정보이동은 사용자를 흐름에 맡기므로 모든 대시보드에서 중요 합니다. 사용자는 관련된 다음 대시보드를 찾느라 시간을 낭비할 필요가 없습니다. URL로 직접 이동할수 있기 때문입니다. (4) 개요, 줌과 필터, 온디맨드의 세부사항 모두가 알다시피, 성공적인 대시보드는 데이터를 탐구하도록 유도하는 측면도 있습니다. 벤 슈나이더만은 데이터 시각화의 모범관례를 다음과 같이 설명 했습니다. ① 개요 ② 줌과 필터 ③ 온디맨드의 세부사항 최근 일자들의 서버 성능 개요가 있습니다. 날짜를 클릭하면 하루별 내용 보기로 필터링할 수 있습니다. 이어서 작업을 클릭해 온디맨드로 세부사항을 얻을 수 있습니다. 그러면 작업 요약 뷰에 세부사항이 나타나거나, URL을 클릭해 서버 자체의 작업으로 바로 이동 합니다. 흐름이 위에서 아래로 자연스럽게 이어지므로 따라가기가 쉽습니다. 아래는 서버 모니터링의 오픈소스로 널리 알려진 스카우터 화면 입니다. 사용자는 서버 모니터링 화면을 통해 CPU, memery, disk, TPS 등의 정보를 알 수 있고 이를 통해 에러가 발생한 시각, 문제 원인을 얻을 수 있습니다. 1.6. 병원 수술실의 이용 현황 대시보드1.6.1. 구현 사항 이 대시보드에 포함된 지표는 사용자가 실제 수술 시간 대비 예상 수술 시간의 정확도를 비교할 때 도움이 됩니다. 예약된 일정이 부정확하게 운영되면 정확한 일정 준수, 시설 활용, 수술실 회전 시간, 환자 만족도에 부정적 영향을 줍니다. 1.6.2. 관련 시나리오 회의실 예약 등 시설 운용 계획을 시각화해야 하는 경우 콘서트 일정이나 행사 장소의 청소, 공조 등 유지보수와 같은 이벤트 기획을 시각화 해야 하는 경우 자원 예약을 모니터링 해야 하는 의료 서비스 경우 비행기가 정확한 시각과 위치에 배치 하도록 보장 해야 하는 항공 일정 관리 운송이나 물류 회사에서 운전기사 관리 등 물류 정보를 시각화 해야하는 경우 1.6.3. 대시보드의 특징과 장점(1) 정확한 값을 표시하는 달력 보기 이 대시보드에는 달력 보기와 히트맵이 더 효과적 입니다. 의사는 매주 구체적으로 할당된 수술실 날짜와 시간에 수술을 집도하는 경우가 많습니다. 그러므로 해당 수술 일자를 직접 몇 주나 몇 달간 확인하고 비교해서 수술실 예약의 개선 기회, 추가적인 수술실 자원의 수요에 관한 단서를 제공하는 일정과 활용 패턴이나 추세도 검토할 수 있으면 유용합니다. (2) 모든 데이터의 표시 대부분 상황에서는 취합된 데이터만 보여주면 숫자가 타겟보다 적은 이유를 정당화하기가 쉽습니다. 이 경우에서는, 의사별로 취합도딘 수술실의 효율성은 부정확한 데이터로 여겨 쉽게 버려질 수 있습니다.수술실 마다 일별로 세분화하는 기능은 문제를 상세히 보여줍니다. 이런 대시보드가 있기전에는 의사들이 개요 데이터에만 접근 가능 했을 것 입니다. 하지만 세부 데이터도 모두 볼 수 있으므로 문제를 확인해 개선 기회도 확인할 수 있습니다. 1.7. 순위와 규모를 보여주는 방법1.7.1. 구현 사항 매출별로 상위 20위 제품을 보여주어야 합니다. 매출의 순위와 규모를 모두 봐야 합니다. 고객 세그먼트, 성별 등 다양한 디멘전에 걸쳐 매출과 함께 순위가 어떻게 변하는지 살펴야 합니다. 1.7.2. 관련 시나리오 다중 선택 질문의 소비자 설문을 통해 어떤 제춤을 가장 많이 선택했는지를 다양한 카테고리별 순위로 보고싶은 경우 사람들에게 정치 후보자에 대한 선호도를 물어서 성별 연령별, 지역별 선호도를 확인하고 싶은 경우 다양한 음악 그룹의 인기도를 국가별, 성별, 카테고리별로 비교 하고 싶은 경우 1.7.3. 대시보드의 특징과 장점(1) 다각적인 접근법 다각적인 접근법은 순위를 매겨야 하는 거의 모든 경우에 효과적 입니다. 설문 조사와 같은 전반적인 결과에 선택된 값은 레이블을 선택하여 그 활용과 순위를 세분화하여 볼 수 있습니다.막대 차트로는 특정 제품의 매출이 다른 제품에 비해 얼마나 많거나 적은지를 쉽게 볼 수 있습니다. 실제로 막대 옆의 숫자를 보여주지 않고도 인기 있는 제품이 무엇인지를 알 수 있습니다. (2) 범프 차트(Bump chart) 개별 순위를 장기적으로, 혹은 다양한 디멘전에 걸쳐 보여주는 방법으로 사람들에게 인기 높은 방법으로는 규모가 중요하지 않은 경우라면 범프 차트가 좋은 선택 입니다. 하지만 순위 있는 막대와 범프 차트를 사용할 때 주의할 점이 있습니다. 한 차트에 제품이나 팀, 이슈 등을 한꺼번에 표시할 수는 없습니다. 그러면 사용자에게 해독이 불가능한 막대와 선이 뒤죽박죽 얽힌 모습을 보이게 되기 때문입니다. 2가지 경우 모두 사용성 높은 차트를 만드려면, 각 항목을 선택해서 시각화 상태의 화면을 캡처하거나, 필요한 인터랙션이 있는 대시보드를 별도로 제공해야 합니다. 1.8. 잠재적 활용 대비 실제 활용의 표시1.8.1. 구현 사항 각 부서마다 자원 활용 타겟 대비 성과가 어떤지 파악 해야 합니다. 한 부서에서 잠재적인 수수료 수입보다 비용이 더 많이 드지는지 여부를 파악 해야 합니다. 활용도가 낮은 잠재적 원인을 확인하기위해 청구 불가한 시간의 세분화를 파악 해야 합니다. 1.8.2. 관련 시나리오 청구 가능한 시간과 잠재적으로 청구 가능한 시간을 소프트웨어 개발 지원 인력에 대해 부서 전반에 걸쳐 비교 해야하는 회사의 경우 직원들의 시간을 추적하고 자원과 식품의 적정한 활용 수준을 모니터링 해야하는 경우 1.8.3. 대시보드의 특징과 장점(1) 개요와 색상 범례 대시보드는 서로 다른 척도를 보여주지만, KPI 점들 덕분에 성과가 나쁜 영역에 집중하기 쉽습니다. 화면 상단에 있는 숫자는 핵심성과 지표에 걸쳐 조직의 성과를 보여주며, 색상 범례 역할을 합니다. (2) 비교하기 쉬운 막대 막대를 누적하여 전반적으로 어떤 부서가 높거나 낮은지 살필 수 있습니다. 누적 막대 뒤에 더 넓고 밝은 색의 타겟 막대를 배치하면, 얼마나 높고 낮은지 알 수 있습니다. 막대를 지능적으로 배치하고 색과 참조선을 사용하여 간결한 차트 하나로 여러 질문에 답할 수 있습니다. 어떤 부서가 가장 많은 시간 일하는지? 어떤 부서가 청구 가능한 시간의 백분율이 가장 높은지? 어떤 부서가 간단한 타겟을 넘는지? 어떤 부서가 타겟보다 상당히 낮은지? 사람들은 공통 기준선으로 막대 길이를 비교하는 데 능숙하지만, 온디맨드로 팝업을 통해 세부사항을 제공할 수 있습니다. 2. 정리 지금까지 여러가지 시나리오를 통해 대시보드를 설계 하는 방법과 데이터를 시각화 하는 방법에 대해 알아 보았습니다. (1부가 궁금하신 분들은 &#10004;여기를 참고 해주세요. ) 이 책에 소개된 시나리오를 몇 가지 추려서 소개 드렸는데, 시나리오 목적에 맞는 경우 대시보드의 특징을 살려서 여러분들이 대시보드를 설계 하는데 이 글이 조금이나마 도움이 되셨으면 좋겠습니다. 읽어 주셔서 감사합니다! &#128519; 출처 도서: &lt;대시보드 설계와 데이터 시각화&gt; https://datavizproject.com/family/chart/# https://help.qlik.com/en-US/sense/February2020/Subsystems/Hub/Content/Sense_Hub/Visualizations/VisualizationBundle/bullet-chart.htm https://www.klipfolio.com/resources/dashboard-examples/executive/kpi-dashboard https://help.privy.com/hc/en-us/articles/360024415834-How-To-Find-the-Monthly-Pageviews-for-Your-Website-in-Google-Analytics https://chartio.com/blog/new-chart-type-sparklines/","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"2. Data Analysis","slug":"it-tech/2-data-analysis","permalink":"http://yoursite.com/categories/it-tech/2-data-analysis/"}],"tags":[{"name":"dashboard","slug":"dashboard","permalink":"http://yoursite.com/tags/dashboard/"},{"name":"data analysis","slug":"data-analysis","permalink":"http://yoursite.com/tags/data-analysis/"}]},{"title":"Jedis Pool 최적화","slug":"jedis-pool","date":"2020-02-02T05:34:05.000Z","updated":"2021-11-13T10:48:21.523Z","comments":true,"path":"2020/02/02/jedis-pool/","link":"","permalink":"http://yoursite.com/2020/02/02/jedis-pool/","excerpt":"","text":"작성자 : 플랫폼 개발실 실장 김완철(David Kim) https://partners-intl.aliyun.com/help/doc-detail/98726.htm 에 있는 JedisPool optimization 영문 내용을 번역하였습니다. JedisPool 파라미터를 설정하면 Redis의 성능을 향상시키는 데 도움이 된다. 이 주제에서는 JedisPool을 사용하고 리소스 풀 파라미터를 구성하는 방법에 대해 설명한다. 또한 JedisPool을 최적화하기 위한 권장 파라미터 구성을 제공한다. JedisPool 사용법 2.9.0 버전을 사용하며, 메이븐 디펜던시는 다음과 같다. 123456&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; Jedis는 Apache Commons-pool2를 사용하여 리소스 풀을 관리한다. JedisPool을 정의 할 때 GenericObjectPoolConfig 파라미터 (리소스 풀)에 주의해야 한다. 다음 예제는 이 파라미터를 사용하는 방법을 설명한다. 123456GenericObjectPoolConfig jedisPoolConfig = new GenericObjectPoolConfig();jedisPoolConfig.setMaxTotal(...);jedisPoolConfig.setMaxIdle(...);jedisPoolConfig.setMinIdle(...);jedisPoolConfig.setMaxWaitMillis(...) ;... JedisPool의 초기화는 다음과 같다. (번역 주, 일반적으로 Spring Framework의 경우 RedisTemplate 를 이용하여 구성한다) 123456789101112131415// redisHost indicates the instance IP address. redisPort indicates the instance port. redisPassword indicates the password of the instance. The timeout parameter indicates both the connection timeout and the read/write timeout.JedisPool jedisPool = new JedisPool(jedisPoolConfig, redisHost, redisPort, timeout, redisPassword);//Run the command as follows:Jedis jedis = null;try &#123; jedis = jedisPool.getResource(); // Specific commands jedis.executeCommand()&#125; catch (Exception e) &#123; logger.error(e.getMessage(), e);&#125; finally &#123; //In JedisPool mode, the Jedis resource will be returned to the resource pool. if (jedis ! = null) jedis.close();&#125; 파라미터 설명 Jedis 커넥션은 커넥션 풀에서 JedisPool이 관리하는 리소스이다. JedisPool은 스레드로부터 안전한 커넥션 풀이며 모든 리소스를 관리 가능한 범위 내에서 유지할 수 있다. GenericObjectPoolConfig 파라미터를 올바르게 구성하면 Redis 성능을 향상시키고 리소스 소비를 줄일 수 있다. 다음 두 표는 중요한 파리미터를 설명하고 파라미터 구성에 대한 권장 사항을 제공한다. 표 1. 리소스 설정 및 리소스 사용과 관련된 파라미터 idle (유휴) Jedis 객체 감지는 다음 네 가지 파라미터로 구성됩니다. testWhileIdle은 이 기능의 스위치이다. 표 2. idle 리소스 감지와 관련된 파라미터 사용자 편의를 위해 Jedis는 idle 커넥션의 유효성을 검사 할 때 GenericObjectPoolConfig와 일부 구성을 공유하는 JedisPoolConfig를 제공한다. 123456789public class JedisPoolConfig extends GenericObjectPoolConfig &#123; public JedisPoolConfig() &#123; // defaults to make your life with connection pool easier :) setTestWhileIdle(true); setMinEvictableIdleTimeMillis(60000); setTimeBetweenEvictionRunsMillis(30000); setNumTestsPerEvictionRun(-1); &#125;&#125; org.apache.commons.pool2.impl.BaseObjectPoolConfig에서 모든 기본값을 볼 수 있다. 주요 파라미터 구성에 대한 권장 사항 maxTotal : 최대 커넥션 수 maxTotal 을 올바르게 설정하려면 다음 요소를 고려해야 한다. 비즈니스에 필요한 Redis 동시 커넥션. 클라이언트가 명령을 실행하는 데 걸리는 시간 Redis 리소스의 한계. 예를 들어 maxTotal에 노드 (애플리케이션) 수를 곱한 결과는 Redis에서 허용되는 최대 커넥션 수보다 작아야 한다. 커넥션 생성 및 해제 비용. 각 요청에 대해 생성 및 해제된 커넥션 수가 많으면 생성 및 해제 프로세스시 막대한 비용이 소요된다. 리소스를 얻기 위해 명령을 실행하는 시간은 리소스를 빌리는 시간, 반환하는 시간, JedisPool이 명령을 실행하는 시간 및 네트워크 연결 시간으로 구성된다. 리소스를 얻기 위해 명령을 실행하는 데 걸리는 평균 시간이 약 1ms 인 경우 연결의 QPS(Queries Per Second-초당 쿼리스) 는 약 1,000이며 비즈니스에서 예상하는 QPS는 50,000 인 경우 이론적으로 필요한 풀 크기는 50 (50,000 / 1,000 = 50) 이다. 그러나 이것은 이론적인 수치일 뿐이다. 일부 리소스를 확보하기 위해 maxTotal 파라미터의 값은 이론적인 값보다 클 수 있다. 그러나 이 값이 너무 크면 연결에 너무 많은 클라이언트 및 서버 리소스가 사용된다. 반면, QPS가 높은 Redis와 같은 서버의 경우 명령 실행시 Blocking 이 있으면 큰 리소스 풀조차도 이 문제를 해결하는 데 도움이 되지 않는다. maxIdle and minIdle maxIdle 은 비즈니스에 필요한 실제 최대 커넥션 수이며, maxTotal은 idle 커넥션 수를 잉여로 포함한다. 로드량이 많은 시스템에서 maxIdle 을 너무 낮게 설정하면 요청을 처리하기 위해 new Jedis (추가 연결)가 생성된다. 따라서 minIdle은 풀에 보관해야 하는 최소 커넥션수를 지정하도록 구성된다. maxTotal = maxIdle 인 경우 커넥션 풀이 최상의 성능에 도달한다. 이렇게 하면 커넥션 풀의 확장시에도 성능은 영향을 받지 않는다. 그러나 동시 커넥션 수가 작거나 maxTotal 파라미터가 너무 높게 설정되면 커넥션 리소스가 낭비된다. 실제 총 QPS 및 Redis를 호출하는 클라이언트 수를 기반으로 각 노드에서 사용하는 커넥션 풀 크기를 평가할 수 있다. 최상의 파라미터 값을 찾으려면 모니터링 도구를 사용하자 모니터링 도구를 사용하여 최상의 파라미터 값을 얻는 것이 보다 안정적인 방법이다. JMX 모니터링 또는 기타 모니터링 도구를 사용하여 최상의 파라미터 값를 찾을수 있다. FAQ 부족한 리소스 다음 두 경우에는 리소스 풀에서 리소스를 얻을 수 없다. Timeout 1234redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool…Caused by: Java. util. nosuchelementexception timeout waiting for idle objectat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:449) blockWhenExhausted를 false로 설정하면, maxWaitMillis 로 지정된 시간이 사용되지 않으며, idle connection 이 사용 가능할 때까지 호출이 block 된다. 1234redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool…Caused by: java.util.NoSuchElementException: Pool exhaustedat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:464) 풀 크기가 제한되어 있기 때문에 이 예외가 반드시 발생하는 것은 아닙니다. 자세한 정보는 주요 파라미터 구성에 대한 권장 사항 참조해라. 이 문제를 해결하려면 네트워크, 리소스 풀의 파라미터 구성, 리소스 풀 모니터링 (JMX 모니터링), 코드 (예 : jedis.close ()가 실행되지 않는 이유일 수 있음), 느린 쿼리 및 DNS 를 확인하는 것이 좋다. Warm up JedisPool 작은 timeout 설정과 같은 몇 가지 이유로 프로젝트 초기 구동시 시간이 초과 될 수 있다. JedisPool은 최대 리소스 수와 최소 idle 리소스 수를 정의 할 때 커넥션 풀에 Jedis 커넥션을 만들지 않는다. 풀에 idle 커넥션이 없으면 new Jedis 커넥션이 생성된다. 이 커넥션은 사용 된 후에 풀로 반환된다. 그러나 새 커넥션을 만들고 매번 커넥션을 해제하려면 시간이 많이 걸린다. 따라서 JedisPool을 정의한 후 최소 idle 커넥션 수로 JedisPool을 예열(Warm up) 하는 것이 좋다. 예는 다음과 같다. 12345678910111213141516171819202122232425List&lt;Jedis&gt; minIdleJedisList = new ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle()); for (int i = 0; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123; Jedis jedis = null; try &#123; jedis = pool.getResource(); minIdleJedisList.add(jedis); jedis.ping(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; finally &#123; &#125;&#125;for (int i = 0; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123; Jedis jedis = null; try &#123; jedis = minIdleJedisList.get(i); jedis.close(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; finally &#123; &#125;&#125; 원문 : https://partners-intl.aliyun.com/help/doc-detail/98726.htm 참고 : https://d2.naver.com/helloworld/5102792","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"스프링부트 시작하기","slug":"springboot01","date":"2020-01-20T11:00:00.000Z","updated":"2021-11-13T10:48:21.532Z","comments":true,"path":"2020/01/20/springboot01/","link":"","permalink":"http://yoursite.com/2020/01/20/springboot01/","excerpt":"","text":"작성자 : 플랫폼 개발실 서버개발팀 김은혜 스프링부트스프링 웹 어플리케이션을 만들기 위해서 서버 설치, config 설정 등의 여러 기본 설정들이 필요합니다. 또한, 템플릿 엔진의 버전과 Spring 버전의 호환성, 의존성을 확인하는 과정이 꼭 필요합니다.스프링부트는 이러한 과정을 거치지 않고도 빠른 개발이 가능케 합니다. 내장된 웹 서버(Tomcat, Jetty)와 의존성을 손쉽게 관리할 수 있는 스타터 POM(Project Object Model), 설정의 표준화와 자동화 등을 지원하여 보다 쉽게 웹 애플리케이션 개발할 수 있도록 도와줍니다. 이를 바탕으로 스프링부트는 ‘스프링부트 애플리케이션의 대부분은 스프링 설정을 필요로 하지 않는다’라고 설명하고 있습니다. 이번 글은 스프링부트 프로젝트의 기본을 설정하면서 새롭게 알게된 정보들로 구성하여 작성했습니다. 스프링부트의 버전스프링부트 1.0버전을 2014년 4월 1일 공개한 이후로 1.5.X버전은 2019년 8월 1일부로 지원을 중단했습니다.현재는 2.2.X버전이 공개되어 있으며, 아래 예제는 최신 버전 2.2.X버전을 사용했습니다.스프링부트 1.5.X 까지는 JDK 6과 7을 지원했지만 2.2.X는 Java 8 이상이 필수이며, Java 13까지 호환됩니다.Build Tool로 Maven은 3.3+버전, Gradle은 5.X와 6.X을 지원합니다. Gradle은 4.10 또한 지원되지만 deprecated 되었습니다.2.2.X버전에서 Tomcat은 9.0, Jetty는 9.4, Undertow는 2.0을 지원하고 있습니다. 개발환경예제 프로젝트의 개발환경은 아래와 같습니다. OS : Window 10 IntelliJ IDEA Ultimate SpringBoot 2.2.X JDK 8 Gradle 6.0.1 MySql 5.6.41 1. 프로젝트 생성하기IntelliJ에서는 Spring Initiallizr로 스프링부트 프로젝트의 생성을 시작합니다. Type은 Gradle Project로 생성했습니다. Packaging은 빠르고 간편하게 생성할 수 있는 Jar로 선택했습니다.War는 기존과 같이 외부의 톰캣으로 배포하는 구조로 만들어지며, Jar로 로컬개발 및 테스트를 하다 나중에 배포할 때 War로 변경해서 배포할 수도 있습니다. eveloper Tools 의 Lombok Web의 Spring Web Template Engines의 Apache Freemarker를 선택했습니다. 프로젝트의 이름과 위치를 지정한 후 Finish로 프로젝트를 생성합니다. 2. 프로젝트 구성프로젝트가 생성되면 다음 파일들이 생성됩니다. 메인은 DemoApplication.java 프로퍼티파일은 application.properties 빌드는 build.gradle 톰캣 관련한 설정들은 스프링부트가 구동될 때 내부 모듈에 의해서 자동설정 됩니다. 1) DemoApplication.java스프링부트의 메인 class 입니다. 123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 스프링부트의 Auto Configuration 기능을 사용하기 위해선 @EnableAutoConfiguration 또는 @SpringBootApplication 중 하나를 사용해야 합니다. @SpringBootApplication은 @EnableAutoConfiguration @ComponentScan @Configuration 를 포함하고 있습니다. @EnableAutoConfiguration : 스프링부트의 Auto Configuration 을 사용할 수 있습니다. 의존성 라이브러리를 기반으로 사용 가능성이 높은 bean을 추측해 자동으로 등록합니다. @ComponentScan : 사용할 application의 패키지를 bean으로 찾아서 등록합니다. (스프링부트 문서가 추천하는 방법입니다.) @Configuration : bean을 추가 등록하거나 configuration을 추가 import 할 때 사용합니다. 데이터베이스 설정없이 구동하고 싶다면,@SpringBootApplication 을@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 로 대체하면 오류없이 구동이 가능합니다.구동 후 http://localhost:8080 을 입력하면 에러 페이지가 나오는데 이는 설정된 페이지가 없을 뿐, 정상적으로 실행은 가능합니다. 간단하게 localhost 에서 페이지를 보고 싶다면 정적인 웹리소스를 관리하는 src/main/resources/static 안에 아래와 같은 index.html 을 하나 생성하고 구동하면 그 다음 아래와 같은 이미지를 볼 수 있습니다.static 폴더는 처음 프로젝트를 만들 때 Web 라이브러리를 선택했다면 자동으로 생성됩니다. 12345678910&lt;!DOCTYPEhtml&gt; &lt;htmllang=\"en\"&gt; &lt;head&gt; &lt;metacharset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello,SpringBoot!! &lt;/body&gt;&lt;/html&gt; 2) application.properties를 application.yml로처음에는 빈 파일로 application.properties 파일이 생성됩니다.생성된 파일에 먼저 freemarker의 경로를 설정했습니다. 12spring.freemarker.template-loader-path=classpath:/templates/spring.freemarker.suffix=.ftl 프로퍼티파일인 application.properties 파일은 아래와 같이 application.yml 파일로 변경해 사용할 수도 있습니다.아래와 같이 가독성이 좋은 yml로 변경해서 설정을 변경해보았습니다./static/index.html 은 삭제해야만 localhost에서 /templates/index.ftl 이 실행이 됩니다. 1234spring: freemarker: template-loader-path: classpath:/templates/ suffix: .ftl yml 파일은 사람이 보기 편하며, profile은 하이픈(—)으로 나누어 환경에 따라 설정값을 다르게 가져갈 수 있는 장점이 있습니다.주의사항으로 Yaml 언어는 공백 하나에도 민감합니다. 하위 계층으로 내려갈 때 탭이 아닌 스페이스바를 사용하고, 콜론(:)이나 하이픈(-) 이후에도 공백 한 칸이 필요합니다. 3) build.gradle프로젝트 생성이 끝나면 빌드도구 Gradle의 설정파일이 아래와 같이 자동 설정됩니다. 123456789101112131415161718192021222324252627282930313233plugins &#123; id &apos;org.springframework.boot&apos; version &apos;2.2.2.RELEASE&apos; id &apos;io.spring.dependency-management&apos; version &apos;1.0.8.RELEASE&apos; id &apos;java&apos;&#125; group = &apos;com.springboot&apos;version = &apos;0.0.1-SNAPSHOT&apos;sourceCompatibility = &apos;1.8&apos; configurations &#123; compileOnly &#123; extendsFrom annotationProcessor &#125;&#125;repositories &#123; mavenCentral()&#125; dependencies &#123; implementation &apos;org.springframework.boot:spring-boot-starter-freemarker&apos; implementation &apos;org.springframework.boot:spring-boot-starter-web&apos; compileOnly &apos;org.projectlombok:lombok&apos; annotationProcessor &apos;org.projectlombok:lombok&apos; testImplementation(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123; exclude group: &apos;org.junit.vintage&apos;, module: &apos;junit-vintage-engine&apos; &#125;&#125; test &#123; useJUnitPlatform()&#125; Repositories는 외부 jar파일들을 추가하기 위해 존재해야 하고, Repositories 정의는 default 값이 없으므로 꼭 정의가 필요합니다. mavenCentral() 저장소 또는 jcenter() 저장소를 사용할 수 있습니다. Url을 통해 원격으로 사용할 수도 있고, 로컬 저장소를 참조하여 사용할 수도 있습니다. dependencies는 필요한 라이브러리를 추가할 수 있으며, 버전도 같이 명시해 줄 수 있습니다. 참고&quot;Plugins 설정&quot;Plugins 설정은 buildscripts와 plugins 두 가지 방식으로 선언이 가능합니다.아래와 같은 buildscripts 방식은 고전적인 방식이라고 설명되어 있습니다. 12345678910buildscript &#123; def springBootVer = &quot;2.0.6.RELEASE&quot; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$springBootVer&quot; &#125;&#125;apply plugin : Gradle 공식 문서에 따르면 Plugins DLS은 플러그인 의존성을 선언하는데 간결하며 편리한 방법을 제공하며, 코어 및 커뮤니티 플러그인에 모두 쉽게 접근할 수 있다고 합니다.gradle 4.6부터 적용되었고 다른 버전의 플러그인을 각각 지정하거나 전역으로 적용할지에 대한 여부 등을 선택할 수도 있습니다. 12345plugins &#123; id &apos;org.springframework.boot&apos; version &apos;2.2.2.RELEASE&apos; id &apos;io.spring.dependency-management&apos; version &apos;1.0.8.RELEASE&apos; id &apos;java&apos; &#125; &quot;빌드도구 Maven와 Gradle의 차이&quot;빌드도구 Maven, Gradle은 라이브러리 의존성을 관리, 애플리케이션을 배포가능한 상태로 포장(Packaging or Archiving, 패키징 또는 아카이빙)하는 과정을 담당합니다. Maven은 XML을 사용하지만, Gradle은 Groovy 문법을 사용합니다. XML을 사용함으로써 설정 내용이 길어지고 가독성이 복잡하지만, Gradle은 Tab으로 구분하여 스크립트 길이와 짧고 가독성이 좋습니다. Gradle은 상속구조를 이용한 멀티 모듈 구현이 쉽습니다. Maven보다 Gradle의 빌드 속도가 최대 100배 빠르다고 합니다. Gradle Daemon은 메모리에 오래 살아있으며, 변경에 영향을 받는 것들만 재컴파일을 실행합니다. Gradle은 캐시를 사용하기 때문에 테스트 반복 시 차이가 더 커집니다. 3. MySql 연동 + MyBatis 설정MyBatis와 연결하기 위해서 build.gradle 에서 dependency를 추가해야 합니다.첫 번째, implementation ‘org.springframework.boot:spring-boot-starter-web’ 하단에implementation ‘org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.1’ 를 추가합니다.두 번째, compileOnly ‘org.projectlombok:lombok’ 하단에runtimeOnly ‘mysql:mysql-connector-java’ 를 추가합니다. 추가 후 Gradle Toolbar를 열고 새로고침 아이콘에 마우스오버 하면 Reimport All Gradle Projects가 보이는데 클릭합니다.실행완료 후 External Libraries에 mysql-connector-java와 mybatis 라이브러리가 정상적으로 import 됐는지 확인하면 됩니다. application.yml 은 아래와 같이 datasource를 추가합니다.com.mysql.jdbc.Driver는 deprecated 되었기 때문에 com.mysql.cj.jdbc.Driver를 적용해야 합니다.스프링부트 2.0부터 HikariCP가 기본으로 변경되었다고 하며, 저는 hikari를 덧붙여 이름을 정의해 MySql을 연동했습니다. 12345678910spring: freemarker: template-loader-path: classpath:/templates/ suffix: .ftl datasource: hikari: driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://localhost/test?serverTimezone=UTC username: scott password: scott 다음 DemoApplication.java 내부에 빈들을 정의했습니다.먼저 @ConfigrationProperties를 사용해 yml에 설정한 내용을 DataSource로 가져온 후, sqlSessionFactory와 sqlSessionTemplate을 구현했습니다.setMapperLocations한 경로 아래 즉, resources 안에 mapper 폴더를 생성하고 그 내부에 ..Mapper.xml 을 생성하면 됩니다. 1234567891011121314151617181920@Bean@ConfigurationProperties(prefix = \"spring.datasource.hikari\")public DataSource dataSource()&#123; return DataSourceBuilder.create() .type(HikariDataSource.class) .build();&#125;@Beanpublic SqlSessionFactory sqlSessionFactory(DataSource dataSource, ApplicationContext applicationContext) throws Exception&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/**.xml\")); return sqlSessionFactoryBean.getObject();&#125;@Beanpublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory)&#123; return new SqlSessionTemplate(sqlSessionFactory);&#125; MyBatis와 연동을 위해 사용할 VO로 java/com/springboot/web/demo 안에 user 폴더를 생성한 후 User.java를 생성했습니다.Lombok을 사용하여 Getter, Setter를 만들어주었습니다. 1234567@Getter@Setterpublic class User &#123; private int num; private String name; private String email;&#125; 예시로 사용할 select 쿼리를 포함한 UserMapper.xml을 생성했습니다. 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.demo.user.UserMapper\"&gt; &lt;select id=\"findOne\" parameterType=\"Integer\" resultType=\"com.example.demo.user.User\"&gt; SELECT num, name, email FROM user WHERE num = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.xml과 연결을 위해 java/com/springboot/web/demo/user 안에 UserMapper.java를 생성했습니다.간단하게 @Mapper를 사용했으며, 연결을 위해 …Mapper.xml 안의 id와 …Mapper.java 메서드의 이름을 동일하게 설정해주었습니다. 12345@Mapper@Repositorypublic interface UserMapper &#123; public User findOne(int num);&#125; 생성한 Mapper를 사용하기 위해 UserController를 생성했습니다. 123456789101112@Controllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @RequestMapping(value=\"/user\") public String getUserList(Model model)&#123; model.addAttribute(\"user\", userMapper.findOne(1)); return \"user\"; &#125;&#125; Mapping 될 뷰로 resources.templates 안에 user.ftl을 추가해주었습니다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello, Spring Boot!! &lt;br&gt; Hello, FreeMarker!! &lt;br&gt; Name : $&#123;user.name&#125; &lt;br&gt; Email : $&#123;user.email&#125;&lt;/body&gt;&lt;/html&gt; 실행 후 브라우저에서 http://localhost:8080/user 을 띄우면 정상적으로 데이터가 보여지는 것을 확인할 수 있습니다. 마무리여기까지 스프링부트의 서버 설정 없이, 간단한 의존성 추가와 간단한 소스 구성으로 간단한 웹 프로젝트를 구축해 볼 수 있었습니다. References https://medium.com/@yongkyu.jang/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-springboot-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1-1-%EC%B2%AB%EA%B1%B8%EC%9D%8C-2aa01e808f62 http://honeymon.io/tech/2019/06/17/spring-boot-2-start.html https://d2.naver.com/helloworld/5626759 https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#getting-started-introducing-spring-boot http://honeymon.io/tech/2019/06/17/spring-boot-2-start.html https://jojoldu.tistory.com/250 https://jojoldu.tistory.com/296 https://bkim.tistory.com/13 https://jeong-pro.tistory.com/159 https://waspro.tistory.com/504","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"}],"tags":[{"name":"springBoot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"디자인패턴 1부 - 생성패턴","slug":"java-design-pattern-creational","date":"2020-01-08T11:00:00.000Z","updated":"2021-11-13T10:48:21.522Z","comments":true,"path":"2020/01/08/java-design-pattern-creational/","link":"","permalink":"http://yoursite.com/2020/01/08/java-design-pattern-creational/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 김솔잎 디자인 패턴디자인 패턴은 주로 객체지향 프로그래밍 언어로 소프트웨어 개발할 때에, 특정 상황에서 자주 나타나는 문제를 해결하기 위해 수많은 개발자가 쌓아온 솔루션입니다. 어떠한 문제가 발생하는 상황이 있는데, 이런 방법으로 해결한다. 디자인 패턴은 결국 어떠한 문제를 해결하기 위해 존재하는 것입니다.디자인 패턴에서는 문제 해결의 목적을 기준으로 3가지 형태로 분리하고 있습니다.그 종류로는 ‘객체를 어떻게 생성할 것인가?’와 관련된 생성 패턴 과 ‘생성된 객체들을 어떻게 조합/합성할 것인가?’와 관련된 구조 패턴 , ‘객체들이 어떻게 상호작용하고 어떻게 책임을 가져가는가?’와 관련된 행동 패턴이 있습니다. 먼저 객체를 어떻게 생성하느냐와 관련된 ‘생성 패턴’부터 살펴보겠습니다. 생성 패턴(Creational Pattern) 생성패턴은 인스턴스를 만드는 절차를 추상화하는 패턴입니다. 시스템으로부터 객체의 생성/합성 방법을 분리해내기 위함입니다.생성패턴은 시스템이 어떤 구체 클래스를 사용하는지, 또한 인스턴스들이 어떻게 만들어지고 어떻게 합성되는지에 대한 정보를 완전히 가려줍니다.&#39;무엇이 생성되나요?&#39; → 알 수 없음&#39;어떻게 생성되나요?&#39; → 알 수 없음&#39;언제 생성되나요?&#39; → 알 수 없음&#39;누가 이걸 생성하나요?&#39; → 알 수 없음 생성 패턴의 종류는 다음과 같습니다. 종류 싱글턴 패턴 (Singleton Pattern) 프로토타입 패턴 (Prototype Pattern) 팩토리 메소드 패턴 (Factory Method Pattern) 빌더 패턴 (Builder Pattern) 추상 팩토리 패턴 (Abstract Factory Pattern) 싱글턴 패턴 (Singleton Pattern)구조 의도 오직 한 개의 인스턴스만을 갖도록 하며, 이에 대한 전역적인 접근을 허용합니다. 일반적으로는 특정 클래스의 인스턴스가 반드시 하나여야 하나 여러 곳에서 사용하는 경우에 싱글턴 패턴을 사용합니다.또한, 생성된 인스턴스를 여러 곳에서 공유하여 사용해도 무리가 없다면 메모리 낭비를 방지하기 위해 싱글턴 패턴을 적용하기도 합니다. 예제로 보겠습니다. 예제카페의 와이파이를 사용하여 네트워크에 연결한다고 경우를 생각해봅시다. 카페에서는 와이파이가 필요한 사용자마다 와이파이를 새로 만들어주지는 않습니다.ID와 패스워드를 알려주어 기존에 있던 네트워크를 공유해서 사용하도록 하죠.위 상황을 생각하면서 와이파이 클래스를 만들어보도록 합시다. 고객으로부터 와이파이 정보 요청이 오면,ㄴ 있으면 있는 와이파이 정보 주고ㄴ 없으면 생성하여 준다. 와이파이 클래스 12345678910111213public class Wifi &#123; private static Wifi wifi; private Wifi() &#123; &#125; public static Wifi requestWifi() &#123; if (wifi == null) &#123; wifi = new Wifi(); &#125; return wifi; &#125;&#125; 실행과 결과 123456Wifi wifi1 = Wifi.requestWifi(); // 와이파이 요청 1Wifi wifi2 = Wifi.requestWifi(); // 와이파이 요청 2Wifi wifi3 = Wifi.requestWifi(); // 와이파이 요청 3System.out.println(wifi1);System.out.println(wifi2);System.out.println(wifi3); creational_pattern.singleton.Wifi@13b6d03creational_pattern.singleton.Wifi@13b6d03creational_pattern.singleton.Wifi@13b6d03 3번의 와이파이 요청 결과 모두 같은 와이파이 정보임을 알 수 있습니다. 100번을 해도 요청한 정보가 모두 같을 것입니다. 이처럼 싱글턴 패턴 을 사용하면 단 하나의 인스턴스만 생성됩니다.싱글턴 패턴 을 사용하면 고정된 메모리 영역을 받기 때문에 단 하나의 객체만 생성되어 메모리가 낭비를 방지할 수 있습니다.하지만 위와 같은 ‘java’의 싱글턴 패턴 방식에는 큰 문제점들이 존재합니다. (java라고 강조한 이유는 타 언어에서는 싱글턴 방식을 위의 방식으로 구현하지 않을 수도 있기 때문입니다.) 문제점 상속할 수 없다.위 방식에서는 객체가 어디서든지 원하는 대로 생성되는 걸 방지하기 위해 생성자를 private으로 선언합니다. 바로 이것이 문제가 되는 핵심입니다.java에서는 생성자를 private으로 선언하면 상속을 할 수 없습니다. 이는 곧 객체지향 프로그램의 핵심인 상속과 다형성을 해치는 개념입니다. 강제로 전역 상태애초에 공유의 목적으로 생성된 클래스이기 때문에 객체를 요청하는 메소드를 public으로 강제할 수밖에 없습니다. 바로 이것이 두 번째 문제의 원인입니다.특정 메소드가 정보의 은닉 범위, 공개 수준 등등에 전혀 상관없이 public으로 선언할 것을 강제했기 때문에 객체지향 프로그램의 또 다른 핵심인 ‘정보 은닉‘을 해칩니다. 객체가 하나인 것을 보장할 수 없다.사실 싱글턴 패턴 의 핵심은 싱글턴인 것을 보장할 수 있어야 한다는 것입니다.하지만 java의 고전적 싱글턴 패턴 은 객체가 하나인 것을 보장할 수 없습니다.멀티쓰레드를 예로 들겠습니다. 해당 인스턴스는 공유돼서 사용되기 때문에 여러 개의 쓰레드가 동시에 접근하여 메소드를 호출할 수 있습니다.문제는 2개 이상의 쓰레드가 동시에 객체 생성을 하게 되면 2개 이상의 객체가 생성된다는 것입니다. 즉, 싱글턴으로 사용하기 위해 싱글턴 패턴 을 적용했으나, 싱글턴이 아닌 게 되는 것입니다. 결론싱글턴 패턴 은 굉장히 많이 활용되는 패턴이나, 앞서 말한 객체지향 프로그래밍의 기본 사상들을 많이 침해하기 때문에 굉장히 비판을 많이 받는 디자인 패턴입니다.따라서 싱글턴 패턴 은 사용 시 매우 조심해서 사용해야 합니다. 그것이 아니라면 위의 고전적인 싱글턴 패턴 이 아닌 개선된 방식으로 객체의 싱글턴 방식을 구현하여 사용해야 합니다. 프로토타입 패턴 (Prototype Pattern)별명 견본 또는 원형 구조 의도 프로토타입이 될 인스턴스를 생성하여 앞으로 생성할 객체의 종류를 명시하고, 그 인스턴스로부터 새로운 인스턴스를 복제합니다 인스턴스들이 서로 다른 상태 값 또는 서로 다른 조합으로 지속적으로나 주기적으로 필요할 때, 나중의 인스턴스 생성을 위해 복제의 견본이 되어줄 원형 인스턴스를 준비해둡니다.그 후, 새로운 인스턴스의 생성 요청이 오거나 필요할 때마다 미리 만들어둔 견본을 복제하여 사용합니다. 예제를 통해 자세히 보도록 하겠습니다. 예제게임을 예로 들어보겠습니다.우리는 어떤 게임을 만들고자 합니다. 우리는 특정 위치에서 지속적으로 몬스터들을 출현시킬 것입니다.이 몬스터들은 각자 정해진 체력이 있고, 이 체력이 모두 다하면 죽습니다. 또한, 구역 별로 초기 체력의 양이 다릅니다.이 몬스터들을 어떻게 구현해야 할까요? 물론 위치 정보와 체력 정보를 저장해놓고, 시간이 되면 저장해놓은 위치 정보와 체력정보를 보고 그때그때 몬스터들을 새로 생성해도 됩니다.하지만 우리는 프로토타입 패턴 을 적용하여 구현해볼 수 있습니다.몬스터들의 유형별로 견본을 준비해놓고, 필요할 때마다 그 견본으로부터 복제해가며 사용하는 것입니다. java에서는 객체의 복제를 위해 Object 클래스에 이미 clone이라는 메소드가 존재합니다.Cloneable 인터페이스를 상속받고 clone이라는 메소드를 오버라이딩하면 인스턴스의 복제가 가능합니다. 적용 위치정보 클래스 : Location 1234567891011121314151617181920public class Location implements Cloneable &#123; private int x; private int y; public Location(int x, int y) &#123; this.x = x; this.y = y; &#125; // getters public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; // 위치정보 복제 @Override public Location clone() throws CloneNotSupportedException &#123; return (Location) super.clone(); &#125;&#125; 몬스터 클래스 : Monster 1234567891011121314151617181920212223public class Monster implements Cloneable &#123; private Location location; private int health; public Monster(Location location, int health) &#123; this.location = location; this.health = health; &#125; // getters public Location getLocation() &#123; return location; &#125; public int getHealth() &#123; return health; &#125; // 몬스터 복제 @Override public Monster clone() throws CloneNotSupportedException &#123; Monster clonedMonster = (Monster) super.clone(); clonedMonster.location = location.clone(); return clonedMonster; &#125;&#125; 실행과 결과 123456789101112131415Monster monsterA = new Monster(new Location(5, 5), 100); // 프로토타입 AMonster monsterB = new Monster(new Location(0, 0), 10); // 프로토타입 BMonster monsterC = new Monster(new Location(-3, 3), 50); // 프로토타입 Cwhile (true) &#123; System.out.println(&quot;몬스터들 출현!&quot;); Monster cloneA = monsterA.clone(); // 프로토타입 A 복제 Monster cloneB = monsterB.clone(); // 프로토타입 B 복제 Monster cloneC = monsterC.clone(); // 프로토타입 C 복제 // 출력과 10초 기다림 System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneA.getHealth(), cloneA.getLocation().getX(), cloneA.getLocation().getY())); System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneB.getHealth(), cloneB.getLocation().getX(), cloneB.getLocation().getY())); System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneC.getHealth(), cloneC.getLocation().getX(), cloneC.getLocation().getY())); System.out.println(&quot;------------------------------------------------&quot;); Thread.sleep(10000);&#125; 몬스터들 출현! 몬스터 생성 [ 체력 : 100, 위치 : (5, 5) ] 몬스터 생성 [ 체력 : 10, 위치 : (0, 0) ] 몬스터 생성 [ 체력 : 50, 위치 : (-3, 3) ] ------------------------------------------------ 몬스터들 출현! 몬스터 생성 [ 체력 : 100, 위치 : (5, 5) ] 몬스터 생성 [ 체력 : 10, 위치 : (0, 0) ] 몬스터 생성 [ 체력 : 50, 위치 : (-3, 3) ] ------------------------------------------------ 몬스터들 출현! 몬스터 생성 [ 체력 : 100, 위치 : (5, 5) ] 몬스터 생성 [ 체력 : 10, 위치 : (0, 0) ] 몬스터 생성 [ 체력 : 50, 위치 : (-3, 3) ] ------------------------------------------------ 진짜 프로토타입으로 몬스터가 생성된 것인지, 그냥 기존에 만들어두었던 프로토타입을 보여주는 것인지 알 길이 없으니 hashCode를 찍도록 코드를 수정하여 다시 출력해봅시다. 실행과 결과 123456789101112131415Monster monsterA = new Monster(new Location(5, 5), 100); // 프로토타입 AMonster monsterB = new Monster(new Location(0, 0), 10); // 프로토타입 BMonster monsterC = new Monster(new Location(-3, 3), 50); // 프로토타입 Cwhile (true) &#123; System.out.println(&quot;몬스터들 출현!&quot;); Monster cloneA = monsterA.clone(); // 프로토타입 A 복제 Monster cloneB = monsterB.clone(); // 프로토타입 B 복제 Monster cloneC = monsterC.clone(); // 프로토타입 C 복제 // 출력과 10초 기다림 System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneA.getHealth(), cloneA.getLocation().getX(), cloneA.getLocation().getY())); System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneB.getHealth(), cloneB.getLocation().getX(), cloneB.getLocation().getY())); System.out.println(String.format(&quot;몬스터 생성 [\\t체력 : %d,\\t위치 : (%d, %d)\\t]&quot;, cloneC.getHealth(), cloneC.getLocation().getX(), cloneC.getLocation().getY())); System.out.println(&quot;------------------------------------------------&quot;); Thread.sleep(10000);&#125; 몬스터들 출현! Monster@f5f2bb7 Monster@73035e27 Monster@64c64813 ------------------------------------------------ 몬스터들 출현! Monster@3ecf72fd Monster@483bf400 Monster@21a06946 ------------------------------------------------ 몬스터들 출현! Monster@77f03bb1 Monster@326de728 Monster@25618e91 ------------------------------------------------ 해쉬코드를 통해 초기에 만들어두었던 프로토타입을 기반으로 새로운 몬스터가 생성되는 것임을 확인할 수 있습니다. 여러분들은 제가 작성한 Monster 클래스의 clone 메소드에 의문을 품을 수도 있습니다. 123Monster clonedMonster = (Monster) super.clone();clonedMonster.location = location.clone();return clonedMonster; 집중할 포인트는 바로 두 번째 줄입니다. ‘몬스터를 복제하고 난 후, 복제된 몬스터의 위치정보를 왜 굳이 또 복제하여 복제된 몬스터에 세팅하나요?’ 이것이 바로 clone 메소드를 사용할 경우, 유의해야 할 사항입니다. 주의사항프로토타입 자체를 ‘깊은 복사‘하지만 프로토타입 내의 또 다른 객체가 있을 때, 그 객체들은 얕은 복사가 수행됩니다.프로토타입에 단순한 기본 자료형만 있을 때, 프로토타입을 복제하였을 때 만들어진 인스턴스들끼리 공유하는 정보가 없습니다.하지만 프로토타입 내부에 참조형 자료형이 있을 때, 프로토타입을 복제하였을 때 그 인스턴스들끼리 내부에 있는 참조형 자료형들을 서로 공유합니다.내부에 있는 참조형 자료형들까지 깊은 복사가 되지 않기 때문입니다.만약, 소프트웨어의 기능 특성상, 내부에 있는 참조형 자료형들까지 깊은 복사가 필요하다면 위의 코드처럼 깊은 복사를 다루는 코드가 필요합니다. 정리이처럼 프로토타입 패턴 은 특정 객체가 지속적으로나 주기적으로 새로이 필요할 때 견본을 만들어놓고 이를 복제하는 형식으로 객체를 제공하기 위해 존재하는 패턴입니다.복제를 위해 견본이 반드시 필요하여 뒤에 나올 다른 생성 패턴처럼 서브클래싱은 필요하진 않아도 초기화 동작은 반드시 필요한 패턴입니다.clone과 같이 복사를 수행할 메소드를 반드시 구현해줘야 한다는 단점도 존재하지만 매번 필요한 상태 조합을 수동적으로 초기화하지 않는다는 점에서 장점도 존재합니다. 팩토리 메소드 패턴 (Factory Method Pattern)별명 가상 생성자 구조 의도 객체를 생성하기 위해 인터페이스를 정의하지만 어떤 클래스의 인스턴스를 생성할지는 서브 클래스가 결정합니다. 로직을 구현할 때에 특정 부분에서 어떤 인터페이스(또는 추상 클래스)를 구현한 클래스의 인스턴스 필요하다는 것은 정의되었으나,구체적으로 어떤 클래스의 인스턴스가 쓰일지 예측이 불가할 때가 있습니다. 예제를 통해 자세히 보도록 하겠습니다. 예제우리는 놀이동산을 만들고 일정 시간이 지나면 놀이동산을 폐쇄하는 프로그램을 만들 것입니다.그런데 그 놀이동산은 비스킷으로 만들어질 수도, 젤리로 만들어질 수도 있습니다. [FMP-1.1] 놀이동산 클래스 : AmusementPark JellyAmusementPark BiscuitAmusementPark 12345678public class AmusementPark &#123; public void open() &#123; System.out.println(toString() + &quot;이(가) 생겼습니다.&quot;); &#125; public void close() &#123; System.out.println(toString() + &quot;이(가) 폐쇄되었습니다.&quot;); &#125;&#125; 123456public class JellyAmusementPark extends AmusementPark &#123; @Override public String toString() &#123; return &quot;젤리로 된 놀이동산&quot;; &#125;&#125; 123456public class BiscuitAmusementPark extends AmusementPark &#123; @Override public String toString() &#123; return &quot;비스킷으로 된 놀이동산&quot;; &#125;&#125; [FMP-1.2] 놀이동산 운영 클래스 : AmusementParkOperator 123456789public class AmusementParkOperator &#123; // 놀이동산을 만들고 5초가 지나면 폐쇄한다. public void operate() throws InterruptedException &#123; AmusementPark amusementPark = new JellyAmusementPark(); amusementPark.open(); Thread.sleep(5000); amusementPark.close(); &#125;&#125; 실행과 결과 12AmusementParkOperator operator = new AmusementParkOperator();operator.operate(); 젤리로 된 놀이동산이(가) 생겼습니다.젤리로 된 놀이동산이(가) 폐쇄되었습니다. 우리는 지금 방금 젤리로 된 놀이동산을 운영시켰습니다.자 그렇다면 이제 비스킷으로 된 놀이동산을 운영시켜봅시다. 그러기 위해서 우리는 위의 AmusementParkOperator의 new JellyAmusementPark() 부분을 new BiscuitAmusementPark()로 바꿔줘야 합니다.이래서는 재료가 바뀔 때마다 AmusementParkOperator 코드를 바꿔주어야 할지도 모르겠습니다. 적용우리는 이제 팩토리 메소드 패턴 을 적용하여 놀이동산을 생성하는 부분을 아예 별도의 메소드로 분리하고 난 후 상속을 통해 그때그때 서브클래스가 자신이 운영할 놀이동산의 종류를 결정하도록 바꿔줄 것입니다. [FMP-2.1] 놀이동산 운영 클래스 : AmusementParkOperator 123456789public abstract class AmusementParkOperator &#123; public void operate() throws InterruptedException &#123; AmusementPark amusementPark = makeAmusementPark(); amusementPark.open(); Thread.sleep(5000); amusementPark.close(); &#125; public abstract AmusementPark makeAmusementPark();&#125; 123456public class BiscuitAmusementParkOperator extends AmusementParkOperator &#123; @Override public AmusementPark makeAmusementPark() &#123; return new BiscuitAmusementPark(); &#125;&#125; 123456public class JellyAmusementParkOperator extends AmusementParkOperator &#123; @Override public AmusementPark makeAmusementPark() &#123; return new JellyAmusementPark(); &#125;&#125; 실행과 결과 12AmusementParkOperator operator = new JellyAmusementParkOperator();operator.operate(); 젤리로 된 놀이동산이(가) 생겼습니다.젤리로 된 놀이동산이(가) 폐쇄되었습니다. 12AmusementParkOperator operator = new BiscuitAmusementParkOperator();operator.operate(); 비스킷으로 된 놀이동산이(가) 생겼습니다.비스킷으로 된 놀이동산이(가) 폐쇄되었습니다. 자, 이제 우리는 재료가 바뀔 때마다 AmusementParkOperator 코드를 변경해주지 않아도 됩니다.실행부에서 선택하는 AmusementParkOperator 종류에 따라 코드의 변경 없이도 놀이동산의 재료를 바꿔줄 수 있게 되었습니다.혹시라도 사탕으로 된 놀이동산이 필요하다 하더라도 AmusementParkOperator를 변경할 필요 없이 상속하여 구현해주면 되는 것입니다. 이처럼 팩토리 메소드 패턴 은 구체 클래스들이 병렬구조를 이루어 그때그때 교체하여 사용하면 되기 때문에 프로그램에 유연성을 제공해줍니다.소프트웨어가 우리들의 코드에 종속되지 않도록 해주는 것입니다. 팩토리 메소드 패턴 의 기본 개념의 이게 끝입니다. 하지만 여러분들은 아마 마음에 들지 않는 부분이 있을수도 있을 겁니다. 개선‘아니, 그럼 놀이동산 객체가 필요할 때마다 저 AmusementParkOperator 클래스를 상속해줘야 한다는 거야?’그렇습니다. 현 구조에서는 그럴 수밖에 없습니다.놀이동산 객체가 필요할 때마다 운영하는 기능을 가진 저 AmusementParkOperator를 서브클래싱해줘야 한다는 것이죠. 왜일까요? 책임의 분리AmusementParkOperator의 핵심 기능은 무엇일까요? 바로 ‘놀이동산을 어떻게 운영시킬 것이다’입니다.물론 operate 메소드가 있으나(예제에는 operate밖에 없지만 사실 더 많은 기능이 들어갈 수 있을 겁니다.) 한 가지 책임이 더 있습니다. 그것은 바로 ‘어떤 놀이동산을 만들어낸다’입니다.‘어떤 놀이동산을 운영한다’와 ‘놀이동산을 어떻게 운영한다’의 책임이 한 클래스 안에 존재하면 각자의 책임에 서로 다른 변경사항이 생기더라도 영향을 주고 받을 수밖에 없습니다.이 문제를 해결하기 위해 우리는 책임을 분리해주는 것이 좋을 것 같습니다. 현재 AmusementParkOperator : 어떤 놀이동산을 만들고, 그 놀이동산을 어떻게 운영한다 To be AmusementParkFactory : 어떤 놀이동산을 만들고, AmusementParkOperator : 받은 놀이동산을 어떻게 운영한다. [FMP-3.1] 놀이동산 공장 : AmusementParkFactory 123public interface AmusementParkFactory &#123; AmusementPark makeAmusementPark();&#125; 123456public class BiscuitAmusementParkFactory implements AmusementParkFactory &#123; @Override public AmusementPark makeAmusementPark() &#123; return new BiscuitAmusementPark(); &#125;&#125; 123456public class JellyAmusementParkFactory implements AmusementParkFactory &#123; @Override public AmusementPark makeAmusementPark() &#123; return new JellyAmusementPark(); &#125;&#125; [FMP-3.2] 놀이동산 운영 클래스 : AmusementParkOperator 12345678910111213public class AmusementParkOperator &#123; private AmusementPark amusementPark; public AmusementParkOperator(AmusementPark amusementPark) &#123; this.amusementPark = amusementPark; &#125; public void operate() throws InterruptedException &#123; amusementPark.open(); Thread.sleep(5000); amusementPark.close(); &#125;&#125; 실행과 결과 123AmusementPark amusementPark = new JellyAmusementParkFactory().makeAmusementPark();AmusementParkOperator operator = new AmusementParkOperator(amusementPark);operator.operate(); 젤리로 된 놀이동산이(가) 생겼습니다.젤리로 된 놀이동산이(가) 폐쇄되었습니다. 123AmusementPark amusementPark = new BiscuitAmusementParkFactory().makeAmusementPark();AmusementParkOperator operator = new AmusementParkOperator(amusementPark);operator.operate(); 비스킷으로 된 놀이동산이(가) 생겼습니다.비스킷으로 된 놀이동산이(가) 폐쇄되었습니다. 이렇게 놀이동산을 만드는 전용 공장이 생기니 새로운 종류의 놀이동산이 생기더라도 놀이동산을 운영하는 클래스가 변경되지는 않을 것입니다.또한 놀이동산의 운영방법이 바뀌더라도 놀이동산을 만들어내는 클래스가 변경되지는 않을 것입니다. 다른 방식눈치가 빠르시다면 눈치채셨을 수도 있습니다. ‘넌 #적용 파트에서 다른 방식을 취할 수도 있었는데 얼렁뚱땅 패턴을 적용했어’ 과연 어떤 다른 방식이 있었을까요? 바로 ‘매개변수로 분기처리‘ 방법입니다. [FMP-4.1] 놀이동산 종류 : AmusementParkType 1234public enum AmusementParkType &#123; JELLY, BISCUIT;&#125; [FMP-4.2] 놀이동산 운영 클래스 : AmusementParkOperator 1234567891011121314151617181920public class AmusementParkOperator &#123; public void operate(AmusementParkType type) throws InterruptedException &#123; AmusementPark amusementPark = makeAmusementPark(type); amusementPark.open(); Thread.sleep(5000); amusementPark.close(); &#125; private AmusementPark makeAmusementPark(AmusementParkType type) &#123; switch (type) &#123; case JELLY: return new JellyAmusementPark(); case BISCUIT: return new BiscuitAmusementPark(); &#125; return null; &#125;&#125; 실행과 결과 12AmusementParkOperator operator = new AmusementParkOperator();operator.operate(AmusementParkType.JELLY); 젤리로 된 놀이동산이(가) 생겼습니다.젤리로 된 놀이동산이(가) 폐쇄되었습니다. 12AmusementParkOperator operator = new AmusementParkOperator();operator.operate(AmusementParkType.BISCUIT); 비스킷으로 된 놀이동산이(가) 생겼습니다.비스킷으로 된 놀이동산이(가) 폐쇄되었습니다. 이 방식으로도 여전히 책임에 대한 문제점이 보이니 개선하도록 하겠습니다. [FMP-5.1] 놀이동산 공장 : AmusementParkFactory 1234567891011public class AmusementParkFactory &#123; AmusementPark makeAmusementPark(AmusementParkType type) &#123; switch (type) &#123; case JELLY: return new JellyAmusementPark(); case BISCUIT: return new BiscuitAmusementPark(); &#125; return null; &#125;&#125; [FMP-5.2] 놀이동산 운영 클래스 : AmusementParkOperator[FMP-3.2] 동일 실행과 결과 123AmusementPark amusementPark = new AmusementParkFactory().makeAmusementPark(AmusementParkType.JELLY);AmusementParkOperator operator = new AmusementParkOperator(amusementPark);operator.operate(); 젤리로 된 놀이동산이(가) 생겼습니다.젤리로 된 놀이동산이(가) 폐쇄되었습니다. 123AmusementPark amusementPark = new AmusementParkFactory().makeAmusementPark(AmusementParkType.BISCUIT);AmusementParkOperator operator = new AmusementParkOperator(amusementPark);operator.operate(); 비스킷으로 된 놀이동산이(가) 생겼습니다.비스킷으로 된 놀이동산이(가) 폐쇄되었습니다. 이처럼 매개변수를 넘겨 분기에 따라 처리해주는 방식도 존재합니다.하지만 이 방법은 새로운 유형의 데이터가 추가될 때마다 기존 메소드를 계속 변경시켜줘야 한다는 단점이 있습니다.또한 구체 클래스가 명시되어 있어서 유연성을 제공해주기 힘들다는 단점도 존재합니다.하지만 위 방법과 비교하면 비교적 구조가 간단하다는 장점이 있습니다. 각 방법의 장단점을 파악하고 그때그때 프로젝트나 소프트웨어의 환경에 맞춰 적합한 방법을 선택하는 것이 바람직한 방법일 것입니다. 정리객체를 생성하는 클래스 또는 인터페이스가 있지만, 정확히 어떤 구체 클래스의 인스턴스가 생성되는지 모를 때(또는 유연성을 제공하고 싶을 때) 서브클래스에게 결정권을 넘겨준다. 빌더 패턴 (Builder Pattern)빌더 패턴 을 정의하고 있는 2가지 방식이 있습니다.한 가지는 서적 ‘gof의 디자인 패턴’에 나오는 빌더 패턴 과 ‘이펙티브 자바’에 나오는 아이템 2번입니다.빌더 패턴 의 전통적인 의미와 구조는 ‘gof의 디자인 패턴’에 나오는 빌더 패턴 이나,지금의 빌더 패턴 은 ‘이펙티브 자바’에 나오는 의미와 구조가 더 많이 알려져 있으며 그만큼 더 많이 사용되는 듯 보입니다. 우리는 이 두 가지 방식 모두 살펴볼 것입니다. 먼저 ‘gof의 디자인 패턴’에 나오는 빌더 패턴 먼저 보도록 하겠습니다. 1. gof의 빌더 패턴구조 의도 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여,서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공한다. 여러 객체들이 조립되어 생성되는 복잡한 객체의 경우, ‘내부 객체들을 어떻게 생성하는가’와 ‘내부 객체들을 어떻게 조립하는가’를 분리시킵니다.조립될 각 객체들의 구체적인 클래스나 객체들의 조립 방법이 서로 다르더라도 내부 객체들이 어떻게 생성되는지 제공해줘야 하고,생성된 각 객체들로 최종적인 객체가 만들어지는 과정에 동일한 절차를 제공해야 하는 경우 빌더 패턴 을 사용합니다. 예제를 통해 파악하도록 하겠습니다. 예제우리는 어떤 방을 생성하려고 합니다. 원룸인 집을 생각하셔도 좋습니다.방은 바닥과 벽, 문, 창문으로 이루어지는데 그 조립의 방법이 각기 다를 수 있습니다.바닥을 짓고 사방에 벽을 세우고 동쪽에 문을 서쪽에 창문을 달 수도 있고, 바닥을 짓고 사방에 벽을 세우고 남쪽에 문을, 남쪽을 제외한 모든 곳에 창문을 달 수도 있습니다.허나, 어떤 조립 방법이든, ‘방’은 바닥, 벽, 문, 창문의 객체들이 생성되고 난 후 최종적으로 생성됩니다. 방향 유형 : Direction 1234567public enum Direction &#123; NORTH(&quot;남&quot;), SOUTH(&quot;북&quot;), EAST(&quot;동&quot;), WEST(&quot;서&quot;); private String value; Direction(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; 바닥/문/벽/창문 클래스 : Floor Door Wall Window 1234public class Floor &#123; @Override public String toString() &#123; return &quot;바닥&quot;; &#125;&#125; 1234public class Door &#123; @Override public String toString() &#123; return &quot;문&quot;; &#125;&#125; 1234public class Wall &#123; @Override public String toString() &#123; return &quot;벽&quot;; &#125;&#125; 1234public class Window &#123; @Override public String toString() &#123; return &quot;창문&quot;; &#125;&#125; 방 클래스 : Room 12345678910111213141516171819202122232425262728293031public class Room &#123; private Floor floor; private Map&lt;Direction, Wall&gt; walls; private Map&lt;Direction, Door&gt; doors; private Map&lt;Direction, Window&gt; windows; // 바닥과 벽들, 문들, 창문들로 방을 생성 public Room(Floor floor, Map&lt;Direction, Wall&gt; walls, Map&lt;Direction, Door&gt; doors, Map&lt;Direction, Window&gt; windows) &#123; this.floor = floor; this.walls = walls; this.doors = doors; this.windows = windows; &#125; // 출력을 위함 @Override public String toString() &#123; StringBuffer buffer = new StringBuffer(floor.toString()).append(&quot;\\n&quot;); for(Direction direction : walls.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(walls.get(direction).toString()).append(&quot;\\n&quot;); &#125; for(Direction direction : doors.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(doors.get(direction).toString()).append(&quot;\\n&quot;); &#125; for(Direction direction : windows.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(windows.get(direction).toString()).append(&quot;\\n&quot;); &#125; return buffer.toString(); &#125;&#125; 우리 소프트웨어에서는 두 가지 구조의 방을 만들어낸다고 가정합시다. 유형 A의 구조 : 바닥이 있고, 남쪽을 제외한 모든 방향에 벽이 세워져있고, 북쪽에 창문이 나 있음 유형 B의 구조 : 바닥이 있고, 사방에 벽이 세워져 있고, 남쪽에 문이, 사방에 창문이 나 있음 유형 A와 유형 B를 만드는 클래스를 작성해봅시다. 방 생성 클래스 : RoomCreateor 1234567891011121314151617181920212223242526272829303132333435363738394041public class RoomCreator &#123; public Room createTypeARoom() &#123; // 바닥 생성 Floor floor = new Floor(); // 남쪽을 제외한 모든 방향에 벽 생성 Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); walls.put(Direction.EAST, new Wall()); walls.put(Direction.WEST, new Wall()); walls.put(Direction.SOUTH, new Wall()); // 북쪽에 창문 생성 Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); windows.put(Direction.SOUTH, new Window()); // 방 생성 return new Room(floor, walls, new HashMap&lt;&gt;(), windows); &#125; public Room createTypeBRoom() &#123; // 바닥 생성 Floor floor = new Floor(); // 사방에 벽 생성 Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); walls.put(Direction.EAST, new Wall()); walls.put(Direction.WEST, new Wall()); walls.put(Direction.NORTH, new Wall()); walls.put(Direction.SOUTH, new Wall()); // 남쪽에 문 생성 Map&lt;Direction, Door&gt; doors = new HashMap&lt;&gt;(); doors.put(Direction.NORTH, new Door()); // 사방에 창문 생성 Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); windows.put(Direction.EAST, new Window()); windows.put(Direction.WEST, new Window()); windows.put(Direction.NORTH, new Window()); windows.put(Direction.SOUTH, new Window()); // 방 생성 return new Room(floor, walls, doors, windows); &#125;&#125; 실행과 결과 1234RoomCreator roomCreator = new RoomCreator();Room typeA = roomCreator.createTypeARoom();System.out.println(typeA); 바닥 서쪽의 벽 동쪽의 벽 북쪽의 벽 북쪽의 창문 1234RoomCreator roomCreator = new RoomCreator();Room typeB = roomCreator.createTypeBRoom();System.out.println(typeB); 바닥 남쪽의 벽 서쪽의 벽 동쪽의 벽 북쪽의 벽 남쪽의 문 남쪽의 창문 서쪽의 창문 동쪽의 창문 북쪽의 창문 위의 예제에서는 방이라는 객체를 생성해주는 RoomCreator가 방을 이루는 여러 구성 요소들을 어떻게 합성하는지와 각 구성 요소들이 어떤 타입으로 이루어져 있는지를 모두 알고 있으며그 정보들을 바탕으로 객체들을 생성합니다.그래서 우리는 각 구성요소들의 생성 방법이나 타입이 달라질 때마다 구성요소의 합성 방법이 같을지라도 RoomCreator를 계속 변경해주거나 추가해줘야 합니다.예를 들자면, 구조는 그대로이나 단순한 벽이 아닌 ‘철제로 만든 벽’과 같이 구성요소의 타입을 변화시켰을 때,또는 바닥을 생성하게 되면 사방에 자동으로 벽을 생성되는 방의 유형이 새로 생겼을 때, 우리는 RoomCreator를 변경해주거나 추가해줘야 합니다. 우리는 이제 빌더 패턴 을 적용하여 구성요소를 ‘어떻게 합성할 것인가’과 어떤 구성 요소를 ‘어떻게 만들어낼 것인가’를 분리하여 방이라는 객체를 만들어내는 작업에 유연성을 제공해줄 것입니다. 적용 구성물 빌드 인터페이스 : RoomBuilder 1234567public interface RoomBuilder &#123; void buildFloor(); // 바닥 생성 void buildWall(Direction direction); // 벽 생성 void buildDoor(Direction direction); // 문 생성 void buildWindow(Direction direction); // 창문 생성 Room build(); // 최종적으로 &apos;방&apos; 빌드&#125; 구성물 빌드 클래스 : BasicRoomBuilder 12345678910111213141516171819202122232425262728public class BasicRoomBuilder implements RoomBuilder &#123; private Floor floor; private Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); private Map&lt;Direction, Door&gt; doors = new HashMap&lt;&gt;(); private Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); @Override public void buildFloor() &#123; floor = new Floor(); &#125; @Override public void buildWall(Direction direction) &#123; walls.put(direction, new Wall()); &#125; @Override public void buildDoor(Direction direction) &#123; doors.put(direction, new Door()); &#125; @Override public void buildWindow(Direction direction) &#123; windows.put(direction, new Window()); &#125; @Override public Room build() &#123; return new Room(floor, walls, doors, windows); &#125;&#125; 방 구성 클래스 : RoomDirector 1234567891011121314151617181920212223242526272829303132333435363738394041public class RoomDirector &#123; private RoomBuilder builder; public RoomDirector(RoomBuilder builder) &#123; this.builder = builder; &#125; public Room createTypeARoom() &#123; // 바닥 생성 builder.buildFloor(); // 사방에 벽 생성 builder.buildWall(Direction.EAST); builder.buildWall(Direction.WEST); builder.buildWall(Direction.NORTH); builder.buildWall(Direction.SOUTH); // 남쪽에 문 생성 builder.buildDoor(Direction.NORTH); // 북쪽에 창문 생성 builder.buildWindow(Direction.SOUTH); return builder.build(); &#125; public Room createTypeBRoom() &#123; // 바닥 생성 builder.buildFloor(); // 사방에 벽 생성 builder.buildWall(Direction.EAST); builder.buildWall(Direction.WEST); builder.buildWall(Direction.NORTH); builder.buildWall(Direction.SOUTH); // 남쪽에 문 생성 builder.buildDoor(Direction.NORTH); // 사방에 창문 생성 builder.buildWindow(Direction.EAST); builder.buildWindow(Direction.WEST); builder.buildWindow(Direction.NORTH); builder.buildWindow(Direction.SOUTH); return builder.build(); &#125;&#125; 실행과 결과 1234RoomDirector roomDirector = new RoomDirector(new BasicRoomBuilder());Room typeA = roomDirector.createTypeARoom();System.out.println(typeA); 바닥 서쪽의 벽 동쪽의 벽 북쪽의 벽 북쪽의 창문 1234RoomDirector roomDirector = new RoomDirector(new BasicRoomBuilder());Room typeB = roomDirector.createTypeBRoom();System.out.println(typeB); 바닥 남쪽의 벽 서쪽의 벽 동쪽의 벽 북쪽의 벽 남쪽의 문 남쪽의 창문 서쪽의 창문 동쪽의 창문 북쪽의 창문 우리는 빌더 패턴 을 적용하여 방의 구성 요소들을 어떻게 합성하는지(Director)와 구성 요소들이 어떤 타입으로 생성되는지를(Builder)를 분리하였습니다.이제는 새로운 구성요소 타입이 나오더라도 또는 구성 요소에 구체적인 생성 방법이 생기더라도 우리가 정의한 빌더 인터페이스를 상속하여 새로이 구현하여 사용하면 됩니다.구성 요소를 생성하는 작업들을 추상화시켰고, 직접 방을 구성하는 클래스가 이 추상화된 인터페이스를 사용하는 구조로 바꾸었기 때문에.그러니까 최종 산출물을 내기까지(방이라는 객체를 생성하기까지) 외부로부터 어떤 요소들로 제품이 조합되는지를 모두 가렸기 때문에 가능한 일입니다. 정리GoF의 빌더 패턴 은 ‘객체를 생성하는 방법’과 ‘객체를 합성/조합하는 방법’을 분리해 복잡한 객체를 생성하는 과정에 유연성을 제공한다. 2. 이펙티브 자바의 빌더 패턴이펙티브 자바의 빌더 패턴 은 GoF의 빌더 패턴 의 사용 이유와 그 초점이 서로 다릅니다. 의도 생성자에 매개변수가 많을 때 빌더 패턴을 사용하여 코드를 깨끗이 한다. 생성자에 매개변수가 많고 또 그 매개변수가 모두 필수 정보가 아닐 때, 우리는 생성자를 만드는 데 어려움을 겪습니다.예를 들어 봅시다. 우리 시스템에서 만들 ‘방’이라는 객체는 바닥이 필수로 존재해야 하지만 벽이나 문, 창문은 선택적 사항이라고 해봅시다.바닥은 필수 사항이기 때문에 생성자에 매개변수를 추가해줄 수 있지만, 벽과 문, 창문은 반드시 생성하도록 강제해줄 수 없습니다. 그렇다면 우리는 이런 방법을 생각해볼 수 있습니다 ‘선택 파라미터의 경우의 수대로 생성자를 준비해놓자!’ 12345678910111213141516// 생성자 1 : 바닥Room(Floor floor) &#123;..생략..&#125; // 생성자 2. : 바닥 + 벽Room(Floor floor, Map&lt;Direction, Wall&gt; walls) &#123;..생략..&#125;// 생성자 3. : 바닥 + 문Room(Floor floor, Map&lt;Direction, Door&gt; doors) &#123;..생략..&#125;// 생성자 4. : 바닥 + 창문Room(Floor floor, Map&lt;Direction, Window&gt; windows) &#123;..생략..&#125;// 생성자 5. : 바닥 + 벽 + 문Room(Floor floor, Map&lt;Direction, Wall&gt; walls, Map&lt;Direction, Door&gt; doors) &#123;..생략..&#125;// 생성자 6. : 바닥 + 벽 + 창문Room(Floor floor, Map&lt;Direction, Wall&gt; walls, Map&lt;Direction, Window&gt; windows) &#123;..생략..&#125;// 생성자 7. : 바닥 + 문 + 창문Room(Floor floor, Map&lt;Direction, Door&gt; doors, Map&lt;Direction, Window&gt; windows) &#123;..생략..&#125;// 생성자 8. : 바닥 + 벽 + 문 + 창문Room(Floor floor, Map&lt;Direction, Wall&gt; walls, Map&lt;Direction, Door&gt; doors, Map&lt;Direction, Window&gt; windows) &#123;..생략..&#125; 자, 모든 경우의 수대로 생성자가 준비되었습니다. 허나 이 위에 있는 코드를 다 작성하면 문제가 생길 것입니다. 생성자의 Signature가 같다.생성자 2&#126;4번, 생성자 5&#126;7번은 서로 Signature가 서로 겹칩니다. 따라서 모두 작성할 수 없으며 하나만 남기고 나머지는 다 제거해줘야 합니다. 그렇다면 무엇을 남겨놔야 할까요?가장 많이 쓰일 것 같다고 생각되는 걸 남겨놓는다 해도 이 객체를 사용하는 프로그래머가 혼란을 겪지 않을까요?즉, 생성자의 Signature가 같을 때도 있다면 이처럼 어떤 생성자를 두어야 할지 애매한 상황이 발생합니다. 생성자의 엄청난 경우의 수현재는 3개의 선택 필드가 존재합니다. 하지만 선택 필드의 개수가 점점 늘어나면 생성자의 경우의 수는 감당할 수 없을 정도로 늘어납니다.현재 선택 필드가 3개일 때 이미 생성자의 경우의 수가 8개인데(1번에 해당하지 않는다 하더라도) 선택 필드가 하나씩 늘어날 때마다 그의 배로 늘어나게 될 것입니다.즉, 선택이 가능한 필드의 개수에 따라 생성자를 계속 추가해줄 수는 없습니다. 그렇다면 우리는 다른 방법을 생각해 낼 것입니다. ‘Setter를 이용하자!’ 필수 필드만 생성자로 두고 선택 필드는 Setter를 이용하게 하는 것입니다. 12345678910111213141516171819202122public Room(Floor floor) &#123; this.floor = floor;&#125;public void setWalls(Map&lt;Direction, Wall&gt; walls) &#123; this.walls = walls;&#125;public void setWall(Direction direction, Wall wall) &#123; this.walls.put(direction, wall);&#125;public void setDoors(Map&lt;Direction, Door&gt; doors) &#123; this.doors = doors;&#125;public void setWall(Direction direction, Door door) &#123; this.doors.put(direction, door);&#125;public void setWindows(Map&lt;Direction, Window&gt; windows) &#123; this.windows = windows;&#125;public void setWall(Direction direction, Window window) &#123; this.windows.put(direction, window);&#125; 객체 생성123456Room room = new Room();room.setFloor(new Floor());room.setWall(Direction.EAST, new Wall());room.setWall(Direction.WEST, new Wall());room.setWall(Direction.SOUTH, new Wall());room.setWindow(Direction.SOUTH, new Window()); 하지만 위 코드 역시 필드가 많아지게 되면 문제가 있습니다.그것은 바로, 최종적인 온전한 객체를 만들 때까지 Setter 메소드를 여러 번 호출해야 하며 그 때까지는 일관성이 무너진 상태에 놓인다는것입니다. ‘아.. 생성자에 매개변수가 많아지면 Setter도 대응하기 어렵겠구나’ 하지만 다행히 한가지 방법이 더 있습니다. 바로 빌더 패턴 입니다.우리는 이제 빌더 패턴 을 적용하여 코드의 가독성을 높여주면서 객체 생성에 안전성을 높여줄 것입니다. 적용 방 클래스 : Room 123456789101112131415161718192021222324252627282930public class Room &#123; private Floor floor; private Map&lt;Direction, Wall&gt; walls; private Map&lt;Direction, Door&gt; doors; private Map&lt;Direction, Window&gt; windows; // 빌더로 필드 세팅 public Room(RoomBuilder roomBuilder) &#123; this.floor = roomBuilder.getFloor(); this.walls = roomBuilder.getWalls(); this.doors = roomBuilder.getDoors(); this.windows = roomBuilder.getWindows(); &#125; // 출력을 위함 @Override public String toString() &#123; StringBuffer buffer = new StringBuffer(floor.toString()).append(&quot;\\n&quot;); for (Direction direction : walls.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(walls.get(direction).toString()).append(&quot;\\n&quot;); &#125; for (Direction direction : doors.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(doors.get(direction).toString()).append(&quot;\\n&quot;); &#125; for (Direction direction : windows.keySet()) &#123; buffer.append(direction.getValue()).append(&quot;쪽의 &quot;).append(windows.get(direction).toString()).append(&quot;\\n&quot;); &#125; return buffer.toString(); &#125;&#125; 방 빌더 클래스 : RoomBuilder 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RoomBuilder &#123; private Floor floor; private Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); private Map&lt;Direction, Door&gt; doors = new HashMap&lt;&gt;(); private Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); public RoomBuilder() &#123; this.floor = new Floor(); &#125; public RoomBuilder buildWalls(Direction direction) &#123; this.walls.put(direction, new Wall()); return this; &#125; public RoomBuilder buildDoors(Direction direction) &#123; this.doors.put(direction, new Door()); return this; &#125; public RoomBuilder buildWindows(Direction direction) &#123; this.windows.put(direction, new Window()); return this; &#125; public Floor getFloor() &#123; return floor; &#125; public Map&lt;Direction, Wall&gt; getWalls() &#123; return walls; &#125; public Map&lt;Direction, Door&gt; getDoors() &#123; return doors; &#125; public Map&lt;Direction, Window&gt; getWindows() &#123; return windows; &#125; public Room build() &#123; return new Room(this); &#125;&#125; 실행과 결과 123456Room room = new RoomBuilder() .buildWalls(Direction.EAST) .buildWalls(Direction.WEST) .buildWalls(Direction.SOUTH) .buildWindows(Direction.SOUTH) .build(); 바닥 동쪽의 벽 북쪽의 벽 서쪽의 벽 북쪽의 창문 1234567891011Room room = new RoomBuilder() .buildWalls(Direction.EAST) .buildWalls(Direction.WEST) .buildWalls(Direction.NORTH) .buildWalls(Direction.SOUTH) .buildDoors(Direction.NORTH) .buildWindows(Direction.EAST) .buildWindows(Direction.WEST) .buildWindows(Direction.NORTH) .buildWindows(Direction.SOUTH) .build(); 바닥 동쪽의 벽 북쪽의 벽 서쪽의 벽 남쪽의 벽 동쪽의 창문 북쪽의 창문 서쪽의 창문 남쪽의 창문 빌더 패턴 은 객체를 사용하는 클라이언트가 필요한 객체를 직접 만드는 것이 아니라 빌더에게 객체를 받게 됩니다.클라이언트는 필수 매개변수만으로 빌더 객체를 생성하고, 빌더를 통해 다른 선택 필드들을 쌓아올리고 마지막으로 빌더 객체에게 최종 객체를 받게 됩니다.빌더 패턴 을 통해 클라이언트는 코드를 작성하기 쉬워지며 개발자가 보기에도 가독성이 좋아집니다. 특히 빌더 패턴 은 계층적으로 설계되어있는 클래스에 적절하게 쓰입니다. 추상 클래스에는 추상 빌더를, 구체 클래스에게는 구체 빌더를 정의하여 계층별로 사용하는 것입니다. 정리생성자나 정적 팩터리가 다뤄야 할 매겨변수가 많다면, 빌더 패턴 을 사용하는 게 나을 수도 있습니다. 특히 모든 필드가 필수가 아니고 선택적으로 정보가 존재할 수 있는 필드들이 많으면 더 그렇습니다.빌더 패턴 을 사용하면 빌더를 사용함으로써 클라이언트들의 코드가 훨씬 깔끔해지며 가독성이 좋아집니다. 추상 팩토리 패턴 (Abstract Factory Pattern)구조 별명 키트(Kit) 의도 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다. 추상 팩토리는 객체가 생성/구성되거나 표현이 되는 방식에 전혀 상관없이 시스템을 독립적으로 만들고자 할 때 유용하게 사용합니다.특히 여러 개의 관련된 제품들이 하나의 군을 이루고, 여러 제품군 중에서 하나를 선택하여 사용할 때(시스템에서 설정해야 할 때) 더욱 유용합니다.또한, 이미 구성됐다 하더라도 일부 제품을 다른 것으로 대체하고자 할 때도 유연하게 대처할 수 있습니다. 예제로 그 의미를 파악해보도록 하겠습니다. 예제우리는 아까와 동일하게 바닥과 벽, 문, 창문으로 방을 만들어낼 것입니다. 하지만 우리는 ‘~~로 만든 방’이라는 개념을 도입하여 제품을 라인화시킬 것입니다.방을 단순하게 만드는 것이 아니라 ‘나무로 만든 방’, ‘철제로 만든 방’ 등과 같이 방의 종류를 지어주는 것입니다.그렇다면 방의 구성 요소가 되는 바닥, 벽, 문, 창문 역시 모두 ‘나무로 만든 바닥’, ‘철제로 만든 창문’ 등등으로 바뀌어야 합니다.가장 먼저, 기존에 사용했던 바닥, 벽, 문, 창문 객체를 추상화 시켜보겠습니다. 바닥 : Floor WoodenFloor SteelFloor 1public interface Floor &#123; &#125; 1234public class SteelFloor implements Floor &#123; @Override public String toString() &#123; return &quot;철제로 된 바닥&quot;; &#125;&#125; 1234public class WoodenFloor implements Floor &#123; @Override public String toString() &#123; return &quot;나무로 된 바닥&quot;; &#125;&#125; 벽 : Wall WoodenWall SteelWall 1public interface Wall &#123; &#125; 1234public class SteelWall implements Wall &#123; @Override public String toString() &#123; return &quot;철제로 된 벽&quot;; &#125;&#125; 1234public class WoodenWall implements Wall &#123; @Override public String toString() &#123; return &quot;나무로 된 벽&quot;; &#125;&#125; 문 : Door WoodenDoor SteelDoor 1public interface Door &#123; &#125; 1234public class SteelDoor implements Door &#123; @Override public String toString() &#123; return &quot;철제로 된 문&quot;; &#125;&#125; 1234public class WoodenDoor implements Door &#123; @Override public String toString() &#123; return &quot;나무로 된 문&quot;; &#125;&#125; 창문 : Window WoodenWindow SteelWindow 1public interface Window &#123; &#125; 1234public class SteelWindow implements Window &#123; @Override public String toString() &#123; return &quot;철제로 된 창문&quot;; &#125;&#125; 1234public class WoodenWindow implements Window &#123; @Override public String toString() &#123; return &quot;나무로 된 창문&quot;; &#125;&#125; 자, 그렇다면 이제 ‘~로 만든 방’을 만들어볼까요? 가장 먼저, ‘철제로 만든 방’부터 만들어봅시다.(방의 구조는 다음과 같다고 해봅시다. ‘사방에 벽이 있고, 남쪽에 문, 북쪽에 창문이 있다.’) 방 생성 클래스 : RoomCreator 12345678910111213141516171819202122public class RoomCreator &#123; public Room createRoom() &#123; Floor floor = new SteelFloor(); // 사방에 생성 Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); walls.put(Direction.EAST, new SteelWall()); walls.put(Direction.WEST, new SteelWall()); walls.put(Direction.NORTH, new SteelWall()); walls.put(Direction.SOUTH, new SteelWall()); // 남쪽에 문 생성 Map&lt;Direction, Door&gt; doors = new HashMap&lt;&gt;(); doors.put(Direction.NORTH, new SteelDoor()); // 북졲에 창문 생성 Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); windows.put(Direction.SOUTH, new SteelWindow()); return new Room(floor, walls, doors, windows); &#125;&#125; 실행과 결과 123RoomCreator roomCreator = new RoomCreator();Room room = roomCreator.createRoom();System.out.println(room); 철제로 된 바닥 남쪽의 철제로 된 벽 동쪽의 철제로 된 벽 서쪽의 철제로 된 벽 북쪽의 철제로 된 벽 남쪽의 철제로 된 문 북쪽의 철제로 된 창문 자, 우리는 createRoom 함수에서 모두 다 Steel이 붙어있는 Room, Wall, Door, Window 구체클래스들을 사용했기 때문에 최종적으로 방을 생성했을 때 ‘철제로 된’이 붙어있는 걸 확인할 수 있습니다.그렇다면 ‘나무로 만든 방’을 만들어봅시다. 어떻게 해야 할까요? new Steel~~()를 모두 new Wooden~~()로 바꾼다.사실 굉장히 간단합니다. 말 그대로 Steel이라고 쓰인 부분을 모두 Wooden으로 바꾸는 것입니다.모두 바꿔서 직접 실행을 하게 되면 위의 결과에서 ‘철제로 된’ 부분이 모두 ‘나무로 된’으로 바뀌어 있을 겁니다.하지만 여러분들은 이 때문에 RoomCreator 함수를 수정하였습니다. 음.. 이러다간 요청한 방의 유형이 바뀔 때마다 RoomCreator 함수를 수정해야 할 겁니다.우리는 위에서 이와 비슷한 문제를 경험하였습니다. 바로 팩토리 메소드 패턴 을 하면서 말입니다.위에서 우리는 놀이동산을 운영할 때 젤리 놀이동산에서 비스킷 놀이동산으로 바꿔줄 때 코드가 바뀌는 문제를 경험하여 팩토리 메소드 패턴 을 적용해주었습니다.AmusementParkOperator를 바꿔주지 않기 위해 우리는 인스턴스를 생성하여 반환해주는 ‘팩토리 인터페이스‘를 만들고 서브클래스가 이를 구현하여 정확히 어떤 구체 클래스의 인스턴스를 반환해주는지 결정하였습니다.동일한 문제가 있으니 먼저 팩토리 메소드 패턴 을 사용하여 이를 해결해주는 게 좋겠습니다. 바닥 팩토리 : FloorFactory SteelFloorFactory WoodenFloorFactory 123public interface FloorFactory &#123; Floor makeFloor();&#125; 1234public class SteelFloorFactory implements FloorFactory &#123; @Override public Floor makeFloor() &#123; return new SteelFloor(); &#125;&#125; 1234public class WoodenFloorFactory implements FloorFactory &#123; @Override public Floor makeFloor() &#123; return new WoodenFloor(); &#125;&#125; 벽 팩토리 : WallFactory SteelWallFactory WoodenWallFactory 123public interface WallFactory &#123; Wall makeWall();&#125; 1234public class SteelWallFactory implements WallFactory &#123; @Override public Wall makeWall() &#123; return new SteelWall(); &#125;&#125; 1234public class WoodenWallFactory implements WallFactory &#123; @Override public Wall makeWall() &#123; return new WoodenWall(); &#125;&#125; 문 팩토리 : DoorFactory SteelDoorFactory WoodenDoorFactory 123public interface DoorFactory &#123; Door makeDoor();&#125; 1234public class SteelDoorFactory implements DoorFactory &#123; @Override public Door makeDoor() &#123; return new SteelDoor(); &#125;&#125; 1234public class WoodenDoorFactory implements DoorFactory &#123; @Override public Door makeDoor() &#123; return new WoodenDoor(); &#125;&#125; 창문 팩토리 : WindowFactory SteelWindowFactory WoodenWindowFactory 123public interface WindowFactory &#123; Window makeWindow();&#125; 1234public class SteelWindowFactory implements WindowFactory &#123; @Override public Window makeWindow() &#123; return new SteelWindow(); &#125;&#125; 1234public class WoodenWindowFactory implements WindowFactory &#123; @Override public Window makeWindow() &#123; return new WoodenWindow(); &#125;&#125; 방 생성 클래스 : RoomCreator 1234567891011121314151617181920212223public class RoomCreator &#123; public Room createRoom(FloorFactory floorFactory, WallFactory wallFactory, DoorFactory doorFactory, WindowFactory windowFactory) &#123; // 바닥 생성 Floor floor = floorFactory.makeFloor(); // 사방에 생성 Map&lt;Direction, Wall&gt; walls = new HashMap&lt;&gt;(); walls.put(Direction.EAST, wallFactory.makeWall()); walls.put(Direction.WEST, wallFactory.makeWall()); walls.put(Direction.NORTH, wallFactory.makeWall()); walls.put(Direction.SOUTH, wallFactory.makeWall()); // 남쪽에 문 생성 Map&lt;Direction, Door&gt; doors = new HashMap&lt;&gt;(); doors.put(Direction.NORTH, doorFactory.makeDoor()); // 북졲에 창문 생성 Map&lt;Direction, Window&gt; windows = new HashMap&lt;&gt;(); windows.put(Direction.SOUTH, windowFactory.makeWindow()); return new Room(floor, walls, doors, windows); &#125;&#125; 실행과 결과 123RoomCreator roomCreator = new RoomCreator();Room room = roomCreator.createRoom(new SteelFloorFactory(), new SteelWallFactory(), new SteelDoorFactory(), new SteelWindowFactory());System.out.println(room); 철제로 된 바닥 남쪽의 철제로 된 벽 동쪽의 철제로 된 벽 서쪽의 철제로 된 벽 북쪽의 철제로 된 벽 남쪽의 철제로 된 문 북쪽의 철제로 된 창문 우리는 기존에 배운 팩토리 메소드 패턴 을 적용하여 RoomCreator가 직접 객체들을 생성하지 않도록 수정해주었습니다. 적용함으로써 더 이상 제품이 바뀐다 할지라도 RoomCreator를 바꿀 일은 없어졌습니다.하지만 여전히 해결되지 않는 문제가 있습니다. 그것은 바로 구성요소들끼리 일관성이 없다는 것입니다.물론, 방을 생성하는 걸 요청하는 클라이언트 쪽에서 어떤 팩토리를 쓸지 정해서 넘겨주기 때문에 RoomCreator 클래스를 수정하지 않아도 된다는 게 참 다행입니다.하지만 애초에 어떤 팩토리를 써줄지 넘겨주는 곳에서 서로 다른 팩토리를 넘겨주게 되면 어떻게 될까요?벽 팩토리 매개변수만 혼자서 나무로 만든 팩토리로 바꿔서 넘겼다고 해봅시다. 실행과 결과 123RoomCreator roomCreator = new RoomCreator();Room room = roomCreator.createRoom(new SteelFloorFactory(), new WoodenWallFactory(), new SteelDoorFactory(), new SteelWindowFactory());System.out.println(room); 철제로 된 바닥 남쪽의 나무로 된 벽 동쪽의 나무로 된 벽 서쪽의 나무로 된 벽 북쪽의 나무로 된 벽 남쪽의 철제로 된 문 북쪽의 철제로 된 창문 두 번째 매개변수를 WoodenWallFactory로 바꾸어서 호출했더니 위와 같은 결과가 표시됩니다. 분명히 ‘~~로 된 방’을 만든다고 하지 않았었나요? 제품들끼리 일관성이 전혀 없는데 어떻게 해야 할까요?해답은 바로 추상 팩토리 패턴 에 있습니다 추상 팩토리 패턴 은 제품들의 객체를 생성하는 과정과 책임을 캡슐화하고 추상화시킵니다.객체를 생성하는 부분을 특정 클래스가 감싸고 그 과정들을 추상화하여 인터페이스 형태로 제공합니다.그리하여 실제 방을 생성하는 로직이 담겨있는 RoomCreator는 구체적인 클래스가 아니라 인터페이스를 통해서만 인스턴스를 조작하기 때문에 RoomCreator 는 방의 종류에 대해서 자유로와집니다.적용하여 그 의미를 파악해봅시다. 팩토리 클래스 : RoomFactory SteelRoomFactory WoodenRoomFactory 123456public interface RoomFactory &#123; Floor makeFloor(); Door makeDoor(); Wall makeWall(); Window makeWindow();&#125; 12345678910public class SteelRoomFactory implements RoomFactory &#123; @Override public Floor makeFloor() &#123; return new SteelFloor(); &#125; @Override public Door makeDoor() &#123; return new SteelDoor(); &#125; @Override public Wall makeWall() &#123; return new SteelWall(); &#125; @Override public Window makeWindow() &#123; return new SteelWindow(); &#125;&#125; 12345678910public class WoodenRoomFactory implements RoomFactory &#123; @Override public Floor makeFloor() &#123; return new WoodenFloor(); &#125; @Override public Door makeDoor() &#123; return new WoodenDoor(); &#125; @Override public Wall makeWall() &#123; return new WoodenWall(); &#125; @Override public Window makeWindow() &#123; return new WoodenWindow(); &#125;&#125; 실행과 결과 123RoomCreator roomCreator = new RoomCreator();Room room = roomCreator.createRoom(new SteelRoomFactory());System.out.println(room); 우리는 각각의 제품들을 한 팩토리에서 관리하도록 변경해주었습니다.따라서 SteelRoomFactory를 사용하면 SteelFloor, SteelWall, SteelDoor, SteelWindow가 WoodenRoomFactory를 사용하면 WoodenFloor, WoodenWall, WoodenDoor, WoodenWindow가 생성됩니다.하나의 상품을 만들기 위해 모든 제품들(Floor, Wall, Door, Window)이 모두 일관성을 갖게 된 것입니다. 이처럼, 추상 팩토리 패턴 은 제품 사이의 일관성을 증진시킵니다.하나의 군(또는 집합) 안에 속한 객체들이 서로 함께 동작하도록 되어 있을 때, 그리하여 시스템에서 하나의 군을 선택하도록 되어있을 때,객체들의 일관성을 증진시키기 위하여 주로 추상 팩토리 패턴 을 적용합니다.이는 제품군을 쉽게 대체할 수 있다는 장점이 있습니다.철제로 된 방에서 나무로 된 방으로 바꾸고 싶으면 내부의 여러 객체들을 일일히 수정할 것이 아니라 SteelRoomFactory를 선택했던 것을 WoodenRoomFactory로 바꾸어 주면 되는 것입니다.이처럼 ‘추상 팩토리’가 앞에서 필요했던 모든 것을 다 생성해주기 때문에 제품군이 한번에 변경될 수 있습니다. 물론 장점만 있는 것은 아닙니다. 추상 팩토리 패턴은 패턴 특성 상 서브클래싱을 해줄 수밖에 없기 때문에 새로운 제품이 추가되어 인터페이스에 메소드를 추가해줘야 하는 경우가 생기면 모든 서브클래스가 이를 반영해줘야 합니다.예를 들어, 방 구조에 ‘베란다’라는 개념이 추가되었다면, 인터페이스에 makeVeranda라는 메소드가 추가되어야 하고 이를 구현/상속하고 있는 모든 서브클래스를 찾아 이를 반영 및 수정해주어야 합니다.하지만 추상 팩토리 패턴 은 관련된 객체들이 서로 함께 사용되게 되어있을 때, 그 객체들의 일관성을 쉽게 제공해주기 때문에 자주 사용되는 패턴입니다. 관련된 패턴여러분들은 추상 팩토리 패턴 을 보면서 이런 의문을 가질 수도 있습니다. (사실 제가 가졌던 의문입니다.) ‘아니, 팩토리 메소드 패턴이랑 다를 게 뭐야? 그냥 팩토리 메소드 패턴이 객체를 여러 개의 객체를 담당하면 추상 팩토리 패턴을 쓰게 되는 거야?’ 결론부터 말씀드리면, 여러 디자인 패턴들이 서로 겹치는 부분이 있어서 그렇습니다. 서로 연관될 수밖에 없는 것이죠.사실상 추상 팩토리 패턴과 팩토리 메소드 패턴의 Area는 분명하게 구분되어 있습니다. 팩토리 메소드 패턴 : 부모가 아닌 서브 클래스가 ‘어떤 객체를 생성한다’는 것을 결정한다. 추상 팩토리 패턴 : 여러 객체가 모여 하나의 군을 이룰 때, 그 객체들의 일관성을 제공한다. 하지만 각각의 목적을 구현하는 과정에 있어서 서로 겹칠수도 또는 서로를 사용할 수도 있는 구조가 되기도 하는 것입니다. 위에서는 추상 팩토리 패턴 을 적용하기 위해 팩토리 메소드 패턴 을 사용하지만 추상 팩토리 패턴 은 사실 다른 방식으로도 구현될 수 있습니다.프로토타입 패턴 을 사용해서 추상 팩토리 패턴 을 적용할 수 있는 것입니다.(미리 객체군을 만들어놓고 복제하여 사용한다.) 이처럼 하나의 패턴이 적용되는 과정에 다른 패턴을 사용되기도 하고 심지어는 같은 패턴이라 할 지라도 여러 가지 방식이 존재합니다.패턴의 형태가 한가지로 국한되는 것이 아니란 것입니다.(특히 서로 언어가 다를 때 많이 발생합니다.) 가장 중요한 것은, ‘어떤 상황‘에서 ‘어떤 문제‘가 있을 때 ‘이런 방식으로 해결한다‘입니다. 부모에서 어떤 구체클래스를 사용할 지 모를 때 팩토리 메소드 패턴을 적용한다. 객체군에 일관성을 제공해주고 싶을 때 추상 팩토리 패턴을 사용한다. 등등 정리하며..지금까지 우리는 디자인 패턴의 의미와 생성 패턴의 종류에 관하여 공부해보았습니다.다음에는 구조 패턴의 종류에 대해 알아보겠습니다. References https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html https://gmlwjd9405.github.io/2018/07/06/design-pattern.html https://ko.wikipedia.org/wiki/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4 https://gdtbgl93.tistory.com/19 http://algamza.blogspot.com/2016/04/prototype-pattern.html https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html 서적 : GoF의 디자인 패턴 서적 : 이펙티브 자바","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"React-2부 [상태관리]","slug":"react-hooks-chapter02","date":"2019-12-29T04:29:55.000Z","updated":"2021-11-13T10:48:21.529Z","comments":true,"path":"2019/12/29/react-hooks-chapter02/","link":"","permalink":"http://yoursite.com/2019/12/29/react-hooks-chapter02/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 들어가기 앞서 본글은 React의 hooks문법으로 작성이 되었습니다. 또한 기본적인 리액트 환경셋팅에 관한 내용은 다루지 않습니다. 리액트의 기본적인 환경셋팅에 관한 내용은 아래의 리액트 1부를 참고해 주세요. React 1부 : 개발환경 구축하기 1부에서 리액트는 단방향 데이터 흐름을 갖고 있다고 하였습니다. 부모 컴포넌트가 자식 컴포넌트에게 데이터를 전달하는 것을 의미합니다. 그렇다면 자식 컴포넌트가 부모 컴포넌트에게 데이터를 전달하는 방법은 없을까요? 간략한 예제 본 글에서는 위의 해답을 예제를 갖고 설명을 하도록 하겠습니다. 해당 예제는 깃허브에서 프로젝트를 다운로드 받으실 수 있습니다. 깃허브주소 프로젝트의 파일 구조에서 chapter01_react_setting 프로젝트는 1부 프로젝트이며 chapter02_react_component는 본글의 2부 프로젝트입니다. 해당 프로젝트의 핵심 파일구조는 아래와 같습니다. 123456789chapter02_react_component(본 글의 root 경로) └─src └─ 01. Parameters&amp;Callback └─ 02. Context API └─ 03. Redux └─ 04. Mobx └─ app.css (01,02,03,04에서 공통적으로 사용하는 css) └─ RootContainer.jsx (01,02,03,04의 결과를 묶기위한 jsx 파일) ... 이하 생략 ... 프로젝트를 보시면 아시겠지만 01~04번까지 UI상으로는 동일한 프로젝트입니다. 해당 소스를 실행하면 아래와 같은 예제를 보실 수 있습니다. 위의 그림은 부모 컴포넌트와 왼쪽, 오른쪽 자식 컴포넌트간의 공을 주고 받는 예제입니다. 각 컴포넌트들은 서로에게 공을 넘겨줄 수 있는 버튼을 갖고 있습니다. 해당 예제를 통해 컴포넌트들 간에 상태를 어떤 방식으로 전달할 수 있는지 보도록 하겠습니다. 컴포넌트들의 상태관리 및 전달 리액트에서 상태관리 및 전달을 할 경우 대표적으로 사용되는 방법은 아래와 같이 4가지가 존재합니다. 위의 프로젝트 번호와 매칭되어 생각하시면 되겠습니다. 123401. 단방향 props 전달 및 부모 컴포넌트의 Call Back 함수02. Context API를 활용한 전역상태 관리03. Redux를 활용한 전역상태 관리04. MobX를 활용한 전역상태 관리 01. 단방향 props 전달 및 부모 컴포넌트의 Call Back 함수[폴더명 : “01. Parameters&amp;Callback”] 먼저 파일구조를 보도록 하겠습니다. 123456789chapter02_react_component(본 글의 root 경로) └─ src └─ 01. Parameters&amp;Callback └─ Root.jsx └─ components └─ Parent.jsx (부모) └─ Left_Child.jsx (왼쪽 자식) └─ Right_Child.jsx (오른쪽 자식) ... 이하 생략 ... Root.jsx는 명목상 01번의 전체 결과를 묶기 위한 컴포넌트입니다. 여기서 Parent.jsx가 존재하며 해당 자식 컴포넌트로 Left_Child , Right_Child를 갖고 있습니다. 자세한 코드는 아래와 같습니다. Root.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.12345678910import React from &apos;react&apos;;import Parent from &quot;./components/Parent&quot;;import &apos;../app.css&apos;;export default function Root() &#123; return( &lt;Parent/&gt; // Parent 컴포넌트를 렌더링 합니다. );&#125; Parent.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React , &#123;useState&#125; from &apos;react&apos;;import Left_Child from &quot;./Left_Child&quot;;import Right_Child from &quot;./Right_Child&quot;;// React 관련 모듈과 Left_Child , Right_Child 컴포넌트를 불러옵니다.export default function Parent() &#123; const [owner , setOwner] = useState(&apos;parent&apos;); // useState 함수는 react hooks에서 state를 설정하는 함수입니다. // useState의 파라메터는 초기값을 의미합니다. // const [owner , setOwner] 에서 첫번째 owner는 상태명 , setOwner는 상태변환 함수명입니다. const onClickParentToLeft = () =&gt; &#123; // 공을 부모 컴포넌트가 갖고 있다면 공의 주인을 left 컴포넌트로 변경 if(owner == &apos;parent&apos;) setOwner(&apos;left&apos;); &#125;; const onClickParentToRight = () =&gt; &#123; // 공을 부모 컴포넌트가 갖고 있다면 공의 주인을 right 컴포넌트로 변경 if(owner == &apos;parent&apos;) setOwner(&apos;right&apos;); &#125;; return( &lt;table className=&#123;&apos;parent-table&apos;&#125;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colSpan=&#123;2&#125;&gt; Parent &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: owner == &apos;parent&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // owner 값을 통해 ball 모양인 div의 visibility 속성을 제어합니다. &lt;br/&gt; &lt;button onClick=&#123;onClickParentToLeft&#125; className=&#123;&apos;btn-parent-to-left&apos;&#125;&gt;Pass to Left_Child&lt;/button&gt; // 부모 컴포넌트에서 Left_Child 컴포넌트로 공을 전달하는 버튼입니다. &lt;button onClick=&#123;onClickParentToRight&#125; className=&#123;&apos;btn-parent-to-right&apos;&#125;&gt;Pass to Right_Child&lt;/button&gt; // 부모 컴포넌트에서 Right_Child 자식 컴포넌트로 공을 전달하는 버튼입니다. &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td className=&#123;&apos;left-table&apos;&#125;&gt; &lt;Left_Child owner=&#123;owner&#125; setOwner=&#123;setOwner&#125;/&gt; // Left_Child 컴포넌트에 owner 상태와 상태변화 함수인 setOwner를 넘깁니다. // setOwner 함수를 통해 owner의 값이 변경되면 다시 렌더링이 됩니다. &lt;/td&gt; &lt;td className=&#123;&apos;right-table&apos;&#125;&gt; &lt;Right_Child owner=&#123;owner&#125; setOwner=&#123;setOwner&#125;/&gt; // Left_Child 컴포넌트에 owner 상태와 상태변화 함수인 setOwner를 넘깁니다. // setOwner 함수를 통해 owner의 값이 변경되면 다시 렌더링이 됩니다. &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; );&#125; Left_Child.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718192021222324252627282930313233343536373839import React from &apos;react&apos;;// 리액트 모듈을 불러옵니다.export default function Left_Child(&#123;owner , setOwner&#125;) &#123;// 부모로부터 props를 전달받습니다. props는 부모에게 받는 값을 의미합니다.// 현재 owner와 setOwner를 받았습니다. owner를 통해 현재 공의 주인을 알 수 있으며// 만약 해당 컴포넌트가 공을 갖고 있는 상태에서 다른 컴포넌트에게 공을 줄 경우// Call Back 함수인 setOwner를 호출하여 부모의 owner상태를 변경할 수 있습니다. const onClickChildToParent = () =&gt; &#123; // 공을 왼쪽 자식 컴포넌트가 갖고 있다면 공의 주인을 부모 컴포넌트로 변경 if(owner == &apos;left&apos;) setOwner(&apos;parent&apos;); &#125;; const onClickRightToLeft = () =&gt; &#123; // 공을 왼쪽 자식 컴포넌트가 갖고 있다면 공의 주인을 오른쪽 자식 컴포넌트로 변경 if(owner == &apos;left&apos;) setOwner(&apos;right&apos;); &#125;; return( &lt;div className=&#123;&apos;child&apos;&#125;&gt; &lt;button onClick=&#123;onClickChildToParent&#125; className=&#123;&apos;btn-to-parent&apos;&#125;&gt;Pass to Parent&lt;/button&gt; // 왼쪽 자식 컴포넌트에서 부모 컴포넌트로 공을 전달하는 버튼입니다. // onClick으로 onClickChildToParent를 호출하며 해당 메서드는 부모로 부터 받은 상태변환 함수인 // setOwner 메서드를 내부적으로 호출하고 있습니다. &lt;br/&gt; Left Child &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: owner == &apos;left&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // owner 값을 통해 ball 모양인 div의 visibility 속성을 제어합니다. &lt;button onClick=&#123;onClickRightToLeft&#125; className=&#123;&apos;btn-left-to-right&apos;&#125;&gt;Pass to Right&lt;/button&gt; // 왼쪽 자식 컴포넌트에서 오른쪽 자식 컴포넌트로 공을 전달하는 버튼입니다. // onClick으로 onClickChildToParent를 호출하며 해당 메서드는 부모로 부터 받은 상태변환 함수인 // setOwner 메서드를 내부적으로 호출하고 있습니다. &lt;/div&gt; );&#125; Right_Child.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;export default function Right_Child(&#123;owner , setOwner&#125;) &#123;// Left_Child 컴포넌트 설명과 동일합니다. const onClickChildToParent = () =&gt; &#123; // 공을 오른쪽 자식 컴포넌트가 갖고 있다면 공의 주인을 부모 컴포넌트로 변경 if(owner == &apos;right&apos;) setOwner(&apos;parent&apos;); &#125;; const onClickRightToLeft = () =&gt; &#123; // 공을 오른쪽 자식 컴포넌트가 갖고 있다면 공의 주인을 왼쪽 자식 컴포넌트로 변경 if(owner == &apos;right&apos;) setOwner(&apos;left&apos;); &#125;; return( &lt;div className=&#123;&apos;child&apos;&#125;&gt; &lt;button onClick=&#123;onClickChildToParent&#125; className=&#123;&apos;btn-to-parent&apos;&#125;&gt;Pass to Parent&lt;/button&gt; // 오른쪽 자식 컴포넌트에서 부모 컴포넌트로 공을 전달하는 버튼입니다. // onClick으로 onClickChildToParent를 호출하며 해당 메서드는 부모로 부터 받은 상태변환 함수인 // setOwner 메서드를 내부적으로 호출하고 있습니다. &lt;br/&gt; Left Child &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: owner == &apos;right&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // owner 값을 통해 ball 모양인 div의 visibility 속성을 제어합니다. &lt;button onClick=&#123;onClickRightToLeft&#125; className=&#123;&apos;btn-right-to-left&apos;&#125;&gt;Pass to Left&lt;/button&gt; // 오른쪽 자식 컴포넌트에서 왼쪽 자식 컴포넌트로 공을 전달하는 버튼입니다. // onClick으로 onClickChildToParent를 호출하며 해당 메서드는 부모로 부터 받은 상태변환 함수인 // setOwner 메서드를 내부적으로 호출하고 있습니다. &lt;/div&gt; );&#125; 정리 Parent는 Left_Child , Right_Child 컴포넌트에게 본인의 상태인 owner와 owner 상태를 변경할 수 있는 setOwner를 자식들에게 props를 전달하며 특정 로직에 의해 setOwner를 호출하여 하나의 상태값을 3개의 컴포넌트가 공유하며 본인의 공인지 아닌지의 여부를 판단하여 UI상 사용자에게 공을 이동시키는 표현을 할수 있게 됩니다. 02. Context API를 활용한 전역상태 관리[폴더명 : “02. Context API”] 위의 예제는 컴포넌트들 간의 상태를 전달 및 공유하는 방법에 대해 알아보았습니다. 그러나 위의 방식은 컴포넌트들간에 공유를 위한 Call Back 함수를 props로 전달해야하며 이는 컴포넌트의 부모와 자식 관계가 점차 깊어질 경우 상당히 복잡해지며 코드가 난잡해진다는 단점이 있습니다. 위의 사진을 보면 A ~ G까지 컴포넌트가 존재합니다. 여기서 C와 G가 특정 상태를 공유하는 방법으로 위와 같은 방법으로 한다면 A 컴포넌트에서 state와 관련된 정보를 내려줘야 합니다. 이런 경우 중간에 존재하는 컴포넌트들에게도 코드상 영향을 미치게 되며 관리가 어려워집니다. 만약 전역적으로 컴포넌트들에게 상태를 전달하며 해당 상태를 변경할 수 있다면 중간에 존재하는 컴포넌트들에게 영향이 없을 것입니다. 이러한 전역적인 상태관리 방법으로 Context API가 존재합니다. 먼저 파일구조를 보도록 하겠습니다. 1234567891011chapter02_react_component(본 글의 root 경로) └─ src └─ 02. Context API └─ Root.jsx └─ components └─ Parent.jsx (부모) └─ Left_Child.jsx (왼쪽 자식) └─ Right_Child.jsx (오른쪽 자식) └─ context └─ OwnerContext.jsx (전역상태 컴포넌트) ... 이하 생략 ... 01번 예제와는 다르게 “context”라는 폴더가 추가되었으며 아래에 OwnerContext.jsx 파일이 추가가 되었습니다. OwnerContext 컴포넌트는 Parent, Left_Child, Right_Child 컴포넌트가 전역적으로 사용하는 상태값을 갖고 있습니다. 코드를 통해 알아보겠습니다. Root.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718import React from &apos;react&apos;;import Parent from &quot;./components/Parent&quot;;import OwnerContext from &quot;./components/context/OwnerContext&quot;// OwnerContext 컴포넌트를 import합니다. 해당 컴포넌트에서 전역으로// 사용하는 상태값을 갖고 있습니다.import &apos;../app.css&apos;;export default function Root() &#123; return( &lt;OwnerContext&gt; &lt;Parent/&gt; &lt;/OwnerContext&gt; // 위의 01번 예제와는 다르게 OwnerContext 컴포넌트 태그로 Parent 컴포넌트가 // 감싸져 있습니다. 이는 OwnerContext의 props 중에 children 이라는 프로퍼티로 // Parent 컴포넌트가 전달됩니다. );&#125; OwnerContext.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718192021222324252627282930import React ,&#123; createContext , useState &#125; from &apos;react&apos;;// createContext 를 import 합니다. 이는 전역적으로 사용할 Context를 생성할 수// 있도록 해줍니다.const Context = createContext(&#123; owner : undefined, setOwner : undefined&#125;);// Context라는 변수명으로 Context를 생성하였습니다.export default function OwnerContext(&#123;children&#125;) &#123;// Root.jsx 파일에서 Root 컴포넌트가 OwnerContext 컴포넌트 태그로 감싸져 있었습니다.// 해당 Root 컴포넌트는 children 이라는 필드명으로 값이 전달됩니다. const [owner , setOwner] = useState(&apos;parent&apos;); // useState을 통해 상태값 owner와 변환함수 setOwner를 설정합니다. // 해당 상태정보를 Context 에게 넘기게 됩니다/ return( &lt;Context.Provider value=&#123;&#123;owner : owner , setOwner : setOwner&#125;&#125;&gt; &#123;children&#125; &lt;/Context.Provider&gt; // Context.Provider 는 해당 내부에 있는 컴포넌트들에게 value를 전달합니다. // 이는 Provider 태그로 감싸져 있으며 children 넘어오는 전달 되는 Parent ,Left_Child ,Right_Child // 컴포넌트들에게 전달됩니다. );&#125;;export &#123;Context&#125;;// 해당 export는 다른 컴포넌트에서 Context 값에 접근하기 위해 export를 해줍니다. Parent.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; useContext &#125; from &apos;react&apos;;import Left_Child from &quot;./Left_Child&quot;;import Right_Child from &quot;./Right_Child&quot;;import &#123;Context&#125; from &quot;./context/OwnerContext&quot;// 나머지는 01번 예제와 같습니다. 다만 OwnerContext.jsx에서 마지막에// export를 해준 Context를 불러와 줍니다. 해당 Context는 react의// useContext를 이용하여 사용할 수 있습니다.export default function Parent() &#123; const context = useContext(Context); // react의 useContext를 사용하여 &quot;context&quot;라는 변수명에 Context를 설정합니다. // 이제 Parent 컴포넌트 내에서 &quot;context&quot;라는 변수명으로 Context를에 접근할 수 있습니다. const onClickParentToLeft = () =&gt; &#123; // Provider의 value로 전달한 owner 값을 비교를 합니다. if(context.owner == &apos;parent&apos;) context.setOwner(&apos;left&apos;); // owner를 변경할 경우 같이 넘긴 setOwner 메서드를 활용합니다. // 해당 메서드를 통해 OwnerContext에서 Context.Provider에게 넘겨준 // owner 를 변경할 수 있습니디. &#125;; const onClickParentToRight = () =&gt; &#123; // Provider의 value로 전달한 owner 값을 비교를 합니다. if(context.owner == &apos;parent&apos;) context.setOwner(&apos;right&apos;); // owner를 변경할 경우 같이 넘긴 setOwner 메서드를 활용합니다. // 해당 메서드를 통해 OwnerContext에서 Context.Provider에게 넘겨준 // owner 를 변경할 수 있습니디. &#125;; return( &lt;table className=&#123;&apos;parent-table&apos;&#125;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colSpan=&#123;2&#125;&gt; Parent &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: context.owner == &apos;parent&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // Context API인 context의 owner 값을 비교하여 visibility 속성을 정합니다. &lt;br/&gt; &lt;button onClick=&#123;onClickParentToLeft&#125; className=&#123;&apos;btn-parent-to-left&apos;&#125;&gt;Pass to Left_Child&lt;/button&gt; &lt;button onClick=&#123;onClickParentToRight&#125; className=&#123;&apos;btn-parent-to-right&apos;&#125;&gt;Pass to Right_Child&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td className=&#123;&apos;left-table&apos;&#125;&gt; &lt;Left_Child/&gt; // 위의 01번 예제에서는 props를 전달하였지만 Context API를 활용하면 해당 props 전달 코드를 // 사용하지 않고 전역적으로 상태를 관리할 수 있습니다. 즉, 현재 컴포넌트인 Parent 컴포넌트와 // 동일하게 Context와 react의 useContext를 사용하여 각 컴포넌트에서 해당 Context를 사용할 // 수 있습니다. &lt;/td&gt; &lt;td className=&#123;&apos;right-table&apos;&#125;&gt; &lt;Right_Child/&gt; // 위의 Left_Child 컴포넌트와 내용이 동일합니다. &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; );&#125; Left_Child.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.Right_Child.jsx는 Left_Child.jsx에서 판단로직만 “right”로 변경이 되기에 코드를 생략합니다.123456789101112131415161718192021222324252627282930313233343536import React, &#123; useContext &#125; from &apos;react&apos;;import &#123;Context&#125; from &quot;./context/OwnerContext&quot;// Left_Child 컴포넌트 내에서 Context 를 사용하기 위해// Parent 컴포넌트와 동일하게 useContext와 Context를 import 합니다.export default function Left_Child(&#123;owner = null&#125;) &#123; const context = useContext(Context); // 전역 Context를 활용하기 위해 Parent와 동일하게 설정합니다. const onClickChildToParent = () =&gt; &#123; // Parent 컴포넌트와 동일하게 &quot;context&quot; 변수명으로 Context에 접근하여 // value로 설정된 값들에게 접근합니다. if(context.owner == &apos;left&apos;) context.setOwner(&apos;parent&apos;); &#125;; const onClickRightToRight = () =&gt; &#123; // Parent 컴포넌트와 동일하게 &quot;context&quot; 변수명으로 Context에 접근하여 // value로 설정된 값들에게 접근합니다. if(context.owner == &apos;left&apos;) context.setOwner(&apos;right&apos;); &#125;; return( &lt;div className=&#123;&apos;child&apos;&#125;&gt; &lt;button onClick=&#123;onClickChildToParent&#125; className=&#123;&apos;btn-to-parent&apos;&#125;&gt;Pass to Parent&lt;/button&gt; &lt;br/&gt; Left Child &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: context.owner == &apos;left&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // Context API인 context의 owner 값을 비교하여 visibility 속성을 정합니다. &lt;button onClick=&#123;onClickRightToRight&#125; className=&#123;&apos;btn-left-to-right&apos;&#125;&gt;Pass to Right&lt;/button&gt; &lt;/div&gt; );&#125; 정리 위의 그림을 보시면 모든 컴포넌트들의 부모인 OwnerContext 컴포넌트가 있으며 해당 컴포넌트에서 전역적으로 사용할 상태와 관련된 정보를 설정합니다. 이를 내부적으로 Context API에게 전달하여 다른 컴포넌트들이 전역적으로 사용할 수 있도록 제공을 합니다. 이때 만약 전역적으로 사용할 상태에 대해 변경을 원한다면 Context API에게 제공한 setOwner 메서드를 사용하여 전역상태를 변경시키는 구조입니다. 현재는 컴포넌트가 3~4개 이므로 Context API가 01번 예제 보다 더욱 코드가 복잡해 보이지만 컴포넌트의 수가 늘어나거나 전역적으로 관리해야할 상태가 늘어날 수록 Context API와 같은 전역적으로 상태를 관리해주는 기능들이 빛을 보게 됩니다. 03. Redux를 활용한 전역상태 관리[폴더명 : “03. Redux”] 지금부터 설명할 Redux는 추가적인 모듈을 설치해야합니다. 만약 github에서 소스를 다운로드 받으셨다면 이미 package.json에 들어있습니다. 만약 안되어 있다면 아래의 명령어를 실행해주세요. 1npm install redux react-redux; redux는 react에 종속되어 있는 모듈이 아닙니다. redux는 자바스크립트 애플리케이션 state container 입니다. 때문에 다른 자바스크립트 어플리케이션에서도 사용을 할 수 있습니다. react-redux는 redux와 react UI와의 바인딩을 해주는 모듈입니다. 즉 , redux에서 관라하는 상태값을 변경하면 react 컴포넌트가 다시 Rendering 됩니다. 파일구조로 넘어가기 전에 redux의 기본적인 원리에 대해 알아도록 하겠습니다. 위의 그림의 화살표는 react 상태를 변화시켜 View를 변경하는 redux의 흐름도입니다. 사용자가 View에서 특정 이벤트를 통하면 Action을 생성하여 Reducer로 전달이 됩니다. 해당 Reducer는 전달받은 Action의 type을 판단하며 해당하는 Store의 값이 변경이됩니다. 이렇게 변화한 Store의 값은 다시 View에 값을 변경시키게 됩니다. redux의 특징으로는 단일 Store를 갖고 있습니다. 그러나 Action과 Reducer는 다수가 될 수 있습니다. 또한 양방향이 아닌 단방향으로만 흐름도를 갖고 있습니다. 컴포넌트 입장에서 그림은 위와 같습니다. C 컴포넌트에서 특정 action을 dispatch하며 해당 action을 통해 reducer는 store에 있는 어떤 상태를 어떻게 변경해야 할지 판단하고 상태를 변경하게 됩니다. 이에 store는 값이 변경되면 해당 상태를 subscribe(구독)하고 있는 컴포넌트인 G에게 값의 변화를 주게 됩니다. 이제 파일구조를 보도록 하겠습니다. 123456789101112chapter02_react_component(본 글의 root 경로) └─ src └─ 03. Redux └─ Root.jsx └─ components └─ Parent.jsx (부모) └─ Left_Child.jsx (왼쪽 자식) └─ Right_Child.jsx (오른쪽 자식) └─ reduxModule └─ ballReducer.js (ball 관련된 리듀서) └─ index.js (여러 리듀서를 통합하는 파일) ... 이하 생략 ... 위의 01번 02번 예제와 다르게 파일구조적으로 “reduxModule”라는 폴더가 존재합니다. 해당 폴더 아래에는 액션 , 액션생성 함수 , 리듀서가 존재합니다. 바로 코드를 보도록 하겠습니다. Root.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718192021222324import React from &apos;react&apos;;import Parent from &quot;./components/Parent&quot;;import &#123; createStore &#125; from &quot;redux&quot;;import reduxModule from &apos;./reduxModule&apos;// 파일구조에서 &quot;reduxModule&quot;라는 폴더가 있었습니다.// 해당 폴더로 import를 하면 기본적으로 index 파일을 import 합니다.import &#123;Provider&#125; from &apos;react-redux&apos;;// react-redux의 Provider를 통해 redux의 값이 전달됩니다.import &apos;../app.css&apos;;const store = createStore(reduxModule);// 위에서 설명하였듯이 &quot;reduxModule&quot; 폴더를 import 하였기에 index 파일이// createStore의 파라메터로 전달됩니다. 해당 파일에는 Reducer가 있습니다.// Reducer의 정보를 바탕으로 store를 생성합니다.export default function Root() &#123; return( &lt;Provider store=&#123;store&#125;&gt; // react-redux 모듈에 있는 Provider입니다. // 해당 Provider에 전역으로 사용할 store를 지정합니다. &lt;Parent/&gt; &lt;/Provider&gt; );&#125; index.js코드상에 “//“ 키워드를 사용하여 설명합니다.12345678910111213import &#123; combineReducers &#125; from &apos;redux&apos;;// redux 모듈에 combineReducers를 import 합니다.// 프로젝트 규모가 커지며 많은 리듀서를 제작하게 됩니다.// 이때 combineReducers는 다수의 Reducer는 하나로// 묶어주는 역할을 합니다.import ballReducer from &apos;./BallReducer&apos;;// 리듀서를 import 합니다.export default combineReducers(&#123; ballReducer,&#125;);// 여러개의 Reducer는 등록할 경우에 구분자 &quot;,&quot; 를 통해// 다수의 Reducer를 등록하면 됩니다. ballReducer.js코드상에 “//“ 키워드를 사용하여 설명합니다.12345678910111213141516171819202122232425262728293031323334const CHANGE_OWNER = &apos;BALL/CHAGNE/OWNER&apos;;// 액션 type을 지정합니다. 해당 타입은 리듀서에서 체크를 합니다. export const getActionChangeOwner = (owner) =&gt; (&#123; type: CHANGE_OWNER, owner : owner&#125;);// 액션 생성함수 입니다. type이라는 필드명으로 위에서 정의한 액션 type이 들어갑니다.// 파라메터로 owner를 받아 owner에 설정되고 있습니다. 해당 액션 정보로 리듀서에서// 값을 변경합니다. 해당 생성함수는 컴포넌트들 파일에서 사용하도록 export 해줍니다.const initialState = &#123; owner: &apos;parent&apos;&#125;;// redux의 초기값 설정입니다.export default function ballReducer(state = initialState, action) &#123;// 마지막으로 리듀서이며 해당 리듀서는 default로 export 해줍니다.// 파라메터로 state와 action이 있습니다.// state은 현재 store에 있는 값이 들어오며 action은 위에서 정의한 액션 생성함수에 의해// 만들어진 액션이 넘어옵니다. switch (action.type) &#123; case CHANGE_OWNER: return &#123; ...state, owner: action.owner, &#125;; default: return state; &#125; // switch문으로 action의 type을 체크합니다. 해당 체크에 따라 return 되는 값이 다릅니다. // 여기서 return 되는 로직에 의해 store의 값이 변경됩니다.&#125; Parent.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from &apos;react&apos;;import Left_Child from &quot;./Left_Child&quot;;import Right_Child from &quot;./Right_Child&quot;;import &#123;connect&#125; from &quot;react-redux&quot;;// react와 redux를 연결해주는 connect 모듈을 import 합니다.import * as ballReducer from &quot;../reduxModule/ballReducer&quot;;// &quot;reduxModule&quot; 폴더 아래에 ballReducer.jsx 파일의 export된 모든 요소를 import 합니다.// ballReducer.xxxx 처럼 해당 요소에 접근할 수 있습니다.function Parent(&#123;owner , changeOwner&#125;) &#123;// 파라메터 값으로 owner와 changeOwner가 넘어오고 있습니다. 해당 부분의 넘어오는 값에 대한// 설정은 밑에 mapStateToProps, mapDispatchToProps 함수로 정의되어 있습니다.// owner는 store로 부터 subscribe(구독)하여 넘어오는 상태값입니다.// changeOwner는 해당 상태를 변경할 dispatch가 넘어옵니다. const onClickParentToLeft = () =&gt; &#123; // 공을 parent가 갖고 있다면 changeOwner 함수를 호출하여 owner 상태를 // left로 변환합니다. 밑에 mapDispatchToProps 설정을 보시면 아시겠지만 // changeOwner 함수는 내부적으로 dispatch 함수를 호출합니다. if(owner == &apos;parent&apos;) changeOwner(&apos;left&apos;); &#125;; const onClickParentToRight = () =&gt; &#123; // 공을 parent가 갖고 있다면 changeOwner 함수를 호출하여 owner 상태를 // left로 변환합니다. 밑에 mapDispatchToProps 설정을 보시면 아시겠지만 // changeOwner 함수는 내부적으로 dispatch 함수를 호출합니다. if(owner == &apos;parent&apos;) changeOwner(&apos;right&apos;); &#125;; return( &lt;table className=&#123;&apos;parent-table&apos;&#125;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colSpan=&#123;2&#125;&gt; Parent &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; att=&#123;owner&#125; style=&#123;&#123;visibility: owner == &apos;parent&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // store에 구독중인 owner의 값을 통해 visibility 를 제어합니다. &lt;br/&gt; &lt;button onClick=&#123;onClickParentToLeft&#125; className=&#123;&apos;btn-parent-to-left&apos;&#125;&gt;Pass to Left_Child&lt;/button&gt; &lt;button onClick=&#123;onClickParentToRight&#125; className=&#123;&apos;btn-parent-to-right&apos;&#125;&gt;Pass to Right_Child&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td className=&#123;&apos;left-table&apos;&#125;&gt; &lt;Left_Child/&gt; // store에서 상태를 관리하므로 props로 내려줄 필요가 없습니다. &lt;/td&gt; &lt;td className=&#123;&apos;right-table&apos;&#125;&gt; &lt;Right_Child/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; );&#125;const mapDispatchToProps = dispatch =&gt; (&#123; changeOwner : (owner) =&gt; &#123; dispatch(ballReducer.getActionChangeOwner(owner)); &#125;&#125;);// dispatch를 개발자가 원하는 로직별로 Mapping하는 설정부분입니다.// 파라메터로 dispatch가 넘어옵니다. 해당 부분에 수행하고자 하는 action을 넘기면// reducer에서 해당 action을 판단하여 store의 상태를 업데이트 합니다.// 해당 메서드는 아래에 connect 함수의 파라메터로 들어갑니다.// 여기서 정의된 changeOwner가 위의 컴포넌트 파라메터로 다시 들어가게 됩니다.const mapStateToProps = (state) =&gt; &#123; return &#123; owner: state.ballReducer.owner &#125;;&#125;;// subscribe(구독) 을 통해 받을 값을 정의합니다.// state 파라메터를 통해 넘어온 값을 onwer에 값을 다시 셋팅합니다.// 셋팅한 onwer는 위에서 props로 받고 있는 owner로 값이 들어오게 됩니다.// 위의 state.ballReducer.owner는 state.[combinreducer를 한 reducer].[설정한 상태값] 입니다.export default connect(mapStateToProps,mapDispatchToProps)(Parent);// 구독 및 디스패치 함수의 셋팅과 parent 컴포넌트의 설정을 통해 store와 연결됩니다. Left_Child.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.Right_Child.jsx는 Left_Child.jsx에서 판단로직만 “right”로 변경이 되기에 코드를 생략합니다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React from &apos;react&apos;;import &#123;connect&#125; from &quot;react-redux&quot;;import * as ballReducer from &quot;../reduxModule/ballReducer&quot;;// Parent 컴포넌트와 동일하게 ballReducer와 connect 모듈을 import 합니다.function Left_Child(&#123;owner , changeOwner&#125;) &#123;// Parent 컴포넌트와 동일하게 owner에는 구독중인 상태값이 넘어오며 // changeOwner에는 dispatch를 할 수 있는 메서드가 넘어옵니다. const onClickChildToParent = () =&gt; &#123; if(owner == &apos;left&apos;) changeOwner(&apos;parent&apos;); &#125;; const onClickLeftToRight = () =&gt; &#123; if(owner == &apos;left&apos;) changeOwner(&apos;right&apos;); &#125;; return( &lt;div className=&#123;&apos;child&apos;&#125;&gt; &lt;button onClick=&#123;onClickChildToParent&#125; className=&#123;&apos;btn-to-parent&apos;&#125;&gt;Pass to Parent&lt;/button&gt; // store에 구독중인 owner의 값을 통해 visibility 를 제어합니다. &lt;br/&gt; Left Child &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: owner == &apos;left&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; &lt;button onClick=&#123;onClickLeftToRight&#125; className=&#123;&apos;btn-left-to-right&apos;&#125;&gt;Pass to Right&lt;/button&gt; &lt;/div&gt; );&#125;;const mapDispatchToProps = dispatch =&gt; (&#123; changeOwner : (owner) =&gt; &#123; dispatch(ballReducer.getActionChangeOwner(owner)); &#125;&#125;);// Parent와 동일하게 dispatch의 Mapping 정보를 정의합니다.const mapStateToProps = (state) =&gt; &#123; return &#123; owner: state.ballReducer.owner &#125;;&#125;;// Parent와 동일하게 구독 정보를 설정합니다.export default connect(mapStateToProps,mapDispatchToProps)(Left_Child);// Parent와 동일하게 store와 연결합니다. 정리 위의 그림은 03번 예제에 적용한 redux 및 컴포넌트의 전체 개념도 입니다. 단일 Store에 각 컴포넌트가 액션을 디스패치를 함과 동시에 owner에 대해 구독을 하고 있는 상황입니다. 단일 Store에서 owner에 대한 상태를 관리하므로 각 컴포넌트는 각자의 상태를 갖고 있을 이유가 없습니다. 이러한 redux는 Contex API와 동일하게 부모 자식관계가 깊어지더라도 Store에 디스패치 및 구독을 통해 서로 상태를 공유할 수 있습니다. 04. MobX를 활용한 전역상태 관리[폴더명 : “04. Mobx”] Mobx를 사용하기 위해서는 Mobx와 관련된 모듈들을 설치해줘야 합니다. 깃허브로 프로젝트를 다운로드 받으셨다면 package.json에 이미 들어가 있습니다. 만약 있지 않다면 아래의 명령어를 실행해주세요. 1npm install mobx mobx-react 기본적으로 mobx는 install를 해줘야하며 react와 같이 사용하기 위해서는 mobx-react를 추가로 설치해줍니다. mobx-react는 mobx로 설정된 값과 react를 연결하여 값이 변경되면 자동으로 rendering 되도록 해줍니다. Mobx도 마찬가지로 Action 발생하면 관리하는 state가 변경되며 이는 state와 관련된 정보들도 같이 업데이트가 됩니다. 파일구조는 아래와 같습니다. 1234567891011chapter02_react_component(본 글의 root 경로) └─ src └─ 03. Redux └─ Root.jsx └─ components └─ Parent.jsx (부모) └─ Left_Child.jsx (왼쪽 자식) └─ Right_Child.jsx (오른쪽 자식) └─ store └─ store.js (Mobx 스토어를 정의) ... 이하 생략 ... 01번 02번 03번 예제와 다르게 “store” 폴더 아래에 store.js 파일이 존재합니다. 해당 파일은 전역으로 사용할 상태를 Mobx로 정의를 해놓은 파일입니다. Mobx는 redux와 다르게 다수의 Store를 정의할 수 있으며 설정이 매우 간단하고 자유롭습니다. 그렇기 때문에 다수의 사람들이 공동으로 프로젝트를 사용할 경우 mobx-state-tree와 같은 틀이 조금더 구체화되어 있는 모듈을 사용하는 것이 좋습니다. 이 강좌에서는 mobx-state-tree를 따로 다루지 않습니다. 본 글에서 Mobx에 대해 데코레이터를 사용하지 않습니다.Root.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.12345678910111213// 해당 파일은 01번 예제와 동일합니다. 즉 , 설정할 부분이 없습니다.// 물론 mobx-react 모듈에서 Provider를 통해 Contex API 예제 처럼// 값을 전달할 수 있습니다. 하지만 본 글에서는 간단하게 store에 대해// import를 통해 사용합니다.import React from &apos;react&apos;;import Parent from &quot;./components/Parent&quot;;import &apos;../app.css&apos;;export default function Root() &#123; return( &lt;Parent/&gt; );&#125; store.js코드상에 “//“ 키워드를 사용하여 설명합니다.1234567891011121314151617import &#123; observable &#125; from &apos;mobx&apos;// mobx 모듈에서 observable 모듈을 import 합니다.// observable 모듈은 관리할 상태에 대해 정의할 수 있게// 도와줍니다.export default observable (&#123; owner : &apos;parent&apos;, setOwner (owner) &#123; this.owner = owner; // redux에서는 디스패치로 액션을 넘겨 상태를 변화시켰지만 // mobx에서는 &quot;=&quot; 키워드를 통해 값을 변경하면 자동으로 // 해당 상태에 대한 Action이 발생합니다. &#125;&#125;);// observable 모듈을 통해 owner와 setOwner에 대해 정의를 했습니다.// 하지만 실제로 관리가 되는 상태는 owner이며 setOwner는 단순히// owner를 변경하기 위한 메서드입니다. Parent.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from &apos;react&apos;;import Left_Child from &quot;./Left_Child&quot;;import Right_Child from &quot;./Right_Child&quot;;import Store from &quot;../store/store&quot;;// owner라는 상태를 갖고 있는 store 모듈을 import 합니다.import &#123;useObserver&#125; from &quot;mobx-react&quot;// mobx와 react를 이어주는 모듈입니다.// store에서 observable로 설정했던 상태들을 useObserver와 연결해주면// 해당 값이 변경시 react 에도 반영이 됩니다.export default function Parent() &#123; const onClickParentToLeft = () =&gt; &#123; // 현재 store에 owner 가 parent이면 left로 변경하라는 로직입니다. if(Store.owner == &apos;parent&apos;) Store.owner = &apos;left&apos;; // &quot;=&quot; 키워드를 통해 값을 직접 변경하여도 알아서 Action이 발생하여 값을 변경합니다. // 이는 아까 store에서 정의한 setOwner(&apos;left&apos;)를 사용하여도 됩니다. &#125;; const onClickParentToRight = () =&gt; &#123; if(Store.owner == &apos;parent&apos;) Store.owner = &apos;right&apos;; &#125;; return( // return에서 useObserver 모듈을 사용하여 mobx의 store에 있는 상태값이 변경되면 rendering을 도와줍니다. useObserver(() =&gt; ( &lt;table className=&#123;&apos;parent-table&apos;&#125;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colSpan=&#123;2&#125;&gt; Parent &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: Store.owner == &apos;parent&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; // store에 있는 owner 값을 통해 visibility 속성을 제어합니다. &lt;br/&gt; &lt;button onClick=&#123;onClickParentToLeft&#125; className=&#123;&apos;btn-parent-to-left&apos;&#125;&gt;Pass to Left_Child&lt;/button&gt; &lt;button onClick=&#123;onClickParentToRight&#125; className=&#123;&apos;btn-parent-to-right&apos;&#125;&gt;Pass to Right_Child&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td className=&#123;&apos;left-table&apos;&#125;&gt; &lt;Left_Child/&gt; &lt;/td&gt; &lt;td className=&#123;&apos;right-table&apos;&#125;&gt; &lt;Right_Child/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; )) );&#125; Left_Child.jsx코드상에 “//“ 키워드를 사용하여 설명합니다.Right_Child.jsx는 Left_Child.jsx에서 판단로직만 “right”로 변경이 되기에 코드를 생략합니다.1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import Store from &quot;../store/store&quot;;// owner라는 상태를 갖고 있는 store 모듈을 import 합니다.import &#123;useObserver&#125; from &quot;mobx-react&quot;// Parent 컴포넌트와 마찬가지로 store와 이어주는 모듈을 import 합니다.export default function Left_Child() &#123; const onClickChildToParent = () =&gt; &#123; if(Store.owner == &apos;left&apos;) Store.setOwner(&apos;parent&apos;); // Parent 모듈과 다르게 store에 있는 setOwner를 호출해서 사용합니다. // setOwner 메서드에는 &quot;this.owner = XXX&quot; 라는 로직이 있으므로 자동으로 // Action을 합니다. &#125;; const onClickLeftToRight = () =&gt; &#123; if(Store.owner == &apos;left&apos;) Store.setOwner(&apos;right&apos;); &#125;; return( // return에서 useObserver 모듈을 사용하여 mobx의 store에 있는 상태값이 변경되면 rendering을 도와줍니다. useObserver(()=&gt; ( &lt;div className=&#123;&apos;child&apos;&#125;&gt; &lt;button onClick=&#123;onClickChildToParent&#125; className=&#123;&apos;btn-to-parent&apos;&#125;&gt;Pass to Parent&lt;/button&gt; &lt;br/&gt; Left Child &lt;br/&gt; &lt;div className=&#123;&apos;ball&apos;&#125; style=&#123;&#123;visibility: Store.owner == &apos;left&apos; ? &apos;unset&apos; :&apos;hidden&apos;&#125;&#125;&gt;ball&lt;/div&gt; &lt;button onClick=&#123;onClickLeftToRight&#125; className=&#123;&apos;btn-left-to-right&apos;&#125;&gt;Pass to Right&lt;/button&gt; &lt;/div&gt; )) );&#125; 정리 위의 그림은 예제 04번 mobx를 적용한 전체 개념도입니다. Store는 mobx로 정의한 상태값을 갖고 있습니다. 각 컴포넌트는 mobx-react 모듈의 Observer를 통해 해당 값에 감시를 하며 컴포넌트 내에서 직접 변경되거나 혹은 store의 setOwner를 호출하여 Action을 발생시킵니다. 이에 변경된 store 상태가 react 컴포넌트들에게 적용이 됩니다. 마무리 4개의 예제를 통해 사용자 입장에서 같은 기능이지만 내부적으로는 다른 구조를 만들어보는 시간을 갖어 보았습니다. 여러개의 내용을 다루다보니 깊이 있게는 가지 못했지만 대략적인 사용법을 익히고 개념을 잡을 수 있는 시간이 되었으면 합니다. 감사합니다. 출처 책 : 리액트를 다루는 기술(개정판) https://velog.io/@velopert/react-redux-hooks https://medium.com/@jsh901220/mobx-%EC%B2%98%EC%9D%8C-%EC%8B%9C%EC%9E%91%ED%95%B4%EB%B3%B4%EA%B8%B0-a768f4aaa73e 인프런 강의 [Redux vs Mobx]/ 강사 : 조현영","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"3. React","slug":"it-tech/3-react","permalink":"http://yoursite.com/categories/it-tech/3-react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Java refactoring 1부","slug":"java-refactoring-01","date":"2019-12-24T05:34:05.000Z","updated":"2021-11-13T10:48:21.523Z","comments":true,"path":"2019/12/24/java-refactoring-01/","link":"","permalink":"http://yoursite.com/2019/12/24/java-refactoring-01/","excerpt":"","text":"작성자 : 플랫폼 개발실 서버개발팀 유현선 리팩토링 입문 1부리팩토링은 참신한 주장이 아니라 여러 설계자나 프로그래머의 경험을 정리한 것으로 이런 점에서 디자인 패턴과 유사합니다.그래서 다른 개발에 관련된 문서들을 찾아보면 리팩토링과 디자인패턴, TDD(Test Driven Development, 테스트 주도 개발)를 같은 내용으로 함께 다루기도 합니다. 리팩토링이라는것 자체가 좀 더 좋은 코드를 작성하기 위한 과정/방법의 하나인 만큼 너무나 당연한 얘기고 이미 코드를 작성하면서 따로 리팩토링이라는 이름을 붙이지 않고서도 이미 그렇게 작성하고 있는 내용들도 꽤 있었습니다.저도 &lt;자바로 배우는 리팩토링 입문&gt; 책을 읽으면서 ‘어? 이미 이렇게 하고있었는데’ 싶었던 것도 있고 새롭게 알게된 점도 있었습니다.이미 알고있고 또 그렇게 해왔던 내용이어도 초심으로 돌아가 자신의 코드를 점검해보는 마음으로 재밌게 읽어봐주시면 좋겠습니다. &lt;자바로 배우는 리팩토링 입문&gt; 책을 읽고 작성하였습니다. 리팩토링이란 외부에서 본 프로그램의 동작은 바꾸지 않고 프로그램의 내부 구조를 개선하는 것 기능추가나 버그 수정 등은 리팩토링이라고 할 수 없음 1. 리팩토링의 목적 버그를 발견하기 쉽게 만듬 기능을 추가하기 쉬워짐 코드 리뷰를 하기 용이함 2. 리팩토링 시 주의해야 할 점리팩토링을 진행하면서 실수 할 수 있고 놓치기 쉬운 점을 아래와 같이 정리해봤습니다. (1) 유닛테스트위에서 말했던 것처럼 리팩토링은 외부 동작이 변하지 않고 내부 구조만을 개선 시키는 것으로, 만약 리팩토링의 결과로 새로운 버그가 생기거나 동작이 기존의 명세와 달라진다면 그건 잘못된 리팩토링입니다.그래서 정말로 동작이 변하지 않고 제대로 된 리팩토링이 되었는지 확인하기 위해서는 유닛 테스트가 중요합니다. 리팩토링 과정에서 유닛테스트를 하는 방법은 간단합니다. 리팩토링 전에 테스트 리팩토링 진행 리팩토링 후에 테스트1번과 3번의 결과(외부 동작이)가 같다면 성공적으로 리팩토링을 완료한 것입니다. (2) Step by Step 여러개의 리팩토링을 동시에 진행하지 말 것 : 한번에 하나의 리팩토링만 진행 되돌리기 쉽게 하기 : 만약 리팩토링을 진행하다가 문제가 생기거나 하는 경우가 반드시 존재할 수 있으므로 이를 반드시 고려 단계마다 확인 : 작업 단계마다 제대로 수정이 되고 있는건지 확인 오래된 걸 새로운 걸로 바꿈 3. 리팩토링 카탈로그리팩토링들의 목적과 절차를 카탈로그 형식으로 정리한 것을 리팩토링 카탈로그라고 부릅니다.책에서 소개된 http://www.refactoring.com/ 라는 사이트가 있는데 많은 종류의 리팩토링들이 (영어지만) 수식과 함께 설명되어 있어 이해가 어렵지 않아 심심하실때 한번씩 들어가서 구경해보시는 것을 추천드립니다. 매직 넘버를 기호 상수로 치환코드 내 매직넘버(특정 의미를 갖는 숫자값)-흔히 우리가 말하는 ‘하드코딩’ 된 수치값-을 상징이 되는 이름을 써서 상수로 선언하여 치환시키는 방법입니다. 1. 리팩토링 카탈로그참고:Refactoring catalog 1. 예제아래는 실제 개발했던 코드를 예제에 맞게 간략화하여 수정, 가공한 내용입니다. (1) 리팩토링 전123456789101112private void doSituationOccurrenceSend(Patient patient) &#123; SituationOccurrenceDetail sod = new SituationOccurrenceDetail(); sod.setSittnClCode(\"SITUATION_CODE_09\"); sod.setReferenceNum(patient.getPatntNum()); sod.setReferenceType(\"patient\"); sod.setReferenceValue(patient.getPatntName()); sod.setTrgterNum(patient.getPatntNum()); sod.setTrgterType(\"patient\"); sod.setTrgterName(patient.getPatntName()); occurenceController.situationOccurrence(sod);&#125; 새로운 환자 정보가 등록되었을때 정보를 가공하여 ‘상황발생이력 등록occurenceController.situationOccurrence(sod);‘을 처리하는 method 입니다.여기서 sod.setReferenceType(&quot;patient&quot;); sod.setTrgterType(&quot;patient&quot;); 이 부분을 보면 환자(patient)라는 구분값이 일반 string 값으로 하드코딩 되어있습니다.sod.setSittnClCode(&quot;SITUATION_CODE_09&quot;); 이 부분 또한 특정한 코드값을 의미하는 string 값으로 따로 보면 그 의미를 알기 힘듭니다. (2) 리팩토링 후12345678910111213141516private static final String PATIENT_REGIST = \"SITUATION_CODE_09\";private static final String PATIENT = \"patient\";private void doSituationOccurrenceSend(Patient patient) &#123; SituationOccurrenceDetail sod = new SituationOccurrenceDetail(); sod.setSituationCode(PATIENT_REGIST); sod.setReferenceNum(patient.getPatntNum()); sod.setReferenceType(PATIENT); sod.setReferenceValue(patient.getPatntName()); sod.setTrgterNum(patient.getPatntNum()); sod.setTrgterType(PATIENT); sod.setTrgterName(patient.getPatntName()); occurenceController.situationOccurrence(sod);&#125; 2. 분류 코드를 클래스로 치환하기 : enum class 사용단순히 계산값이나 URL 같은 하드코딩 값은 상수로 선언하여 사용하면 되지만 분류코드(type code)는 enum 등을 활용하여 class로 치환하여 사용하면 좋습니다.예를 들어 내부 로직에 위해 계산된 결과에 따라 상태값을 지정해주거나 할 때 이 상태값을 enum 클래스로 생성하여 관리하면 어떤 상태값들이 있는지 확인하고 수정, 추가하기가 쉽습니다. (1) 예제아래는 센서 상태값을 처리하는 enum 클래스를 만들어 관리를 쉽게 만든 내용입니다. 12345678910111213141516171819public enum SensorStatusType implements EnumValue&lt;String&gt; &#123; NONE(\"\"), OUTOFRANGE(\"OUTOFRANGE\"), CRITICAL(\"CRITICAL\"), WARNING(\"WARNING\"), NORMAL(\"NORMAL\"); SensorStatusType(String value) &#123; this.value = value; &#125; private String value; @Override public String getValue() &#123; return value; &#125;&#125; 메소드 추출하나의 method 는 그 이름에 맞는 하나의 기능만 처리하는 것이 좋습니다.만약 한 메소드 안에 이러저런 세세한 처리가 많다면 그런 처리를 묶어서 나누고 독립된 메소드로 추출하는 것이 메소드 추출 리팩토링입니다.저 같은 경우는 어떤 기능을 개발 할 때 처리해야 할 내용을 순서대로 작성 처리 내용에 따라 보통 Test 코드로 하나의 method 에 기능을 전부 작성 테스트로 그 기능이 정상적으로 작동하는지 확인 정상적으로 작동하는 코드를 기능별로 method 로 분리 하는 과정을 거치는데 여기서 4번이 이번에 서술할 메소드 추출 리팩토링에 속한다고 볼 수 있을것 같습니다. 1. 리팩토링 카탈로그참고:Refactoring catalog 2. 예제IntelliJ IDEA는 리팩토링에 강력한 여러가지 기능들을 제공해주고 있습니다. 여기서 그 중 하나인 메소드 추출 기능을 예제와 함께 설명하겠습니다. (1) 리팩토링 전 아래 코드는 하루동안의 입실/퇴실 목록을 조회하는 JSON 으로 각각 가져오는 Query 는 다르지만 넘겨주는 parameter 값이 중복되고 있습니다. 12345678910111213141516171819202122232425@RequestMapping(value = \"/dashboard/inList.json\", method = RequestMethod.POST)@ResponseBodypublic Object getTodayFloorInTargetList() &#123; FloorLogSearchParam logSearchParam = new FloorLogSearchParam(); TimeZone loginTimeZone = TimeZone.getTimeZone(Security.getLoginDetail().getTimeZone()); logSearchParam.setComNum(Security.getLoginDetail().getCompanyNumber()); logSearchParam.setStartDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 00:00:00\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); logSearchParam.setEndDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 23:59:59\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); List&lt;?&gt; res = presenceFloorService.getTodayFloorInList(logSearchParam); return res;&#125;@RequestMapping(value = \"/dashboard/outList.json\", method = RequestMethod.POST)@ResponseBodypublic Object getTodayFloorOutTargetList() &#123; FloorLogSearchParam logSearchParam = new FloorLogSearchParam(); TimeZone loginTimeZone = TimeZone.getTimeZone(Security.getLoginDetail().getTimeZone()); logSearchParam.setComNum(Security.getLoginDetail().getCompanyNumber()); logSearchParam.setStartDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 00:00:00\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); logSearchParam.setEndDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 23:59:59\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); List&lt;?&gt; res = presenceFloorService.getTodayFloorOutList(logSearchParam); return res;&#125; (2) 리팩토링 후중복된 검색Parameter 설정을 method 로 분리 123456789101112131415161718192021222324@RequestMapping(value = \"/dashboard/inList.json\", method = RequestMethod.POST)@ResponseBodypublic Object getTodayFloorInTargetList() &#123; FloorLogSearchParam logSearchParam = setSearchParam(); List&lt;?&gt; res = presenceFloorService.getTodayFloorInList(logSearchParam); return res;&#125;@RequestMapping(value = \"/dashboard/outList.json\", method = RequestMethod.POST)@ResponseBodypublic Object getTodayFloorOutTargetList() &#123; FloorLogSearchParam logSearchParam = setSearchParam(); List&lt;?&gt; res = presenceFloorService.getTodayFloorOutList(logSearchParam); return res;&#125;private FloorLogSearchParam setSearchParam() &#123; FloorLogSearchParam logSearchParam = new FloorLogSearchParam(); TimeZone loginTimeZone = TimeZone.getTimeZone(Security.getLoginDetail().getTimeZone()); logSearchParam.setStartDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 00:00:00\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); logSearchParam.setEndDate((int) DateUtil.str2timestamp(DateUtil.getDate(\"yyyy-MM-dd 23:59:59\"), \"yyyy-MM-dd HH:mm:ss\", loginTimeZone)); logSearchParam.setComNum(Security.getLoginDetail().getCompanyNumber()); return logSearchParam;&#125; 3. IntelliJ의 Refactor &gt; Extract Method 기능IntelliJ IDEA는 리팩토링에 강력한 여러가지 기능들을 제공해주고 있습니다.여기서 그 중 하나인 메소드 추출 기능을 소개해드리겠습니다.참고로 IntelliJ IDEA 는 프로젝트 안에서 소스코드의 내용이 중복되면 노란색 밑줄로 경고표시를 해줘서 동일한 코드가 중복으로 작성되는 일을 방지할 수 있습니다.(설정에서 변경 가능) 추출할 메소드를 블럭 오른쪽 마우스 클릭 &gt; Refactor &gt; Extract Method (단축키 : Ctrl + Alt + M) 자동으로 선택된 코드가 method 로 분리됨 선택했던 영역 외에도 중복으로 코드가 작성된 부분이 있다면 자동으로 생성된 메소드로 대체 출처 책 : 자바로 배우는 리팩토링 입문","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"React-1부 [개발환경 구축하기]","slug":"react-hooks-chapter01","date":"2019-12-12T05:56:55.000Z","updated":"2021-11-13T10:48:21.528Z","comments":true,"path":"2019/12/12/react-hooks-chapter01/","link":"","permalink":"http://yoursite.com/2019/12/12/react-hooks-chapter01/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 유주빈 들어가기 앞서 기존의 HTML , CSS를 이용하여 충분히 웹 사이트를 만들 수 있습니다. 또한 자바스크립트까지 활용한다면 동적인 요소들도 제어할 수 있습니다. 그러나 앞서 말한 HTML , CSS , 순수한 자바스크립트로만 프론트 엔드를 개발한다는 것은 상당히 복잡하고 어렵습니다. 이러한 부분을 이 글에서 설명할 React를 통해 체계적으로 프론트 엔드 개발을 할 수 있게 됩니다. React란 리액트는 페이스북에서 제공을 하고 있는 프론트 엔드 라이브러리 입니다. 이는 컴포넌트 기반으로 개발자가 UI를 설계하도록 도와줍니다. React의 특징1. 컴포넌트 기반 위에서 언급했듯이 React는 컴포넌트 기반이라고 하였습니다. 이를 설명하기 위하여 아래의 사진을 보도록 하겠습니다. 위의 사진은 이 글에서 실습할 React dom 구조 및 컴포넌트 구조입니다. 일반적인 태그로 아주 간단한 dom 트리구조를 갖고 있습니다. 그러나 빨강색 박스로 한개 이상의 dom을 묶은 컴포넌트 또한 확인할 수 있습니다. 즉, 컴포넌트는 여러개의 태그를 갖을 수 있으며 해당 태그에 대한 로직과 UI 표현을 제어할 수 있습니다. 2. virtual dom(가상 dom) React를 통해 개발을 하는 개발자는 상황에 따라 다르지만 대게 직접적인 Dom을 제어하여 UI를 수정하지 않습니다. 개발자는 컴포넌트의 상태만을 관리하며 이러한 상태를 React의 적절한 로직을 통해 변경하면 가상 돔은 업데이트가 되고 실제 돔과의 비교를 하게 됩니다. 이를 통해 변동이 생긴 부분을 아예 삭제하고 변경된 dom을 해당 부분으로 변경하게 됩니다. 3. One-way Data Flow (단방향 데이터) 위에서 설명한 리액트의 특징을 종합해보면 , dom을 컴포넌트 단위로 분리할 수 있으며 해당 컴포넌트들은 각각의 state(상태)를 갖을 수 있습니다. 이렇게 다수의 컴포넌트들은 데이터를 서로에게 전달할 수 있습니다. 다만, 이러한 데이터의 흐름은 기본적으로 부모 컴포넌트에서 자식 컴포넌트로 단방향 흐름만이 가능합니다. React 간단한 예제 아래의 내용을 만들기 전에 미리 본글에서 만들 아주 간단한 예제입니다. 지금부터 해당 설명을 하도록 하겠습니다. React의 개발환경 설정1. 경로 설정 및 관련 라이브러리 다운로드하위 설명은 node가 설치되어 있다는 전제조건하에 설명에 들어가도록 하겠습니다. 이 글은 v10.16.3 버전으로 작성되었습니다. React의 본격적인 개발에 들어가기 앞서 프로젝트 폴더와 관련 라이브러리를 다운로드 받도록 하겠습니다. 현재 저는 Window 운영체제를 사용중이기 때문에 cmd창을 이용하여 설정을 하겠습니다. 아래의 명령어를 통해 디렉토리를 생성합니다. “pntbiz_react”는 개발자가 하고자 하는 이름으로 변경하셔도 됩니다. 1mkdir pntbiz_react 방금 생성한 디렉토리로 이동하여 npm 초기화를 합니다. 명령어 init을 하면 package name 및 version 등 입력해달라는 정보가 나옵니다. 본 글에서는 전부 엔터를 입력하여 해당 값을 입력하지 않았습니다. 12cd pntbiz_reactnpm init npm을 이용하여 react 라이브러리를 다운로드 합니다. 또한 react-dom 모듈 또한 설치를 합니다. react-dom은 react 모듈을 이용해 만든 내용을 실제 UI 렌더링에 사용되는 모듈입니다. 1npm install --save react react-dom React는 프로젝트 규모가 커질수록 많은 컴포넌트들이 생기며 해당되는 파일들이 무수히 많이 생성됩니다. 게다가 관련된 자바스크립트 , css , 이미지 등까지 합친다면 양이 엄청나게 불어납니다. webpack은 이러한 수 많은 파일들의 대규모 의존성을 파악하고 브라우저가 이해할 수 있도록 번들로 묶고 컴파일하는 역할을 합니다. webpack-cli는 webpack을 사용한 프로젝트를 더욱 유연하게 사용할 수 있도록 커맨드라인으로 제어할 수 있도록 도와줍니다. webpack-dev-server는 webpack을 통해 개발 서버를 열어 개발중인 결과물을 확인할 수 있도록 도와줍니다. 1npm install -D webpack webpack-cli webpack-dev-server 위에서 언급한 webpack은 다수의 파일을 하나의 번들링으로 묶고 컴파일을 한다고 하였습니다. 여기서 말하는 컴파일이란 브라우저가 이해할 수 있는 언어로 변환되는 것을 의미합니다. 결국 프론트 엔드 개발이기 때문에 최종 결과물은 브라우저가 이해를 해야합니다. 이때 사용되는 모듈이 babel 입니다. 자세히는 자바스크립트 컴파일러이며 최신 자바스크립트 문법인 ES6, ES7 , React 등의 문법을 브라우저가 이해할 수 있도록 도와주며 이러한 환경은 preset가 들어간 모듈들이 도와줍니다. 1npm install -D @babel/core @babel/preset-env @babel/preset-react babel-loader 참고 사항 : npm install에서 D 옵션을 사용함은 개발시에만 필요한 모듈을 분리하기 위함입니다.2. 개발환경 설정해당 부분에서는 위에서 내려받은 여러 모듈을 통해 React 개발환경을 구축해보도록 하겠습니다. 아래는 생성할 디렉토리의 미리보기 구조입니다. 해당 경로와 동일하게 폴더와 파일들을 생성해주세요. 아래 구조의 오른쪽 숫자는 내용을 수정할 파일의 순서입니다.123456789101112( / : 프로젝트 root 디렉토리 혹은 package.json이 있는 경로 )/index.html (1)/index.jsx (3)/package.json/package-lock.json/webpack.config.js (2)/src └─ components └─UserList.jsx (4) └─User.jsx (5)/dist (해당 폴더와 app.js는 만들지 않아도 됩니다.) └─ app.js 1) index.html 해당 파일은 실제 서버로 접속하면 처음으로 보이게 되는 html 파일입니다. 해당 소스는 아래와 같습니다. 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;pntbiz_react&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./dist/app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 내용은 크게 특별한 점은 없습니다. 일반적은 head와 body로 분리가 되어 있습니다. 약간의 특이점은 하나의 div가 id로 “root”라는 속성을 갖고 있으며 script 파일로 “./dist/app.js” 경로의 app.js 파일을 호출하고 있습니다. id 속성의 값인 “root”는 꼭 “root”일 필요는 없지만 실습과 동일하게 해주세요. 2) webpack.config.js 웹팩의 기본적인 설정은 아래와 같습니다. 참고 : React에서 jsx란 자바스크립트의 확장판 문법입니다. 확장자를 jsx나 jsx로 하나 상관은 없으나 webpack에서 확장자를 이용하여 해당 파일을 어떤 방법으로 컴파일할지 정하기 때문에 해당 글에서는 jsx라고 정하겠습니다.123456789101112131415161718192021const path = require(&apos;path&apos;);module.exports = &#123; mode: &apos;development&apos;, entry: &#123; app: &apos;./index.jsx&apos;, &#125;, module: &#123; rules: [&#123; test: /\\.jsx?$/, loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;] &#125; &#125;], &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;app.js&apos; &#125;,&#125;; 해당 설정에서 가장 중요한 부분은 entry와 module, output 입니다. entry : 컴파일을 시작할 파일을 명시합니다. 현재는 indexjsx 파일을 통해 컴파일이 시작되며 하나 이상의 파일을 설정할 수도 있습니다. module : entry에서 시작한 컴파일의 규칙을 정하는 부분입니다. 해당 내용에서는 jsx 확장자를 option의 presets에 명시한 설정을 babel-loader가 사용하여 컴파일 하라는 내용입니다. output : 컴파일이 완료된 산출물을 생성하는 부분입니다. 현재 dist폴더에 app.js로 생성되도록 설정을 했습니다. 해당 산출물을 index.html에서 호출합니다. 3) index.jsx12345import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import UserList from &apos;./src/components/UserList.jsx&apos;ReactDOM.render(&lt;UserList/&gt; , document.querySelector(&apos;#root&apos;)); index.jsx는 webpack.config.js에서 컴파일의 시작점으로 지정한 파일이며 react와 react-dom 모듈을 불러오고 있습니다. 또한 dom의 id로 root인 dom에 UserList라는 컴포넌트를 주입하겠다는 설정입니다. 여기서 생소한 문법이 있습니다. 바로 UserList 태그 입니다. 해당 컴포넌트를 화면에 렌더링을 하기 위해서는 컴포넌트를 태그화하여 표현을 하면 렌더링을 하게 됩니다. 4) UserList.jsx123456789101112131415import React from &apos;react&apos;;import User from &quot;./User.jsx&quot;;export default class UserList extends React.Component&#123; render() &#123; return ( &lt;div&gt; &lt;tabe&gt; &lt;User name=&#123;&apos;김아무개&apos;&#125; age=&#123;25&#125;/&gt; &lt;User name=&#123;&apos;이아무개&apos;&#125; age=&#123;26&#125;/&gt; &lt;/tabe&gt; &lt;/div&gt; ) &#125;&#125;; 자바스크립트의 class 문법을 통해 React의 Component를 extends 키워드를 통해 상속받아 컴포넌트를 생성하게 됩니다. render는 위에서 언급한 컴포넌트를 태그화하여 표현하게 되면 호출이 되어 return으로 dom을 반환하여 렌더링을 합니다. return 내부에는 위의 import 키워드로 불러온 User 컴포넌트를 사용하고 있습니다. 게다가 User 태그의 내부에는 name과 age의 속성을 명시해주고 있으며 ‘{‘를 통해 값이 들어가 있는 것을 확인할 수 있습니다. ‘{}’를 이용하면 return으로 돌려주는 dom에 자바스크립트 문법을 작성을 할 수 있습니다. 이를 위에서 언급한 React애서 jsx를 뜻합니다. 여기서는 User에 name과 age의 속성에 데이터를 내려주는 단방향 흐름을 확인할 수 있습니다. 참고 : Javascript + XML를 뜻하는 jsx는 xml형식인 dom 내부에 자바스크립트를 사용할 수 있는 문법을 일컫습니다. 리액트는 v16.8 부터 hooks라는 문법을 지원합니다. 해당 문법은 class를 통해서가 아닌 함수와 같은 형태로 함수형 컴포넌트를 만들 수 있도록 해줍니다. 위의 코드를 hooks로 변환하면 아래와 같습니다. 12345678910111213import React from &apos;react&apos;;import User from &quot;./User.jsx&quot;;export default function UserList() &#123; return ( &lt;div&gt; &lt;tabe&gt; &lt;User name=&#123;&apos;김아무개&apos;&#125; age=&#123;25&#125;/&gt; &lt;User name=&#123;&apos;이아무개&apos;&#125; age=&#123;26&#125;/&gt; &lt;/tabe&gt; &lt;/div&gt; );&#125;; 상단에 react 모듈을 불러오며 class와 동일하게 컴포넌트를 export를 합니다. 다만 함수를 선언하여 내부에 return으로 dom을 반환하면 알아서 React의 Component를 상속받아 생성된 class와 동일한 기능을 하게 됩니다. 5) User.jsx123456789101112131415import React from &apos;react&apos;;export default class User extends React.Component&#123; constructor(props) &#123; super(props); &#125;; render() &#123; return ( &lt;tr&gt; &lt;td&gt;&#123;this.props.name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.age&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;&#125;; UserList.jsx에서 name과 age 속성을 전달하였습니다. 해당 전달받은 값은 props로 전달이 됩니다. 이는 this.props라는 키워드를 통해 접근할 수 있습니다. 이를 통해 render함수 내부에 값의 위치를 설정할 수 있습니다. User.jsx 컴포넌트 또한 hooks 문법으로 표현하면 아래와 같습니다. 12345678910import React from &apos;react&apos;;export default function User(&#123;name,age&#125;) &#123; return ( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;age&#125;&lt;/td&gt; &lt;/tr&gt; );&#125;; 함수형 컴포넌트의 파라메터로 값을 받아 개발자가 원하는 dom 위치에 설정을 하면 됩니다. class를 기반한 컴포넌트가 좋은지 , 함수형 컴포넌트인 hooks가 좋은지는 개발자별로 취향이 다릅니다. 다만 개인적은 의견으로는 hooks가 코드가 더욱 간결하므로 hooks를 권장드립니다. 6) 빌드 및 실행하기 cmd 창을 열거나 혹은 개발툴을 이용하여 root 경로로 이동합니다. 이동 후 아래의 명령어를 실행합니다. 1webpack 해당 명령어를 통하면 자동으로 webpack.config.js 파일을 찾아 컴파일을 시작합니다. 컴파일이 완료가 되면 /dist/app.js가 있는 것을 확인할 수 있습니다. 해당 파일을 확인했다면 webpack 개발 서버를 통해 결과물을 확인할 수 있습니다. 아래의 명령어를 입력합니다. 1webpack-dev-server 개발 서버 명령어를 통해 서버가 열리며 기본 포트인 8080으로 서버가 개설됩니다. 이제 브라우저를 열어 localhost:8080을 입력하면 아래와 같은 결과가 브러우저에 나타납니다. 비록 css 및 동적인 자바스크립트로 UI를 수정하여 보기 좋은 결과물은 아니지만 기본적인 React의 셋팅 및 구조에 대해서 알아보았습니다. 소스 깃허브 주소 : https://github.com/SayRew/pntbiz_react.git 출처 책 : 리액트를 다루는 기술(개정판) https://www.geeksforgeeks.org/reactjs-reactdom/","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"3. React","slug":"it-tech/3-react","permalink":"http://yoursite.com/categories/it-tech/3-react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"대시보드 설계와 데이터 시각화 1부","slug":"dashboard","date":"2019-11-28T13:56:55.000Z","updated":"2021-11-13T10:48:21.514Z","comments":true,"path":"2019/11/28/dashboard/","link":"","permalink":"http://yoursite.com/2019/11/28/dashboard/","excerpt":"","text":"작성자 : 플랫폼 개발실 R&amp;D팀 신상은 대시보드 설계와 데이터 시각화 1부 이번 주제는 실무에서 많이 사용하는 대시보드를 효과적으로 설계하는 방법과 복잡한 데이터를 친숙하게 표현할 수 있도록 시각화 하는 방법에 대해 알아보도록 하겠습니다. &lt;대시보드 설계와 데이터 시각화&gt; 라는 책을 참고 하였습니다. 1. 데이터를 시각화 해야하는 이유 대시보드를 만들기 위해서는 주어진 데이터를 활용하여 시각화 하는 작업이 필요 합니다. 데이터 시각화를 활용하면 많은 양의 데이터도 시각화 차트 하나로 요약할 수 있기 때문 입니다. 시각화 차트 유형은 매우 다양한데, 이 중 어떤 시각화 차트를 활용 하느냐에 따라 같은 데이터로도 여러가지 인사이트를 발견 할수 있습니다. 시각적 분석 에서는 데이터 시각화를 얼마나 잘 이해 하고 활용 하느냐에 따라서 도출 가능한 데이터 인사이트 범위가 달라집니다. 데이터 시각화 대시보드의 장점은 여러 차트를 한 화면에 모아서 볼 수 있는 것뿐만 아니라 많은 양의 데이터를 빠르게 탐색할 수 있는 인터랙티브 기능 요소를 포함 한다는 것입니다. 데이터 필터와 차트 간 인터랙션 기능 요소를 활요하면 데이터의 조회 기간을 변경하거나, 특정 항목을 기준으로 세부 데이터를 빠르게 확인할 수 있습니다. 2. 대시보드를 만들 때 고려해야 할 사항2.1. 목적에 적합한 시각화 차트 활용 데이터 시각화 대시보드 내 개별 시각화 차트는 데이터의 특성과 활용에 맞는 시각화 유형을 사용 합니다. 같은 데이터라도 어떤 시각화 유형을 사용하느냐에 따라 직관적으로 데이터를 찾아내는 데 정도의 차이가 발생 합니다. 시간 흐름에 따라 변화하는 데이터 값의 추이 변화를 표현하고자 한다면 선 차트가 효과적이고, 전체 중 특정 항목이 차지하는 구성 비중을 표현하고자 한다면 파이 차트를 활용하는 것이 효과적입니다. 2.2. 한 화면의 시각화 차트는 5개 이내 데이터 시각화 대시보드 화면을 구성하는 시각화 차트 수는 최대 5개 정도로 제한 합니다. 종합적인 데이터 도출을 위해 여러개의 시각화 차트를 한번에 볼 필요가 있다고 해서 무조건 많은 것이 좋다고 할 수는 없습니다. 대시보드 한 화면 내 너무 많은 시각화 차트를 구성할 경우 오히려 너무 많은 시각화 차트가 보여주는 데이터 인사이트 중 무엇이 중요한 것인지 구별하기 어려운 상황을 맞게 될 수 있습니다. 효과적인 데이터 시각화 대시보드는 단순히 차트를 나열하는 것이 아닌 얻고자 하는 핵심 데이터 인사이트 도출을 목표로 설계된 것이므로, 목표 달성을 위해 필요한 최소한의 시각화 차트와 인터랙티브 기능 요소만으로도 충분히 데이터 인사이트를 도출할 수 있습니다. 2.3. 핵심 인사이트별 개별 대시보드 제작 사용자의 모든 니즈를 충족시킬 수 있는 단 하나의 대시보드를 만들려고 하기 보다는 구별되는 각각의 니즈를 충족시킬 수 있는 여러개의 데이터 시각화 대시보드를 만드는게 효과적 입니다. 단 하나의 시각화 차트로 모든 데이터 인사이트를 도출할 수 없듯이, 데이터 시각화 대시보드 하나로 찾기 원하는 모든 데이터 인사이트를 발견할 수 없습니다. 따라서 데이터 시각화 대시보드를 보는 사람이 누구인지, 데이터 탐색의 세부 기준-인구 특성별, 지역별, 시간별 등-을 무엇으로 할 것인지 등의 기준으로 개별 데이터 시각화 대시보드를 만듭니다. 한 화면으로 만들되 각 대시보드를 탭으로 구분하여 대시보드별 이동을 쉽게 하는 것도 방법 입니다. 이 경우 개별 데이터 시각화 대시보드에서 도출할 수 있는 인사이트가 구체적이고 명확하므로 효과적으로 핵심 인사이트를 빠르게 파악할 수 있습니다. 2.4. 적색과 녹색 색각 이상(CVD): 색각 이상(色覺異常)은 시력의 이상으로 인해 색상을 정상적으로 구분하지 못하는 증상을 말한다.흔히 색맹(色盲), 또는 색약(色弱)이라고도 부른다. 우리는 흔히 좋은 것을 나타낼 때는 녹색, 나쁜 것을 나타낼때는 적색을 떠올립니다. 하지만 대시보드에서 적색과 녹색을 사용한다면 색각 이상을 겪는 사람에게 치명적인 문제가 될 수 있습니다. 색각이상(CVD, Color Vision Deficiency) 주로 유전이며 남성의 8%, 여성의 1%가 많이 겪습니다. 이를 겪는 사람의 주된 문제는 적색, 녹색, 오렌지색 모두 갈색으로 보이는 것 이므로 함께 사용하지 않아야 하며, 일반적으로 흔히 신호등 색조합은 피하는 것이 좋습니다. 데이터 시각화 실무자들은 흔히 해결책으로 파란색과 오렌지 색을 사용합니다. 녹색 대신 파란색, 적색 대신 오렌지색을 사용하면 거의 모두가 파란색과 오렌지색은 구별할 수 있으므로 꽤 효과적 입니다. 이 파랑-오렌지 팔레트는 ‘색맹 친화적’이라고 일어집니다. 하지만 사용자가 원해서 적색과 녹색을 사용 해야 하는 경우, 구별된 데이터의 대안적인 방법을 제공해야 합니다. 이를 위해서는 아이콘(좋음/나쁨)을 활용하거나, 색맹 친화적인 색으로 전환할 수 있는 체크박스나 드롭박스를 사용합니다.: 색맹을 위한 디자인 조정A. 원본 이미지 B. 색맹 교정본 C. 최적화된 디자인 3. 여러 가지 차트 대시보드에서 주로 사용하는 그래프 중에 흔히 볼수 있는 그래프는 어떤 것이 있을까요? 영역 차트, 막대 차트, 꺾은선 차트, 히스토그램 그래프, 도넛 그래프 등이 존재 합니다. 그 중에서도 파이 그래프와 도넛 그래프에 대한 문제점과 대안 그래프에 대해 알아 봅니다. 정확한 정량 비교를 제시할 때 각도나 아치, 영역, 원 크기등을 사용 하는 것은 데이터를 약화 할때 길이나 위치를 사용하는 것만큼 좋지 못합니다. 이러한 이유로 파이 차트, 도넛 차트, 버블 차트는 일반적으로 데이터 시각화에 적절한 선택이 아닙니다. 가끔 예외는 있지만, 이런 차트를 사용할 때는 아주 주의 해야 합니다. 3.1. 파이 차트의 문제점 데이터에 카테고리가 많은 경우, 고려해야 할 것은 데이터 유형 입니다. 파이 차트의 목적은 부분에서 전체로의 관계 표시 입니다. 파이 차트를 읽을 때 주된 문제는 조각을 서로 비교 하는 것인데, 파이나 도넛 차트를 너무 많은 조각으로 나누게 되면 데이터를 해석하기가 더 어려워 집니다. 3.2. 도넛 차트의 문제점 도넛 차트는 부분에서 전체로의 관계를 보여주는 파이 차트의 대안으로 사용하며, 핵심성과지표(KPI)를 나타낼 때 자주 쓰입니다. 다양한 카테고리나 기간의 결함율을 보여주는 일련의 도넛 차트인 경우, 데이터의 차이를 보기가 아주 어려운 점도 문제가 됩니다. 3.3. 대안 차트 위의 문제점을 해결하기 위한 대안 차트로는 아래와 같은 그래프들이 있습니다. 3.3.1. 롤리팝 차트 막대의 높이/길이로 데이터를 규약화하고 카테고리를 한눈에 비교 할 수 있습니다. 3.3.2. 불릿 그래프 길이/높이 혹은 위치와 색으로 데이터를 규약화해 타겟이나 성과 대역에 비교한 실제를 표시합니다. 실제 값 대비 타겟의 비교를 보여주는 가장 좋은 방법에 속합니다. 3.3.3. 확산형 막대차트 중간 지점으로부터 확산 되는 막대의 길이/높이로 데이터를 규약화해 카테고리 비교를 표시 합니다. 3.3.4. 산포도 위치로 데이터를 규약화해 2가지 변수의 관계를 표시 합니다. 크기로도 2차 비교를 할 수 있습니다. 3.3.5. 트리맵 크기와 색으로 데이터를 규약화하며 계층적 데이터나 대량의 카테고리를 비교할 때 유용 합니다. 출처 도서: &lt;대시보드 설계와 데이터 시각화&gt; 색각이상 http://newsjel.ly/archives/newsjelly-report/visualization-report/9145 https://docs.microsoft.com/ko-kr/power-bi/service-dashboards https://helpx.adobe.com/kr/photoshop/using/proofing-colors.html http://hleecaster.com/how-to-draw-a-pie-radar-chart-in-excel https://www.datarevelations.com/with-great-power-comes-great-responsibility-or-think-before-you-use-a-donut-chart.html https://datavizproject.com/data-type/lollipop-chart/ https://okviz.com/blog/introducing-bullet-chart-v2-1/ https://www.makeovermonday.co.uk/week-29/ https://newsjel.ly/archives/newsjelly-report/visualization-report/9387","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"2. Data Analysis","slug":"it-tech/2-data-analysis","permalink":"http://yoursite.com/categories/it-tech/2-data-analysis/"}],"tags":[{"name":"dashboard","slug":"dashboard","permalink":"http://yoursite.com/tags/dashboard/"},{"name":"data analysis","slug":"data-analysis","permalink":"http://yoursite.com/tags/data-analysis/"}]},{"title":"비콘(Beacon)에 대한 이해","slug":"beacon-ble","date":"2019-11-13T05:56:55.000Z","updated":"2021-11-13T10:48:21.513Z","comments":true,"path":"2019/11/13/beacon-ble/","link":"","permalink":"http://yoursite.com/2019/11/13/beacon-ble/","excerpt":"","text":"작성자 : 플랫폼 개발실 서버개발팀 팀장 김대영 1. 비콘(Beacon)이란 무엇인가 전통적인 의미에서의 비콘은 어떤 신호를 알리기 위해 주기적으로 신호를 전송하는 기기를 모두 의미한다.역사적으로 보면 비콘이 가장 널리 사용된 부분은 적의 침입을 알리는 일종의 군사 연락 수단이었다. 언덕이나 높은 곳에 설치한 불빛을 의미한다. 육지에서는 적의 습격을 미리 감지해 방어 할 수 있도록 알려주는 기능을 했고 바다에서 보면 등대의 역할로 선박의 안전 운행을 유도하는 역할로 기능을 했다.따라서 옛날의 등대나 봉화 같은 것도 전통적인 의미에서는 모두 비콘에 포함된다고 할 수 있다. 이러한 비콘의 개념은 현대에 이르러 IT기술과 만나 보다 확장되고, 일상 깊숙이 들어왔다. 비콘을 활용하면 사물과 상황인식, 콘텐츠 푸시, 실내위치 측위, 자동 체크인, 지오펜스 등 다양한 응용 서비스 제공이 가능 하다. 비콘은 본질적으로 위치를 알려주는 기준점 역할을 하며, 정보 전달을 위해서는 통신기술(음파(Ultrasonic) , LED, WiFi, 블루투스) 활용이 필요하다. 2. 비콘의 종류 신호를 전송하는 방법에 따라 사운드기반의 저주파 비콘, LED 비콘, WiFi 비콘, 블루투스 비콘 등으로 나눌 수 있다. 2.1. iBeacon 아이비콘(iBeacon)은 비콘의 전통적인 개념만 따왔을 뿐 기술적으로는 기존의 비콘과는 많이 다르다. 아이비콘의 기본 개념은 위치서비스(Location Services)를 iOS로 확장한 것이다.애플이 아이비콘에 사용한 핵심 기술은 블루투스 4.0 표준에 포함된 사양 중 하나인 블루투스 로우 에너지(BLE, Bluetooth Low Energy)다. iBeacon은 BLE 4.0의 애드버터이징 패킷(Advertising Packet)전송 표준을 활용, 이를 iOS기기에 적용한 것이다.아이비콘 장치의 비콘 신호 영역 안에 iOS 기기를 소지한 사용자가 들어오면 해당 어플리케이션에 신호(Beacon)를 보내게 된다. 예를 들어 특정 상점 근처를 지나갈 때 상점에 설치된 비콘이 할인 쿠폰을 보내주거나 박물관에서 특정 전시물 앞에 가면 관련된 내용을 iOS 기기로 보내주는 등 이러한 기술을 이용할 수 있는 영역이 매우 다양하다. 2.2. no-iBeacon iBeacon 규격을 사용하지 안는 Beacon 모델도 있다. AltBeacon : Radius Networks 사에서 오픈 한 규격으로 애플의 iBeacon 규격을 보다 유연성 있게 재 구성한 비콘 이다. UriBeacon : Google의 Physical Web 프로젝트와 연계되어 특정 URI(Universal Resouce Identifier)가 포함된 Advertising Data를 브라우저를 통해 바로 정보를 보여주는 방식이다. Placedge : 삼성이 자사의 스마트폰인 갤럭시폰에 관련 기능을 지원하면서 해당 서비스 App이 설치되어 있지 않아도 이를 바로 연결해 주도록 지원하고 쿠폰, 콘텐츠 등을 전달하는 플랫폼을 별도로 개발하지 않아도 가능하도록 서버 플랫폼을 함께 제공하고 있다. 에디스톤(Eddystone) : 2015년 구글에서 발표했으며 오픈 소스 프로젝트이다. 차이점은 에디스톤의 전송패킷은 Eddyston-UID, Eddyston-URL, Eddyston-TML(Telemetry)세가지 타입이 있다. 기존 규격을 지키면서도 유연한 구조로 iOS와 Android 모두에서 잘 동작하는 것이 목표라고 한다. 3. 비콘의 장단점3.1. 장점 Bluetooth 기반의 무선 통신이지만 페어링 하는 과정이 없습니다. (사용자의 수동적인 작업이 필요 없다.) 저전력 기술이다 BLE(Bluetooth Low Energy) 기술을 활용하여 구현하여 iOS는 물론 BLE를 장착한 모든 기기(안드로이드 포함)에서 Beacon을 이용 할 수 있다. 근거리 무선 통신인 NFC가 10m 이내의 근거리에서만 작동하는 반면, Beacon은 약5m에서 50m(최대70m) 정도의 먼 거리에서도 사용이 가능하다. 안전적 거리는 20~30m이다 장비에 접촉 없이 Beacon이 설치된 곳을 지나가기만 해도 데이터 전송이 가능하다. 3.1. 단점 Beacon 자체의 보안성 문제인 스푸핑(Spoofing)과 클로닝(Cloning)에 취약 하다. 스푸핑 : 네트워크에서 MAC 주소, IP주소, 포트 등 네트워크 통신과 관련된 정보들을 속여서 통신 흐름을 왜곡시키는 공격. 클로닝 : 원본 시스템의 복제본을 하나 이상을 생성하는 것으로, 기존에 체크인 되었던 대사물의 정보를 복제하여 그 대상물이 없어도 있는 것처럼 속여서 정보를 빼내는 방법. 비콘 확산으로 많은 채널이 점유되면 비콘 간의 전파 간섭과 충돌로 인해 신호 수신율 저하와 서비스 자체가 불가능해질 우려가 있다. 비콘이 부착된 사물 또는 소유하는 사용자의 개인정보가 노출 될 수 있다. 4. Bluetooth Low Energy(BLE) BLE는 종종 Bluetooth Smart 로도 불리며 classic Bluetooth의 경량화 버전을 목표로 블루투스 4.0의 일부로 발표되었습니다. Classic Bluetooth와 겹치는 부분이 존재하지만 BLE는 완전히 다른 표준으로 블루투스 표준화 그룹인 Bluetooth SIG에 의해서 개발되기 전까지 Nokia의 사내 프로젝트(Wibree)로 시작하였습니다.BLE를 지원하는 디바이스들은 기본적으로 Advertise(Broadcast) 과 Connection 이라는 방법으로 외부와 통신한다. 4.1. Advertise Mode(Broadcast Mode) 특정 디바이스를 지정하지 않고 주변의 모든 디바이스에게 Signal을 보낸다. 다시 말해, 주변에 디바이스가 있건 없건, 다른 디바이스가 Signal을 듣는 상태이건 아니건, 자신의 Signal을 일방적으로 보내는 것이라고 생각하면 된다. 이 때, Advertising type의 Signal을 일정 주기로 보내게 된다. Advertise 관점에서, 디바이스의 역할은 다음과 같이 구분된다. Advertiser(Broadcaster) : Non-Connectable Advertising Packet을 주기적으로 보내는 디바이스. (Beacon) Observer : Advertiser가 Advertise를 Non-Connectable Advertising Packet을 듣기 위해 주기적으로 Scanning하는 디바이스. (스마트폰 및 스캐너) Advertise 방식은 한 번에 한 개 이상의 디바이스와 통신할 수 있는 유일한 방법이다. 주로 디바이스가 자신의 존재를 알리거나 적은 양(31Bytes 이하)의 User 데이터를 보낼 때도 사용된다. 한 번에 보내야 하는 데이터 크기가 작다면, 굳이 오버헤드가 큰 Connection 과정을 거쳐서 데이터를 보내기 보다는, Advertise를 이용하는 것이 더 효율적이기 때문이다. 게다가 전송할 수 있는 데이터 크기 제한을 보완하기 위해 Scan Request, Scan Response을 이용해서 추가적인 데이터를 주고 받을 수 있다. Advertise 방식은 말 그대로 Signal을 일방적으로 뿌리는 것이기 때문에 보안에 취약하다. 4.2. Connection Mode 양방향으로 데이터를 주고받거나, Advertising Packet으로만 전달하기에는 많은 양의 데이터를 주고 받아야 하는 경우에는, Connection Mode로 통신을 한다. Advertise처럼 ‘일대다’ 방식이 아닌, ‘일대일’ 방식으로 디바이스 간에 데이터 교환이 일어난다. 디바이스간에 Channel hopping 규칙을 정해놓고 통신하기 때문에 Advertise보다 안전하다.Connection 관점에서 디바이스들의 역할은 다음과 같이 구분된다. Central (Master) : Central 디바이스는 다른 디바이스와 Connection을 맺기 위해, Connectable Advertising Signal을 주기적으로 스캔 하다가, 적절한 디바이스에 연결을 요청한다. 연결이 되고 나면, Central 디바이스는 timing을 설정하고 주기적인 데이터 교환을 주도한다. 여기서 timing이란, 두 디바이스가 매번 같은 Channel에서 데이터를 주고 받기 위해 정하는 hopping 규칙이라고 생각하면 된다. Peripheral (Slave) : Peripheral 디바이스는 다른 디바이스와 Connection을 맺기 위해, Connectable Advertising Signal을 주기적으로 보낸다. 이를 수신한 Central 디바이스가 Connection Request를 보내면, 이를 수락하여 Connection을 맺는다. Connection을 맺고 나면 Central 디바이스가 지정한 timing에 맞추어 Channel을 같이 hopping을 하면서 주기적으로 데이터를 교환한다. 5. iBeacon 스펙 Advertiser’s Data (Max 31 byte) 영역은 iBeacon prefix, UUID, Major, Minor, TX Power 로 나뉩니다. iBeacon prefix(9 byte) : 비콘의 설정이나 특성 값이 기록되는 부분입니다. iBeacon 헤더 정보라 생각하시면 됩니다. 우리가 손대지 않고 정해진 값을 사용해도 됩니다. UUID (16 byte) : 사실 iBeacon에서 가장 중요한 데이터는 UUID, Major, Minor 값입니다. 이 값을 추출한 뒤, 서버에 보내서 내가 어느 위치에 있는지, 이 비콘이 어떤 역할을 하는지, 그래서 사용자에게 어떤 정보를 보여주는 것이 좋은지 판단하게 됩니다. iBeacon 관련 공식 문서를 보면 주변에서 스캔한 UUID, Major, Minor 로 사용자의 위치를 판단하는 예시들을 언급하는데, iBeacon 장치가 위치기반 서비스의 일부임을 표시하기 위해 미리 정해둔 UUID 를 사용합니다. UUID는 꼭 표준에 지정된 값을 쓸 필요는 없으며, 서비스 개발자가 임의로 지정해서 사용해도 됩니다. Major (2 byte), Minor (2 byte) : UUID 와 함께 사용자의 위치(Major, Minor = 지역, 세부 장소)를 판별하는데 주로 사용됩니다. 하지만 사용방법이 고정된 것은 아니며, 개발자가 이 값들을 임의의 목적으로 사용할 수도 있습니다. 예를 들어, 온도와 습도 데이터를 Major, Minor 데이터로 보낼 수도 있습니다. 물론 이 경우 비콘을 스캔 하는 장치도 해당 데이터를 온도, 습도로 인식하도록 만들어야 합니다. TX Power(1 byte) : 비콘 장치가 신호를 송출할 때의 power 레벨을 여기에 적어 보내줍니다. 비콘 신호를 수신할 때 신호 세기를 알 수 있기 때문에 TX power 보다 얼마나 감소했는지를 계산하고, 대강의 거리를 짐작할 수 있습니다. 하지만 이렇게 계산된 거리는 대략적인 추정치입니다. 비콘 신호는 주변 상황이나 움직임, 장애물에 의한 변동이 심할 수 있습니다. 6. iBeacon 서비스 종류 페블(pebBLE)형 : 매장 및 상점들을 겨냥한 소형 타입, 체크인 기능만 가능. 마블(MarBLE)형 : 병원이나 공항에서 실내 네비게이션을 가능케 하는 타입, 체크인과 내비게이션 기능이 모두 탑재. 님블(nimBLE)형 : 전시 솔루션이나 박물관에서 적용할 수 있는 타입, 체크인과 내비게이션 기능이 모두 탑재. 트래블(treBLE)형 : 실외용 위치 솔루션을 위한 타입, 체크인과 내비게이션 기능이 모두 탑재. 7. iBeacon 활용방법 비콘 신호를 활용하여 기획 할 수 있는 서비스는 다양 합니다. 실제 야구장의 좌석 안내 서비스, 미술관의 작품 해설 서비스, 쿠폰이나 매장 이벤트 알림 서비스, 결제 서비스, 미아 방지 서비스, 작업자 안전관리 서비스, 출입보안, 자산관리, 창고관리, 차량관제 등에 비콘이 사용되고 있습니다. 복잡한 연결 설정이나 코드 없이도 주변 비콘 장치들을 짧을 시간 안에 스캔하고 정보를 얻을 수 있는 비콘의 특징을 연구하여 획기적인 서비스로 구현해 보시기 바랍니다. 출처-http://www.ibeacon.com/what-is-ibeacon-a-guide-to-beacons-http://www.hardcopyworld.com/ngine/aduino/index.php/archives/3202-http://www.isquery.com/wiki/lib/exe/fetch.php?media=beacon_.pdf","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"1. IoT","slug":"it-tech/1-iot","permalink":"http://yoursite.com/categories/it-tech/1-iot/"}],"tags":[{"name":"beacon","slug":"beacon","permalink":"http://yoursite.com/tags/beacon/"}]},{"title":"Network Engine 2부","slug":"network2","date":"2019-10-12T13:47:01.000Z","updated":"2021-11-13T10:48:21.527Z","comments":true,"path":"2019/10/12/network2/","link":"","permalink":"http://yoursite.com/2019/10/12/network2/","excerpt":"","text":"IoT 에서의 네트워크 엔진 작성자 : 플랫폼 개발실 실장 김완철(David Kim) 3. IoT 에서의 데이터 수집시 문제점3.1. 대량의 데이터 현재 IoT 디바이스 수는 보통 우리가 생각하는 수준을 휠씬 뛰어넘고 있다. 디바이스수는 데이터량과 정비례한다. 의미있는 데이터든, 단순한 로그성 데이터든 디바이스에서 중앙저장소(서버)로 데이터를 전송하는 액션은 IoT디바이스가 가지고 있는 가장 기본적인 성향이자, 비즈니스를 하는 입장에서 추구하는 지향점이라고 할수 있다. 보통 웹브라우저에서 웹사이트에 접속하면 서버에서 로컬 클라이언트로 데이터가 전송되어 화면에 나타나게 된다. IoT디바이스의 경우 데이터의 방향이 보통의 웹사이트와 반대 방향이기 때문에 중앙저장소(서버)의 역할은 매우 크다고 할수 있다. 대량의 데이터를 서버에 처리하는 프로세스는 일반 웹서비스를 개발하는 과정과는 근본적으로 차이가 있다. 컴퓨팅 리소스는 기본이며, 애플리케이션의 견고성, 퍼포먼스는 늘 고민할 수 밖에 없다. 3.2. 초고속 데이터 일반적으로 데이터의 양이 문제가 되지만, 그와 함께 데이터 전송 주기는 데이터의 양만큼 기본적으로 고민할 수 밖에 없는 문제점이다. 주기 또는 속도는 같은 데이터의 양이라고 하더라도 서버의 리소스와 애플리케이션의 성능을 좌지우지하는 중요한 팩터(factor)이다. 규칙적으로 빠르게, 규칙적으로 느리게, 불규칙적으로 빠르게, 불규칙적으로 느리게, 이렇게 다양한 방식으로 데이터는 전송된다. 그중 가장 큰 위험요소는 불규칙적으로 빠르게 전송되는 데이터이다. 불규칙적이고 빠른 주먹은 방어하기가 쉽지 않듯이, 사전 준비나 예측이 불가능한 경우는 컴퓨팅 리소스와 애플리케이션의 성능 측면에 있어서는 치명적인 독과 같다. 3.3. 네트워크 레이턴시 인터넷 속도는 근 20년 사이에 엄청나게 빨라졌다. 스마트폰에서도 실시간으로 동영상이나 MMORPG 게임이 가능한 수준이기에 일반적으로 사용하는 유선인터넷의 속도는 가히 짐작할 수 있다. 특히 기업의 경우는 가정에서 사용하는 네트워크의 전송속도나 대역폭(bandwidth)보다 수십배는 좋기 때문에 데이터 전송에 매우 최적화되어 있다. 그렇다고 해서 모든 기업의 네트워크의 성능이 최대치라고 생각하는것은 무리가 있다. 비용문제와 보안문제 등 여러가지 이유로 전송속도와 대역폭, 그리고 특정 기간동안의 제한된 전송량은 IoT디바이스의 데이터 전송 측면에서 보면 치명적인 문제점으로 다가온다. 또한, 인위적인 제한이 아니라고 하더라도, 너무 많은 디바이스로 인해 네트워크 전송속도가 느려지고, 레이턴시(지연시간)이 늘어나게 되는 경우는 매우 자주 발생하는 현상으로 볼수 있다. 단편적으로 사무실에서 누군가 대량의 데이터를 다운로드 받거나, 업로드할때 사무실 전체 네트워크가 느려지는것이 이러한 경우라 할수 있다. 3.4. 데이터 수집 서버 성능 데이터는 중앙저장소 즉 콜렉터(collector)라고 불리우는 서버로 전송된다. 웹서비스와 다른 대량의 데이터를 초고속으로 받아서 로직을 실행하거나, 분석하거나, 또는 단순히 저장을 하는 일련의 과정은 하드웨어 서버가 아닌 서버에 설치되어 있는 애플리케이션(웹서버, 데이터 처리 애플리케이션 등등)가 수행하게 된다. 서버를 아무리 하이엔드로 구축하였다 하더라도 데이터를 처리하는 애플리케이션의 성능은 얼마나 적절한 애플리케이션을 구축했는지, 또는 적절한 아키텍처로 구성되었는지에 따라 많은 차이를 보인다. 4. IoT 에서의 데이터 수집에 새로운 접근법4.1. 새로운 아키텍처에 대한 고민 데이터 수집시 네트워크 속도나 대역폭, 그리고 전송량은 데이터를 수집해야 하는 해당 지역 또는 회사의 네트워크 인프라에 의존(Dependency)할수 밖에 없다. 기본적으로 네트워크에 문제가 발생하거나, 전송이 불규칙하거나, 데이터가 한꺼번에 몰리는 경우가 있다는 전제을 깔고, 아키텍처를 구성해야 한다. 일반적인 아키텍처는 수집 서버(또는 웹서버) 한대로 모두 처리하는 경우로 데이터베이스 역시 함께 구성한다. 또는 데이터베이스를 분리하는 경우가 그 다음으로 구성하는 단계이다. 데이터 처리가 서버 한대로 불가능한 수준까지 오게 되면, 1차적으로 스케일업(scale-up)을 하게 된다. 즉 CPU, 메모리, 스토리지 용량을 높이는 단계이다. 정통적인 서버의 경우는 스케일업조차 쉽지 않았다. 왜냐하면 직접 하드웨어를 열어서 업그레이드를 해야 했기 때문이다. 클라우드가 보편화된 요즘은 한번의 설정 변경으로 스케일업이 이루어지기 때문에 크게 문제가 되지 않는다. 만약, 스케일업 수준을 넘게되면 2차로 횡적으로 확장하는 스케일아웃(scale-out)을 시도하게 된다. 하지만, 이 마저도 어느 시점에 가게 되면 한계에 도달하게 된다. 즉, 새로운 애플리케이션, 새로운 아키텍처에 대한 고민이 시작되며, 기존의 정통적인 방식의 단순한 아키텍처로는 해결이 어렵다는것을 알게 된다. 빅데이터 아키텍처가 발전함에 따라 대용량 데이터 처리를 위한 새로운 애플리케이션, 예를 들어 스톰, 하둡, 카프카 등등 매우 다양한 애플리케이션이 나타났으면, 클라우드에서 제공하는 매니지먼트 서비스 (AWS 키네시스 등등)도 함께 발전하게 되었다. 4.2. 클라우드 컴퓨팅과 엣지 컴퓨팅 클라우드 컴퓨팅이 보편화된것이 그리 오래 되지 않았다. 기존에는 서비스를 오픈하기 위해서는 하드웨어 스펙과 대수를 산정하고 견적을 받는 업무가 필수적이였다. 인프라 지식이 없는 엔지니어나 개발자의 경우는 하드웨어 스펙을 산정하는 일이 그리 쉬운일만은 아니였다. 또한 규모가 있는 회사에서는 구매팀이 따로 있어서 서버 구매금액에 대한 네고라고 불리우는 네고시에이션(negotiation)을 수행했지만, 작은 회사, 보통 스타트업의 경우 개발리더 또는 CTO가 견적 및 네고까지 하는 경우가 비일비재했다. 특히 서버 수량의 산정은 구매 금액의 할인률과도 연관이 있고, 서비스를 어느정도까지 커버할지, 어느 정도까지 확장할지에 대한 미래 계획까지도 포함을 해서 결정해야 하는 무척 어려운 일이였다. 하지만, 클라우드가 보편화되고, 저렴(솔직히 엄청 저렴하진 않다.)해진 지금 시점에서는 서버스펙 및 서버대수에 대한 고민은 시간낭비가 되어 버렸다. 그렇다고 해도, 적절할 인스턴스 타입을 선택하고, 어떻게 아키텍처를 구성하느냐에 따라서 비용이 천차만별이기 때문에 클라우드 비용절감에 대한 고민은 지속적으로 해야 한다. 또한 좀더 저렴함 새로운 타입의 인스턴스가 지속적으로 출시되기 때문에 클라우드의 새로운 소식도 놓치지 말고 찾아보아야 한다. 클라우드 덕에 편하게 서버를 증설할수 있지만, 서버 하나하나가 모두 비용이기 때문에 데이터를 좀더 효율적으로 수집하고 처리할수 있는 방법에 대한 고민은 계속되고 있으며, 그에 대한 대안이 엣지 컴퓨팅이라는 개념이라고 생각한다. 엣지 컴퓨팅이란 쉽게 얘기해서 IoT디바이스 자체에서 클라이언트에 제공할수 있는 데이터는 자체적으로 처리하고, 꼭 필요한 데이터만 중앙서버(클라우드)에 전송하는 개념이다. 이 개념은 필요한 데이터만 전송하기 때문에 중앙 저장소에 부담이 적을뿐만 아니라 네트워크를 효율적으로 사용할수 있고, 클라이언트 입장에서는 엣지 컴퓨팅에서 바로 데이터 처리 내용을 받아 볼수 있어, 기존보다 빠르게 응답 받을수 있다. 단순히 데이터만 전송하는 IoT디바이스의 경우는 데이터를 서버로 전송할때 불필요한 데이터를 필터링할수 있는 기능만 추가하더라고, 좀더 빠르게 데이터를 수집하고, 클라우드 컴퓨팅 리소스 또한 절약할수 있다. 5. IoT 에서의 네트워크 엔진5.1. 실시간 데이터 처리 데이터의 수집시, 대량의 데이터 또는 초속 데이터에 따라 아키텍처의 구성을 다양하게 할수 있다. 무조건 저장만하고 추후에 데이터 분석에 이용한다거나, 데이터 스트림 과정중에 필요한 데이터만 캡쳐해서 저장하고 분석한다거나 할수도 있다. 여러가지 비즈니스 니즈와 다양한 솔루션 기능에 따라 데이터 구성 방법이나 데이터 저장 방법이 달라지겠지만, 실시간(100~500ms) 데이터를 가지고, 실시간으로 데이터 분석하여 어떠한 결과를 도출하는 솔루션의 경우는 데이터 수집 및 처리에 대해서 좀더 신중하게 그리고, 깊이 고민할 필요가 있다. 데이터가 들어오는 초기 진입시부터 최종 분석이나 결과를 도출하는 과정까지 처리되는 시간이 실시간으로 클라이언트에게 응답해줘야 하는 비즈니스 니즈의 상황에서 처리 파이프라인 사이사이에 애플리케이션이 추가되면 될수록 늘어남에 따라 실시간 응답이라는 취지를 잃게 되는 문제점이 생길수 있다. 안정적인 데이터 처리가 중요한 포인트라면 적절하게 파이프라인을 구축하는 방법은 최근 많이 알려진 빅데이터 기술을 사용하면 충분 처리가 가능하다. 하지만, 대량이면서 초고속 데이터를 실시간으로 빠르게 처리하고, 빠르게 응답해 주는 일은 그리 녹녹하지 않다. 솔루션 니즈에 100% 맞는 것이 없다면, 기존에 나와 있는 빅데이터 기술이나 데이터 스트림 처리가 가능한 다양한 애플리케이션에만 집중하지 말고, 데이터 처리를 위해 개발한 애플리케이션의 아키텍처를 수정함으로써 실시간 처리에 대한 문제를 해결해야 한다. 5.2. 동기, 비동기에 대한 고려 데이터 수집, 처리 및 분석시 데이터베이스는 기본적으로 사용하는 스토리지이다. 비용이나 속도문제를 해결하기 위해 레디스나 몽고디비와 같은 오픈소스 메모리 데이터베이스를 많이 사용한다. 하지만 메모리 데이터베이스를 사용했다고 해서 실시간 데이터 처리가 잘될거라는 생각은 오산이다. 데이터를 저장하는 과정은 같은 하드웨어가 아닌 다른 하드웨어 설치된 메모리 데이터베이스의 경우 네트워크를 타고 넘어가야 하는 문제로 성능이 떨어지거나 또는 디스크 IO 로 인한 성능이 떨어지게 된다. 데이터 저장시 동기 처리인지 비동기 처리인지에 따라서 데이터를 처리하는 애플리케이션 전체 성능이 결정된다. 당연히 비동기 처리에 대한 고민을 해야 하며, 애플리케이션 또는 데이터베이스가 비동기처리를 지원하는지 확인해 봐야 한다. 비동기 처리가 안되는 경우 비동기 처리가 되도록 리팩토링하거나, 프레임워크를 바꾸거나 최악의 상황에서는 개발언어를 변경해서 재구축해야 하는것도 고려해야 한다. 비동기 처리는 동기 처리보다 몇십배 좋은 성능을 보여준다는것은 이미 검증된 상황이기 때문이다. 본 내용은 작성자 개인적인 의견입니다. 다른 의견이 있으시면, 피드백 환영합니다.","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"1. IoT","slug":"it-tech/1-iot","permalink":"http://yoursite.com/categories/it-tech/1-iot/"}],"tags":[{"name":"Network","slug":"network","permalink":"http://yoursite.com/tags/network/"},{"name":"IoT","slug":"iot","permalink":"http://yoursite.com/tags/iot/"},{"name":"RTLS","slug":"rtls","permalink":"http://yoursite.com/tags/rtls/"},{"name":"LBS","slug":"lbs","permalink":"http://yoursite.com/tags/lbs/"},{"name":"VertX","slug":"vertx","permalink":"http://yoursite.com/tags/vertx/"},{"name":"Node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"Network Engine 1부","slug":"network","date":"2019-10-12T07:15:30.000Z","updated":"2021-11-13T10:48:21.526Z","comments":true,"path":"2019/10/12/network/","link":"","permalink":"http://yoursite.com/2019/10/12/network/","excerpt":"","text":"IoT 에서의 네트워크 엔진 작성자 : 플랫폼 개발실 실장 김완철(David Kim) 1. 개요 인터넷이 보편화된 시점부터 지금까지 데이터 처리에 대한 관심과 이슈는 언제나 있어 왔다. 인터넷의 속도가 느렸던 과거에는 데이터량와 처리속도에 대한 이슈가 그다지 많지는 않았지만, 에러없이 데이터 처리를 하고자 하는 생각은 속도와 데이터량에 상관없이 주요 관심사였다. 5G로 가고 있는 현시점도 마찬가지로 속도와 데이터량에 대한 관심은 실시간으로 데이터를 처리하는 솔루션 특히 서비스파트에서 많이 관심을 보이고 있다. 1.1. 데이터 수집 데이터 수집이란 말은 쉽게 생각하면, 그냥 저절로 들어오는 데이터를 모으는 행위 또는 특정한 장소에 저장되어 있는 데이터를 가져와서 저장하는 개념이 포함되어 있다. 데이터 수집은 초기 인터넷 서비스부터 회원가입이라는 개념이 있는 그 시점부터 당연스럽게 생겼던 개념이다. 초고속 인터넷망이 보편화된 현재에도 데이터 수집은 지속적으로 이루어져 왔고, 특히 빠르고, 네트워크망에 부담없이 데이터를 수집할지에 대한 고민은 여전히 숙제로 남아 있다. 1.2. 데이터 가공 데이터를 수집하고, 특정 위치에 저장하고, 해당 데이터를 읽는 행위는 데이터를 수집하는 솔루션 특히 서비스업체에서는 당연한 업무이며, 비즈니스의 한 부분이라는것에는 이견이 없다. 하지만, 가공이라는 역할은 그리 쉽지 않는 업무프로세스이다. 특히 쓰레기 데이터가 들어오면 결과물도 쓰레기라는 얘기가 있듯이, 가공하는 그 시점에 어떤 데이터를 선별하고 어떤 데이터를 이쁘게 가공할지에 대한 고민은 한순간의 문제로 끝나지 않는다. 1.3. 데이터 분석 데이터가 가공이 되면, 그 다음 프로세스로 가공된 데이터를 필요한 요건에 맞게 분석하는 일이다. 데이터 분석이 반드시 인사이트(insight) 있는 리포트를 생산하는 업무라기 보다는, 리포트를 만들수 있도록 그 전단계까지 데이터 자체를 분석하는것도 이 범위에 속한다고 생각한다. 업무 범위나 프로세스에는 충분히 이견이 있을수 있다고 생각한다. 분석단계가 데이터 처리의 마지막이라고 생각하는 경우가 보편적이기 때문이다. 하지만 내가 생각하는 분석과 인사이트(insight)는 특정한 업무범위나 분석능력 그리고 특정 도메인에 정통한 사람이 있느냐 없느냐에 따른 분석과 인사이트(insight) 업무가 분리된다고 생각한다. 1.4. 데이터 인사이트(insight) 가공 및 분석된 데이터를 특정 도메인에 정통한 멤버가 우리가 보지 못한, 또는 우리가 분석하지 못한 내용을 도출하는 액션 또는 업무프로세스가 데이터 인사이트라고 생각한다. 데이터는 누구나 수집하고 가공하고 분석할수는 있으나 그것을 가지고, 미래에 대한 예측, 예견 또는 현재의 문제점을 파악하고 도출해내는 행위야 말로 데이터 인사이트라는 용어를 붙일수 있다고 생각한다. 이 프로세스 역시 여러가지 이견이 있을수 있지만, 본인이 생각하는 것이 분석과 인사이트는 엄연히 다르다고 생각한다. 2. IoT 에서의 데이터 수집2.1. 디바이스 IoT 란 Internet of Things 의 약자로 말 그대로 어떠한 물건(에셋)에 인터넷이 결합된 것을 의미한다. 최근 4차 산업이라고 불리우는 것들중 IoT 는 빠지지 않고 단골손님처럼 회자된다. 물건하나 하나를 인터넷 망이라는 또는 무선망으로 연결한다며, 그 연결 과정에서 나오는 데이터 특히 IoT 제품(상품) 이라고 보편적으로 불리고 있는 인터넷 연결이 가능한 세탁기나 공기청정기 같은 전자제품에서 특정 서버로 데이터를 전송하게 된다면, 엄청난 데이터가 수집이 가능해지게 된다. 하지만, 인터넷 연결이 불가능한 디바이스도 존재하기 때문에, 데이터 전송을 위한 보완책이 필수적으로 마련되어야 한다. 2.2. 디바이스 서버 게이트웨이(브릿지) 인터넷망으로 연결된 IoT 제품의 경우는 서버로 특정한 데이터를 전송할수 있는 기본적인 구성은 되어 있다. 하지만, 인터넷이 가능하도록 부품을 심기 힘든 디바이스 특히 비컨이나 센서와 같은 작은 사이즈의 디바이스는 데이터를 서버로 보낼수 있는 방법이 쉽지가 않다. 이런한 문제를 해결하기 위해 브릿지 또는 게이트웨이라는 디바이스를 가지고, 작은 사이즈의 센서나 비컨들의 데이터를 서버로 전송하게 된다. 참고 : 게이트웨이(브릿지) 2.3 데이터 수집 서버(클라우드) 원하는 데이터를 수집하기 위해서는 어딘가에는 저장을 해야 한다. 대부분은 데이터베이스라는 전통적인 RDB를 이용하게 된다. 인터넷이 발달하기 시작한 시점의 인터넷 서비스 또는 솔루션에서는 RDB(오라클, MSSQL, MYSQL)는 매우 유용한 없어서는 안될 신과 같은 존재였다. 요즘도 마찬가지로 반드시 있어야 하는 애플리케이션이다. 하지만, 최근들어 인터넷 속도가 빨라지고, IoT 라는 디바이스에서 수집되는 데이터 그리고, 인터넷 역사에 길어짐에 따라 엄청나게 축된 데이터들 처리하기 위해서는 전통적인 아키텍처 또는 전통적인 애플리케이션으로는 해결하기 쉽지가 않다. 한가지 예로, 어느순간 예상치 못하게 수집되는 데이터량이 폭발적으로 늘어나거나, 데이터 처리를 위한 프로세스가 길어짐에 따라 컴퓨팅 리소스가 부족하게 되는 기존에 예상하지도 않았던 것들이 나타나고 있다 이와 같은 경우는 전통적인 방식 또는 아키텍처 또는 생각으로는 해결할 수가 없다. NoSQL 또는 유연하게 확장이 가능한 아키텍처 구성 또는 데이터를 수집하고 처리할수 있는 애플리케이션(네트워크 엔진)의 성능이 엄청난 데이터를 흘려다니는 현대에는 반드시 필요한 기본 필수 요건이 되어 가고 있다. 다음글 : 2부 보기 본 내용은 작성자 개인적인 의견입니다. 다른 의견이 있으시면, 피드백 환영합니다.","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"1. IoT","slug":"it-tech/1-iot","permalink":"http://yoursite.com/categories/it-tech/1-iot/"}],"tags":[{"name":"Network","slug":"network","permalink":"http://yoursite.com/tags/network/"},{"name":"IoT","slug":"iot","permalink":"http://yoursite.com/tags/iot/"},{"name":"RTLS","slug":"rtls","permalink":"http://yoursite.com/tags/rtls/"},{"name":"LBS","slug":"lbs","permalink":"http://yoursite.com/tags/lbs/"},{"name":"VertX","slug":"vertx","permalink":"http://yoursite.com/tags/vertx/"},{"name":"Node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"깃허브 블로그 협업하기","slug":"hexo-pr","date":"2019-10-12T06:45:30.000Z","updated":"2021-11-13T10:48:21.519Z","comments":true,"path":"2019/10/12/hexo-pr/","link":"","permalink":"http://yoursite.com/2019/10/12/hexo-pr/","excerpt":"","text":"깃허브 블로그 협업하기 블로그를 멤버들이 작성하고자 할때, 깃허브라는 협업이 가능한 버전관리 시스템을 최대한 이용해야 합니다. 그럼, 개발 프로젝트와 동일한 프로세스로 블로그 작성법에 대해서 알아보도록 하겠습니다. Hexo 소스 리포지토리(https://github.com/tech-people/tech-people-source) 에서 fork 한다. fork 한 소스를 로컬로 clone 한다. 로컬에서 Hexo 작성 환경을 셋팅한다. ‘Hexo로 블로그 만들기 참고’ 글 작성후 로컬에서 테스트한다. 작성 및 테스타가 완료되면, 깃허브로 푸시하고, 원본 리포지토리 master 브랜치로 PR (Pull requests) 을 날린다. 관리자는 PR 요청을 받은 내용을 확인하고, 머지한후 블로그에 배포한다. 참고 : Pull requests 이란? 작성자 : 플랫폼 개발실","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"9. etc","slug":"it-tech/9-etc","permalink":"http://yoursite.com/categories/it-tech/9-etc/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"Pull requests","slug":"pull-requests","permalink":"http://yoursite.com/tags/pull-requests/"}]},{"title":"Hexo로 블로그 만들기","slug":"hexo","date":"2019-10-12T05:56:55.000Z","updated":"2021-11-13T10:48:21.520Z","comments":true,"path":"2019/10/12/hexo/","link":"","permalink":"http://yoursite.com/2019/10/12/hexo/","excerpt":"","text":"Hexo Hexo는 Node.js 기반 정적 사이트 생성기(Static site generator)의 일종이다. 여기서는 Hexo 와 hueman 테마를 이용하여 기업 IT 블로그를 구성해 보려고 한다. 맨 마지막에는 하나의 로컬 폴더에서 Hexo 데이터를 블로그로 배포하고, 소스를 백업하는 방법을 설명한다. 1. 설치 사전준비 node.js 설치 git 설치 깃허브에 블로그로 사용할 repository 생성 (예 : tech-people.github.io) 깃허브에 hexo 소스를 저장할 repository 생성 (예 : tech-people-source) 2. hexo 설치2.1. 설치 아래와 같이 hexo 를 설치한다. 1npm install -g hexo-cli hexo 소스를 저장하게될 github 리포지토리(tech-people-source) 를 clone 한후에 해당 위치에서 디렉토리를 생성하면 추후에 관리하기가 편한다. tech-people-source 를 clone 한후에 해당 위치에서 아래와 같이 디렉토리를 생성한후 init 을 실행한다. 12mkdir &lt;디렉토리명&gt;hexo init &lt;디렉토리명&gt; 제대로 설치되었는지 테스트해기 위해 아래와 같이 서버를 실행한다. 1hexo s (or server) 서버를 실행한 후에 웹브라우저에서 http://localhost:4000 에 접속해서 정상적으로 페이지가 나오면 설치가 완료된 것이다. 2.2. 글 작성하기 아래 명령어를 실행하면 /source/_post/ 아래에 .md 파일이 생성이 된다.1hexo new &lt;글 제목&gt; 2.3 작성한 글을 html로 만들기 아래 명령어를 실행하면 public 이라는 폴더가 생성되고, 글이 html 로 변환된다.1hexo g (or generate) 2.4 깃허브로 푸시하기 (글 배포하기) 글을 작성한 후 깃허브에 푸시해야 웹에서 블로그를 확인할수 있다. hexo에서 깃허브의 리포지토리(tech-people.github.io)로 바로 배포하려면 플러그인을 설치해야 한다. 아래의 명령어로 플러그인을 설치한다. 1npm install hexo-deployer-git --save _config.yml을 아래와 같이 수정한다. 1234deploy: type: git repo: https://github.com/tech-people/tech-people.github.io branch: master 아래의 명령어로 깃허브로 블로그를 배포(푸시)한다. 123hexo d -g orhexo deploy -generate 마지막으로 https://tech-people.github.io 에 접속하여 배포된 블로그 내용을 확인한다. 만약 수정한 내용이 반영이 안되면 아래 명령어로 기존 데이터를 삭제하고 다시 배포한다. 1hexo clean 3. Hueman 테마 설치 Hexo 설치가 마무리되었으면, Hueman 테마를 설치해 보자. 3.1. hexo init를 이용하여 만든 폴더로 이동한다.3.2. 해당 폴더에서 아래의 명령어로 hueman 테마 파일을 clone 한다. 1git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 3.3. _config.yml에서 theme 부분을 landscape 에서 hueman 으로 수정한다. 1theme: hueman 3.4. themes/hueman 폴더에 있는 _config.yml.example를 _config.yml로 파일명을 변경한다.3.5. Hueman 테마의 Insight Search 검색엔진을 사용하기 위해 hexo-generator-json-content 를 설치한다. 1npm install -S hexo-generator-json-content 3.6. hexo s (or server)를 이용하여 로컬(http://localhost:4000) 테스트를 해본다. 4. 깃허브로 블로그로 배포(푸시)하기 위에 언급한것 처럼 아래의 명령어로 배포하면 된다. 실행하면 _config.yml에 명시된 리포지토리로 배포된다.123hexo d -g orhexo deploy -generate 5. Hexo 소스 깃허브에 저장 hexo d 명령어로 배포하면 public 폴더에 있는 내용만 _config.yml에 설정된 tech-people.github.io 리포지토리로 푸시되기 때문에, 원본소스 모두를 리포지토리에 올리려면 위에서 clone 한 tech-people-source 리포지토리로 소스트리 또는 git 명령어를 이용하여 푸시하면 된다. 결론적으로 하나의 폴더의 내용을 hexo d 와 git 명령어를 통해서 각기 다른 깃허브 리포지토리를 푸시한다고 생각하면 된다. 작성자 : 플랫폼 개발실 출처 https://hyunseob.github.io/2016/02/23/start-hexo/ https://taetaetae.github.io/2016/09/18/hexo_github_blog/","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"9. etc","slug":"it-tech/9-etc","permalink":"http://yoursite.com/categories/it-tech/9-etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"마크다운 (markdown)","slug":"markdown","date":"2019-10-09T05:27:53.000Z","updated":"2021-11-13T10:48:21.525Z","comments":true,"path":"2019/10/09/markdown/","link":"","permalink":"http://yoursite.com/2019/10/09/markdown/","excerpt":"","text":"마크다운 (markdown) github 블로그 페이지에 글을 작성하기 위해서는 먼저 마크다운의 기본적인 사용법을 익혀야 합니다. 1.마크다운이란? 마크다운 (Markdown)은 마크업 언어의 일종으로, 존 그루버(John Gruber)와 아론 스워츠(Aaron Swartz)가 만들었다. 온갖 태그로 범벅된 HTML 문서 등과 달리, 읽기도 쓰기도 쉬운 문서 양식을 지향한다. 그루버는 마크다운으로 작성한 문서를 HTML로 변환하는 펄 스크립트도 만들었다. 확장자는 .md 또는 .markdown을 쓰지만, 전자가 압도적으로 많이 쓰인다. 1.1 장점 문법이 쉽다. 관리가 쉽다. 지원 가능한 플랫폼과 프로그램이 많다. 1.2 단점 표준이 없어서 사용자마다 문법이 상이하다. 모든 HTML 마크업을 대신하지 못한다. 2.문법2.1 문단 제목123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 또는 다음과 같이 사용할수 있다. 12341단계 제목=======2단계 제목------ 2.2 문단 문단을 나누기 위해서는 줄바꿈을 두번 하면 된다. 2.3 목록12345* 목록 하나* 목록 두울* 목록 세엣- 이렇게 써도- 된답니다. 순서가 있는 목록은 다음과 같이 쓴다. 이 때, 숫자는 반드시 맞춰 쓸 필요는 없다. 1234561. 첫째입니다.2. 둘째입니다.3. 셋째입니다.5. 넷째입니다. 다섯째 아닙니다.6. 이게 다섯째입니다.4. 이건 여섯째. 2.4 글자모양 글자를 굵게 하려면 다음과 같이 사용합니다. 1**굵게** 쓰거나 __두껍게__ 쓰거나 글자를 기울게 쓰려면 다음과 같이 사용합니다. 1*기울게* 쓰면서 _기울게_ 쓴다 2.5 인라인(inline) 코드 강조 숫자 1번 키 왼쪽에 있는 `(Grave)를 입력하면 됩니다. 2.6 블록(block) 코드 강조 코드 첫 줄과 마지막 줄에 Back quote ( ` ) 또는 물결( ~ ) 3개를 삽입합니다. 2.6 인용문 줄 첫번째마다 &gt; 를 쓰면 된다. 12&gt; 인용&gt;&gt; 인용 2.7 링크1[NAVER](https://naver.com &quot;링크 설명(title)을 작성하세요.&quot;) 2.8 그림 넣기123![깃허브][imgGithub] [imgGithub]: https://guides.github.com/images/logo@2x.png &quot;설명문구&quot; 2.9 가로줄 가로줄은 아래와 같이 사용합니다. 12345* * *********- - ------------- 작성자 : 플랫폼 개발실 출처 나무위키 https://heropy.blog/2017/09/30/markdown/ https://how-to-use.tistory.com/2","categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"9. etc","slug":"it-tech/9-etc","permalink":"http://yoursite.com/categories/it-tech/9-etc/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"플랫폼 개발실 - 플랫폼 엔지니어 채용","slug":"recruit","date":"2019-10-09T04:35:26.000Z","updated":"2021-11-13T10:48:21.532Z","comments":true,"path":"2019/10/09/recruit/","link":"","permalink":"http://yoursite.com/2019/10/09/recruit/","excerpt":"","text":"P&amp;T에서의 플랫폼 엔지니어란? P&amp;T는 국내 1위 실내위치기반 IoT 솔루션를 개발하는 소프트웨어 개발사로써, 데이터 분석, AI까지 단순한 솔루션이 아닌 플랫폼으로 거듭나기 위해 지속적으로 엔지니어에게 투자하고 R&amp;D를 통해 신규 비즈니스를 창출하고 있습니다. P&amp;T 플랫폼 개발실은 솔루션 개발 및 SaaS 서비스를 국내뿐만 아니라 해외(유럽, 사우디 등)에도 제공하고 있으며, 자유롭고 유연한 개발 마인드를 바탕으로, 회사의 기여뿐만 아니라 개인의 역량을 최대한 발휘하고 발전할 수 있도록 모든 지원을 아끼지 않고 있습니다 왜? 개발자가 아닌 엔지니어를 채용할까? 코더, 프로그래머, 개발자, 엔지니어 등등 다양한 명칭으로 사용되어 있는 상황에서 왜 굳이 개발자가 아닌 엔지니어라는 표현을 사용했을까요? 저희 플랫폼 개발실에서는 개발자의 역할뿐만 아니라 시스템 전체 즉 아키텍처를 볼수 있고, 다룰수 있고, 업그레이드 할수 있는 멤버들로 구성되어 있습니다. 단순히 솔루션 또는 SaaS 개발만이 아닌 클라우드를 운영하고, 애플리케이션을 모니터링하고 튜닝도 하며, 여러가지 역할에 재미를 느끼고 최선을 다할 수 있는 멤버를 찾고 있습니다 플랫폼 개발실에서는 이런 것이 있습니다 코드리뷰를 진행하고 있습니다. 2~3주 단위 릴리즈를 하고 있습니다. 개발/스테이지/QA 환경이 구분되어 있습니다. CI/CD 환경이 구축되어 있습니다. 자기 주도적으로 일할 수 있습니다. 이런 것이 없습니다. 주 1회 회의는 최대 30분을 넘기지 않습니다. 야근과 회식시 술을 강요하지 않습니다. 1. 요구기술 개발 언어 : Java or Node.js 프레임워크 : Spring Framework, Spring Boot, Spring Security, Mybatis 데이터베이스 : Mysql, Oracle, Redis 기타 : IntelliJ, Git, Jenkins, SonarQube 등 OOP 기반 개발 및 설계 개념 소프트웨어 공학 / 자료구조에 대한 기본지식 2. 자격요건 학력 : 무관 경력 : 무관 (신입도 지원 가능) 성별 : 무관 3. 공통역량 일반적인 의사소통 스킬 능동적이며 진취적인 사고 전문성 및 도전의식 새로운 기술 학습 열정이 높고 이를 공유하는데 인색하지 않은 분 4. 우대사항 AWS, Docker 사용 경험 우대 빅데이터 관련 개발 경험 우대 컴퓨터학과/소프트웨어학과/통계학과 출신 우대 5. 복지 혜택 퇴직금, 명절휴가비, 경조사비, 4대 보험 오전 10시~오후 7시 (자율 출퇴근제), 휴일 근무시 대체휴가 간식 무한 제공, 석식 제공 월별 통신비 및 교통비 지원 도서구입비 지원, Intellij 개발툴 지원 6. 채용절차 서류 전형 &gt; 1차 코딩 테스트 및 면접 &gt; 2차 임원 면접 &gt; 최종합격 신입/경력 동일하게 3개월간의 수습기간이 있습니다. 작성자 : 플랫폼 개발실","categories":[{"name":"Recruit","slug":"recruit","permalink":"http://yoursite.com/categories/recruit/"},{"name":"Platform Engineer","slug":"recruit/platform-engineer","permalink":"http://yoursite.com/categories/recruit/platform-engineer/"}],"tags":[{"name":"recruit","slug":"recruit","permalink":"http://yoursite.com/tags/recruit/"},{"name":"platform","slug":"platform","permalink":"http://yoursite.com/tags/platform/"},{"name":"engineer","slug":"engineer","permalink":"http://yoursite.com/tags/engineer/"}]}],"categories":[{"name":"IT Tech","slug":"it-tech","permalink":"http://yoursite.com/categories/it-tech/"},{"name":"4. Java","slug":"it-tech/4-java","permalink":"http://yoursite.com/categories/it-tech/4-java/"},{"name":"6. Cloud","slug":"it-tech/6-cloud","permalink":"http://yoursite.com/categories/it-tech/6-cloud/"},{"name":"3. React","slug":"it-tech/3-react","permalink":"http://yoursite.com/categories/it-tech/3-react/"},{"name":"1. IoT","slug":"it-tech/1-iot","permalink":"http://yoursite.com/categories/it-tech/1-iot/"},{"name":"5. Flutter","slug":"it-tech/5-flutter","permalink":"http://yoursite.com/categories/it-tech/5-flutter/"},{"name":"2. Data Analysis","slug":"it-tech/2-data-analysis","permalink":"http://yoursite.com/categories/it-tech/2-data-analysis/"},{"name":"9. etc","slug":"it-tech/9-etc","permalink":"http://yoursite.com/categories/it-tech/9-etc/"},{"name":"Recruit","slug":"recruit","permalink":"http://yoursite.com/categories/recruit/"},{"name":"Platform Engineer","slug":"recruit/platform-engineer","permalink":"http://yoursite.com/categories/recruit/platform-engineer/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/tags/kafka/"},{"name":"InfluxDB","slug":"influxdb","permalink":"http://yoursite.com/tags/influxdb/"},{"name":"AWS","slug":"aws","permalink":"http://yoursite.com/tags/aws/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Edge Computing","slug":"edge-computing","permalink":"http://yoursite.com/tags/edge-computing/"},{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"},{"name":"dashboard","slug":"dashboard","permalink":"http://yoursite.com/tags/dashboard/"},{"name":"data analysis","slug":"data-analysis","permalink":"http://yoursite.com/tags/data-analysis/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"springBoot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"},{"name":"beacon","slug":"beacon","permalink":"http://yoursite.com/tags/beacon/"},{"name":"Network","slug":"network","permalink":"http://yoursite.com/tags/network/"},{"name":"IoT","slug":"iot","permalink":"http://yoursite.com/tags/iot/"},{"name":"RTLS","slug":"rtls","permalink":"http://yoursite.com/tags/rtls/"},{"name":"LBS","slug":"lbs","permalink":"http://yoursite.com/tags/lbs/"},{"name":"VertX","slug":"vertx","permalink":"http://yoursite.com/tags/vertx/"},{"name":"Node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"Pull requests","slug":"pull-requests","permalink":"http://yoursite.com/tags/pull-requests/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"recruit","slug":"recruit","permalink":"http://yoursite.com/tags/recruit/"},{"name":"platform","slug":"platform","permalink":"http://yoursite.com/tags/platform/"},{"name":"engineer","slug":"engineer","permalink":"http://yoursite.com/tags/engineer/"}]}